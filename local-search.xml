<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/19/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/10/19/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><em>生命周期</em>一词常被用在产品中，来形容一个产品从诞生，到成熟，最终衰退这一系列事件的过程。</p><p>在Android中，大多数应用组件都存在生命周期，以表明该组件在应用（App）运行过程中的状态，体现在代码层面就是诸如<code>onCreate()</code>，<code>onStop()</code>等回调方法。开发者可以通过重写组件生命周期的回调方法，在组件处于创建，停止、销毁或者恢复等状态时执行相应的操作。</p><h3 id="生命周期回调简要介绍"><a href="#生命周期回调简要介绍" class="headerlink" title="生命周期回调简要介绍"></a>生命周期回调简要介绍</h3><p>让我们跟着下面这张图先来了解一下Activity生命周期的回调方法：</p><p><img src="https://developer.android.com/guide/components/images/activity_lifecycle.png" alt="img"></p><h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h4><p>Activity首次创建时执行，且只执行一次。</p><p><em>[需要注意的地方]</em></p><ol><li>执行onCreate()时Activity不可见，其内的View没有完成测量绘制（此时获取View的宽高皆为0）。</li><li>建议在onCreate()方法中对只需初始化一次的对象进行初始化操作（如初始化ViewModel，将数据绑定到列表等），不建议在其中进行耗时的操作。</li><li>onCreate()方法接收名为<code>savedInstanceState</code>的Bundle对象，该对象将存储Activity被暂时销毁时所保存的状态。您可以通过onCreate()或者onRestoreInstanceState()方法中的savedInstanceState参数来恢复界面状态。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> EDIT_TEXT_CONTENT = <span class="hljs-string">&quot;edit_text_content&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> editText: EditText<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        editText = findViewById(R.id.edit_text)<br>        <span class="hljs-comment">// 获取Activity销毁前保存的数据</span><br>        savedInstanceState?.let &#123; <br>            editText.setText(it.getString(EDIT_TEXT_CONTENT)) &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Activity重建时恢复状态</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onRestoreInstanceState</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>)</span></span> &#123;<br>        editText.setText(savedInstanceState.getString(EDIT_TEXT_CONTENT))<br>    &#125;<br><br>    <span class="hljs-comment">// Activity异常销毁前执行该方法，保存界面状态</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(outState: <span class="hljs-type">Bundle</span>)</span></span> &#123;<br>        outState.putString(EDIT_TEXT_CONTENT, editText.text.toString())<br>        <span class="hljs-keyword">super</span>.onSaveInstanceState(outState)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h4><p>Activity对用户可见时调用，可被onRestart()方法重复调用。</p><p>*[需要注意的地方]*：</p><ol><li>执行onStart()时Activity内的view没有获得焦点，与用户不可交互。</li><li>建议在onStart()中执行动画的初始化和开启操作，以及需要重新恢复的对象初始化（如操作View的Handler的重新初始化，视频播放和相机拍照等功能的重新初始化）。</li><li>不建议在onStart()中进行耗时操作。</li></ol><h4 id="onResume"><a href="#onResume" class="headerlink" title="onResume()"></a>onResume()</h4><p>Activity来到前台，准备与用户交互时调用。</p><p>*[需要注意的地方]*：</p><ol><li>Activity会一直保持这种状态，直到某些像接到来电、跳转到另一Activity等事件发生，让焦点远离当前Activity。</li><li>建议在onResume()方法中执行耗时操作，以及重新恢复视频播放等操作。</li></ol><blockquote><p>穿插一个<strong>前台</strong>和<strong>后台</strong>概念的解释：</p><p>前台（Foreground）指App可见，可与用户交互。即我们打开一个App，正常与其交互的过程。</p><p>后台（Background）指App不可见，不可交互。如我们打开网易云音乐播放一首音乐，这时QQ来了一条消息，于时我们暂时退出网易云音乐，打开QQ查看消息。此时的网易云音乐App就处于后台播放音乐，不可见也不可交互，但仍然可以播放音乐。</p></blockquote><h4 id="onPause"><a href="#onPause" class="headerlink" title="onPause()"></a>onPause()</h4><p>Activity从前台切换到后台时调用。</p><p>*[需要注意的地方]*：</p><ol><li>执行onPause()时Activity可见，但不可交互。</li><li>onPause()执行非常简单，建议进行只与当前Activity有关的对象的资源释放（如动画的暂停）。</li><li>不建议在onPause()中进行保存应用数据或网络请求等耗时操作。</li></ol><h4 id="onStop"><a href="#onStop" class="headerlink" title="onStop()"></a>onStop()</h4><p>Activity对用户不可见时调用。</p><p>*[需要注意的地方]*：</p><ol><li>执行onStop()时，Activity与用户不可交互。</li><li>建议在onStart()中释放可能在其他Activity中使用到的对象资源（如Camera2，VideoView等），或执行CPU相对密集的关闭操作（如将数据保存到数据库中）。</li></ol><h4 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy()"></a>onDestroy()</h4><p>Activity被销毁前调用。</p><p>*[需要注意的地方]*：</p><ol><li>onDestroy()被调用的原因主要有有两个：一是<em>用户彻底关闭该Activity</em>或者<em>系统由于内存不足释放Activity所在的进程，从而销毁Activity</em>；二是<em>由于屏幕旋转或多窗口模式等配置变更的情况发生，导致系统暂时销毁Activity</em>。</li><li>在onDestroy()中应释放Activity剩余的所有资源，以防止内存泄漏的情况发生。</li><li>当配置变更导致Activity被暂时销毁时，实际上是包裹Activity的外部容器宽高发生了变化，其内的子View也需要重新进行测量和布局。此时可以在<code>AndroidManifest.xml</code>文件中配置Activity的<code>android:configChanges=&quot;orientation|screenSize&quot;</code>属性，旋转屏幕时不会重新调用各个生命周期（以及<code>onSaveInstanceState()</code>和<code>onRestoreInstanceState()</code>），只会执行Activity内的<code>onConfigurationChanged()</code>方法。</li></ol><h3 id="常用生命周期执行顺序"><a href="#常用生命周期执行顺序" class="headerlink" title="常用生命周期执行顺序"></a>常用生命周期执行顺序</h3><table><thead><tr><th>事件</th><th>生命周期</th></tr></thead><tbody><tr><td>第一次启动</td><td>onCreate() -&gt; onStart() -&gt; onResume()</td></tr><tr><td>从 A 跳转到 B</td><td>A_onPause() -&gt; B_onCreate() -&gt; B_onStart() -&gt; B_onResume() -&gt; A_onStop()</td></tr><tr><td>从 B 再次回到 A</td><td>B_onPause() -&gt; A_onRestart() -&gt; A_onStart() -&gt; A_onResume() -&gt; B_onStop()</td></tr><tr><td>用户按 home 键&#x2F;锁屏</td><td>onPause() -&gt; onStop()</td></tr><tr><td>按 home 键后回到应用&#x2F;亮屏</td><td>onRestart() -&gt; onStart() -&gt; onResume()</td></tr><tr><td>用户按 back 键回退</td><td>onPause() -&gt; onStop() -&gt; onDestroy()</td></tr></tbody></table><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p><code>Fragment</code>表示应用界面中可重复使用的一部分。它依赖于其他Activity或Fragment存活，<strong>具有属于自己的生命周期</strong>，可以定义、管理自己的布局，处理自己的输入事件等。</p><p>Fragment被定义为<strong>一个轻量级Activity</strong>而进行设计。一个Activity中可包含多个Fragment，实现界面的<strong>解耦</strong>和<strong>模块化</strong>；一个Fragment可以被使用在多个Activity里，提高界面的<strong>可重用性</strong>。</p><h3 id="生命周期回调简要介绍-1"><a href="#生命周期回调简要介绍-1" class="headerlink" title="生命周期回调简要介绍"></a>生命周期回调简要介绍</h3><p>Fragment的生命周期和Activity十分相似，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/4625401-a37a7c32683ecda6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340/format/webp" alt="img"></p><p>可以发现Fragment只比Activity多了几个方法。这里对Fragment生命周期回调方法进行一个简单的介绍：</p><ol><li>**onAttach()**：Fragment与Activity发生关联时调用。</li><li>**onCreate()**：Fragment被创建时调用。</li><li>**onCreateView()**：创建、绘制Fragment内部的View组件时调用，该方法返回创建成功的View组件。</li><li>**onActivityCreated()**：当Fragment所在的Activity启动完成时调用。</li><li>**onStart()**：Fragment启动时调用，此时Fragment可见。</li><li>**onResume()**：Fragment恢复时调用，此时获取焦点，可与用户交互。</li><li>**onPause()**：Fragment暂停时调用，此时失去焦点，但仍然可见。</li><li>**onStop()**：Fragment停止时调用，此时Fragment不可见。</li><li>**onDestroyView()**：销毁与Fragment有关的视图，但未与Activity解除绑定。</li><li>**onDestroy()**：Fragment销毁时调用。</li><li>**onDetach()**：Fragment与Activity取消关联时调用。</li></ol><h3 id="常用生命周期执行顺序-1"><a href="#常用生命周期执行顺序-1" class="headerlink" title="常用生命周期执行顺序"></a>常用生命周期执行顺序</h3><table><thead><tr><th>事件</th><th>生命周期</th></tr></thead><tbody><tr><td>第一次创建</td><td>onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onActivityCreated() -&gt; onStart() -&gt; onResume()</td></tr><tr><td>切换到其他Fragment</td><td>onPause() -&gt; onStop() -&gt; onDestroyView()</td></tr><tr><td>切换回本身的Fragment</td><td>onCreateView() -&gt; onActivityCreated() -&gt; onStart() -&gt; onResume()</td></tr><tr><td>用户按 home 键&#x2F;锁屏</td><td>onPause() -&gt; onStop()</td></tr><tr><td>按 home 键后回到应用&#x2F;亮屏</td><td>onStart() -&gt; onResume()</td></tr><tr><td>用户按 back 键回退</td><td>onPause() -&gt; onStop() -&gt; onDestroyView() -&gt; onDestroy() -&gt; onDetach()</td></tr></tbody></table><h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p><code>Service</code>是一种<strong>可在后台执行</strong>长时间运行操作而<strong>不提供界面</strong>的应用组件。</p><h2 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h2><p>Service的启动有两种方式：<strong>startService</strong>和<strong>bindService</strong>。Service的生命周期也因为启动方式的不同分为两种，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/4625401-756d89b600d55081.png" alt="img"></p><h3 id="startService"><a href="#startService" class="headerlink" title="startService()"></a>startService()</h3><ol><li><p>**onCreate()**：首次创建服务时调用，且只执行一次。</p></li><li><p>**onStartCommand()**：当组件通过<code>startService()</code>方法启动服务调用，多次启动服务时<code>onStartCommand()</code>调用多次。</p><blockquote><p>事实上<code>onStartCommand()</code>的返回值有四种：<em>START_STICKY_COMPATIBILITY</em>（不保证服务被杀死后onStartCommand()方法会被重新调用）、<em>START_STICKY</em>（Service被杀死后保持服务为started状态，但不会获取到Intent信息）、<em>START_NOT_STICKY</em>（当Service运行的进程被Android系统强制杀掉之后不会重新创建该Service）、<em>START_REDELIVER_INTENT</em>（服务进程在执行完onStartCommand()之后被杀死，将会被安排重启，且传递最近的intent）。这些参数在原生安卓机上没问题，但国内安卓设备厂商会为了提高系统安全性修改源码，导致上面这些参数都不会真正起到作用。</p></blockquote></li><li><p>**onDestroy()**：当组件使用<code>stopService()</code>方法或者服务自身执行<code>stopSelf()</code>方法时调用，多次停止服务时<code>onDestroy()</code>只会执行一次。</p><blockquote><p>stopSelf()方法接收一个int参数，同<code>onStartCommand()</code>方法传递进来的startId对应。</p><p>需要注意的是，如果在<code>onStartCommand()</code>方法中执行stopSelf()时Service不会立刻停止，只有**当<code>onStartCommand()</code>全部执行完后才会调用<code>onDestroy()</code>**。</p><p>同样地，如果在Activity的<code>onCreate()</code>方法里调用<code>finish()</code>方法也不会立刻销毁Activity，而是**等<code>onCreate()</code>方法全部执行完才进入<code>onDestroy()</code>**。</p><p>这是因为在调用<code>finish()</code>时系统只是将当前的Activity移出了栈，并没有及时地调用<code>onDestroy()</code>方法，其占用的资源也没有别及时释放。</p></blockquote></li></ol><p>*[需要注意的地方]*：通过startService()方式启动的服务<strong>独立于</strong>启动它的组件，也就是说即使启动该服务的组件销毁了，Service仍然可以继续运行。但是这也导致了Service与组件的通信较为困难（可使用BroadcastReceiver进行通信）。</p><h3 id="bindService"><a href="#bindService" class="headerlink" title="bindService()"></a>bindService()</h3><ol><li>**onCreate()**：同<code>startService()</code>。</li><li>**onBind()**：当组件通过<code>bindService()</code>方法与服务绑定时调用。同时这也是Service类里唯一的抽象方法，开发者必须实现该方法，并返回一个IBinder对象，供客户端（组件）与服务端（Service）的进行通信。</li><li>**onUnbind()**：当所有与该服务绑定的组件都解除绑定时调用。</li></ol><p>*[需要注意的地方]*：</p><ol><li>一个服务可以被多个组件绑定，当绑定到该服务上的所有组件<strong>都被销毁</strong>时，服务才会停止。</li><li>先<code>startService()</code>再<code>bindService()</code>的生命周期：onCreate()  -&gt; onStartCommand() -&gt; onBind() -&gt; onUnbind() -&gt; onDestroy()。</li><li>先<code>bindService()</code>再<code>startService()</code>的生命周期：onCreate() -&gt; onBind() -&gt; onStartCommand() -&gt; onUnbind() -&gt; onDestroy()。</li></ol><h2 id="Service使用"><a href="#Service使用" class="headerlink" title="Service使用"></a>Service使用</h2><p>Service的使用分为三步：创建Service，注册Service，启动Service。</p><h3 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h3><p>这里以一个播放音乐的服务为例说明，创建<code>MusicService</code>类，使其继承Service，并重写其中的onBind()方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MusicService</span>: <span class="hljs-type">Service</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBind</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span>: IBinder? &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>onBind()</code>方法返回一个IBinder的实现对象。IBinder是Android提供的进程间和跨进程调用机制的接口，在Service里，它是组件与Service通信的重要桥梁。</p><p>因此如果我们选择使用<code>bindService()</code>启动服务，则需要在MusiceService里创建一个继承自Binder（而不是IBinder）的内部类，将其作为<code>onBind()</code>方法的返回值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MusicService</span>: <span class="hljs-type">Service</span>() &#123;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBind</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span>: IBinder &#123;<br>        <span class="hljs-keyword">return</span> MyBinder()<br>    &#125;<br><br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBinder</span>: <span class="hljs-type">Binder</span>() &#123;<br>        <span class="hljs-keyword">val</span> service: MusicService <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span><span class="hljs-symbol">@MusicService</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注册Service"><a href="#注册Service" class="headerlink" title="注册Service"></a>注册Service</h3><p>Android四大组件在使用时都需要在<code>AndroidManifest.xml</code>中对其进行注册，这里我们对刚创建的MusicService进行注册：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">service</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.service.MusicService&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="启动Service"><a href="#启动Service" class="headerlink" title="启动Service"></a>启动Service</h3><p>在生命周期中我们已经提到过Service的两种启动方式，现在来看一看它们的代码实现：</p><h4 id="通过startService-启动"><a href="#通过startService-启动" class="headerlink" title="通过startService()启动"></a>通过startService()启动</h4><p>由于通过<code>startService()</code>启动的Service与组件是相互独立的，因此这里不需要过多的配置：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">startService(Intent(<span class="hljs-keyword">this</span>, MusicService::<span class="hljs-keyword">class</span>.java)) <span class="hljs-comment">// 启动服务</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">stopService(Intent(<span class="hljs-keyword">this</span>, MusicService::<span class="hljs-keyword">class</span>.java))  <span class="hljs-comment">// 停止服务</span><br></code></pre></td></tr></table></figure><h4 id="通过bindService-启动"><a href="#通过bindService-启动" class="headerlink" title="通过bindService()启动"></a>通过bindService()启动</h4><p><code>bindService()</code>方法接收三个参数：Intent、ServiceConnection和flag。</p><ol><li><p>第一个参数Intent同<code>startService()</code>一样，为当前组件到目标Service的Intent。</p></li><li><p>第二个参数为ServiceConnection接口的具体实现类，在其中有<code>onServiceConnected()</code>和<code>onServiceDisconnected()</code>两个方法可以<strong>异步监听服务的连接与断开事件</strong>，可以充当组件与Service连接的桥梁。我们通常在其中拿到对应的Binder实例，进而通过Binder拿到Service内的实例或调用其内的方法，并判断当前Service是否已绑定：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mMusicService: MusicService <span class="hljs-comment">// Service实例</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mBound: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">// 服务是否已绑定</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> connection = <span class="hljs-keyword">object</span> : ServiceConnection &#123;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(className: <span class="hljs-type">ComponentName</span>, service: <span class="hljs-type">IBinder</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> binder = service <span class="hljs-keyword">as</span> MusicService.MyBinder<br>        mMusicService = binder.service<br>        mBound = <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(className: <span class="hljs-type">ComponentName</span>)</span></span> &#123;<br>        mBound = <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>第三个参数为该方法的标志位，通常我们选择<code>Context.BIND_AUTO_CREATE</code>作为该参数的值，表示若绑定服务未启动则自动启动服务。</p></li></ol><h2 id="Service与应用组件通信"><a href="#Service与应用组件通信" class="headerlink" title="Service与应用组件通信"></a>Service与应用组件通信</h2><p>通过startService()方法启动服务时，服务于组件独立，因此需要全局广播来实现服务与组件的通信，我们稍后在BroadcastReceiver的知识里继续讲解。</p><p>这里我们继续以MusicService为例讲解通过bindService()方式启动Service时如何与组件进行通信。</p><p>首先在MusicService里定义一个MediaPlayer对象，用来操作音频对象。在onCreate()里初始化MediaPlayer，在onDestroy()里释放。同时在MusicService里对外开放play()和pause()两个方法来控制音乐的播放和暂停，以及isPlaying()判断音乐是否正在播放。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MusicService</span> : <span class="hljs-type">Service</span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> player: MediaPlayer<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> binder = MyBinder()<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate()<br>        player = MediaPlayer.create(<span class="hljs-keyword">this</span>, R.raw.music)<br>    &#125;<br>    <br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBinder</span> : <span class="hljs-type">Binder</span>() &#123;<br>        <span class="hljs-keyword">val</span> service: MusicService <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span><span class="hljs-symbol">@MusicService</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBind</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>?)</span></span> = binder<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        player.let &#123;<br>            it.stop()<br>            it.release() &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span> &#123; player.start() &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pause</span><span class="hljs-params">()</span></span> &#123; player.pause() &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isPlaying</span><span class="hljs-params">()</span></span> = player.isPlaying<br>&#125;<br></code></pre></td></tr></table></figure><p>在Activity内获取到Service，并绑定相应的点击事件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> KEY_IS_PLAYING = <span class="hljs-string">&quot;is_playing&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">LogActivity</span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> playMusic: ImageView<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mMusicService: MusicService <span class="hljs-comment">// Service实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mBound: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">// 服务是否已绑定</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> connection = <span class="hljs-keyword">object</span> : ServiceConnection &#123;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(className: <span class="hljs-type">ComponentName</span>, service: <span class="hljs-type">IBinder</span>)</span></span> &#123;<br>            <span class="hljs-keyword">val</span> binder = service <span class="hljs-keyword">as</span> MusicService.MyBinder<br>            mMusicService = binder.service <span class="hljs-comment">// 获取Service实例</span><br>            mBound = <span class="hljs-literal">true</span><br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(className: <span class="hljs-type">ComponentName</span>)</span></span> &#123;<br>            mBound = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        findViewById(R.id.ib_play_music).setOnClickListener &#123;<br>            <span class="hljs-keyword">if</span> (!mBound) <span class="hljs-keyword">return</span><span class="hljs-symbol">@setOnClickListener</span><br>            <span class="hljs-keyword">if</span> (mMusicService.isPlaying()) &#123;<br>                <span class="hljs-comment">// 暂停播放</span><br>                mMusicService.pause()<br>                playMusic.setImageResource(R.drawable.ic_play)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 开始播放</span><br>                mMusicService.play()<br>                playMusic.setImageResource(R.drawable.ic_pause)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 两种方式同时启动服务</span><br>        startService(Intent(<span class="hljs-keyword">this</span>, MusicService::<span class="hljs-keyword">class</span>.java))<br>        Intent(<span class="hljs-keyword">this</span>, MusicService::<span class="hljs-keyword">class</span>.java).also &#123; intent -&gt;<br>            bindService(intent, connection, BIND_AUTO_CREATE)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;===onDestroy===&quot;</span>)<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        unbindService(connection)<br>        mBound = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onRestoreInstanceState</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>)</span></span> &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;===onRestoreInstanceState===&quot;</span>)<br>        <span class="hljs-keyword">if</span> (savedInstanceState.getBoolean(KEY_IS_PLAYING)) &#123;<br>            playMusic.setImageResource(R.drawable.ic_pause)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(outState: <span class="hljs-type">Bundle</span>)</span></span> &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;===onSaveInstanceState===&quot;</span>)<br>        <span class="hljs-keyword">super</span>.onSaveInstanceState(outState)<br>        outState.putBoolean(KEY_IS_PLAYING, mMusicService.isPlaying())<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onConfigurationChanged</span><span class="hljs-params">(newConfig: <span class="hljs-type">Configuration</span>)</span></span> &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;===onConfigurationChanged===&quot;</span>)<br>        <span class="hljs-keyword">super</span>.onConfigurationChanged(newConfig)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后需要注意的是，Service是运行在主线程中的，因此不能执行耗时的或者密集型的任务，需要在服务中额外开启线程执行，或者使用官方提供的IntentService。</p><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><p>Notification能够在App界面之外向用户显示消息。</p><h3 id="Notification介绍"><a href="#Notification介绍" class="headerlink" title="Notification介绍"></a>Notification介绍</h3><h4 id="Notification组成"><a href="#Notification组成" class="headerlink" title="Notification组成"></a>Notification组成</h4><p>关于通知在设备上的外观有很多种，如状态栏通知图标、抽屉式通知栏和锁屏时的通知等，具体可直接前往<a href="https://developer.android.com/guide/topics/ui/notifiers/notifications">Android官网</a>查询。</p><p>这里我们主要介绍一下通知的组成，如下图所示：</p><p><img src="https://developer.android.com/images/ui/notifications/notification-callouts_2x.png" alt="img"></p><ol><li>小图标：必须提供，通过 <code>setSmallIcon()</code> 进行设置。</li><li>应用名称：由系统提供。</li><li>时间戳：由系统提供，但您可以使用 <code>setWhen()</code> 替换它或者使用 <code>setShowWhen(false)</code> 隐藏它。</li><li>大图标：可选内容（通常仅用于联系人照片，请勿将其用于应用图标），通过 <code>setLargeIcon()</code> 进行设置。</li><li>标题：可选内容，通过 <code>setContentTitle()</code> 进行设置。</li><li>文本：可选内容，通过 <code>setContentText()</code> 进行设置。</li></ol><h4 id="不同版本下的Notification"><a href="#不同版本下的Notification" class="headerlink" title="不同版本下的Notification"></a>不同版本下的Notification</h4><p>对不同版本下的Notification作简要了解，我们主要关注Android8.0版本的Notification。</p><ul><li><p>Android 4.1（API 级别 16）</p><p>引入了展开式通知模板（称为通知样式），可以提供较大的通知内容区域来显示信息。用户可以使用单指向上&#x2F;向下滑动的手势来展开通知。</p></li><li><p>Android 5.0（API 级别 21）</p><p>引入了锁定屏幕和浮动通知。<br>向 API 集添加了通知是否在锁定屏幕上显示的方法 (setVisibility())，以及指定通知文本的“公开”版本的方法。<br>添加了 setPriority() 方法，告知系统该通知应具有的“干扰性”（例如，将其设置为“高”，可使该通知以浮动通知的形式显示）</p></li><li><p>Android 7.0（API 级别 24）</p><p>用户可以使用内联回复直接在通知内回复（用户可以输入文本，然后将其发送给通知的父级应用）。</p></li><li><p>Android 8.0（API 级别 26）</p><p>现在必须将单个通知放入特定渠道中。<br>用户现在可以按渠道关闭通知，而不是关闭应用的所有通知。<br>包含活动通知的应用会在应用图标上方显示通知“标志”。（小圆点或数字）<br>用户可以暂停抽屉式通知栏中的通知。您可以为通知设置自动超时。<br>可以设置通知的背景颜色。</p></li></ul><h3 id="Notification使用"><a href="#Notification使用" class="headerlink" title="Notification使用"></a>Notification使用</h3><p>发送一条简单的通知只需要三步：</p><ol><li><p>创建渠道：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> String createNotificationChannel(String channelID, String channelNAME, int level) &#123;<br>       <span class="hljs-keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;<br>           NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);<br>           NotificationChannel channel = new NotificationChannel(channelID, channelNAME, level);<br>           manager.createNotificationChannel(channel);<br>           <span class="hljs-keyword">return</span> channelID;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>设置点击事件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Intent intent = new Intent(<span class="hljs-keyword">this</span>, Main2Activity.<span class="hljs-keyword">class</span>);<br>intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);<br>PendingIntent pendingIntent = PendingIntent.getActivity(<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, intent, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>构造Notification对象并显示通知</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Intent intent = new Intent(<span class="hljs-keyword">this</span>, Main2Activity.<span class="hljs-keyword">class</span>);<br>intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);<br>PendingIntent pendingIntent = PendingIntent.getActivity(<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, intent, <span class="hljs-number">0</span>);<br>String channelId = createNotificationChannel(<span class="hljs-string">&quot;my_channel_ID&quot;</span>, <span class="hljs-string">&quot;my_channel_NAME&quot;</span>, NotificationManager.IMPORTANCE_HIGH);<br>NotificationCompat.Builder notification = new NotificationCompat.Builder(<span class="hljs-keyword">this</span>, channelId)<br>            .setContentTitle(<span class="hljs-string">&quot;通知&quot;</span>)<br>            .setContentText(<span class="hljs-string">&quot;收到一条消息&quot;</span>)<br>            .setContentIntent(pendingIntent)<br>            .setSmallIcon(R.mipmap.ic_launcher)<br>            .setPriority(NotificationCompat.PRIORITY_HIGH)<br>            .setAutoCancel(<span class="hljs-literal">true</span>);<br>NotificationManagerCompat notificationManager = NotificationManagerCompat.from(<span class="hljs-keyword">this</span>);<br>notificationManager.notify(<span class="hljs-number">100</span>, notification.build());<br></code></pre></td></tr></table></figure></li></ol><p>通过RemoteView自定义Notification样式。</p><h2 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h2><h1 id="BroadcastRecevier"><a href="#BroadcastRecevier" class="headerlink" title="BroadcastRecevier"></a>BroadcastRecevier</h1><p>在Android系统中，广播（Broadcast）是组件间传播数据的一种机制，对于不同进程中的组件，广播起到了进程间组件通信的作用。</p><p>而广播接收器（BroadcastReceiver）则是<strong>对发送出来的Broadcast进行过滤、接受和响应</strong>的组件。</p><p>Android中的广播（Broadcast）分为两种：</p><ol><li><strong>标准广播</strong>：标准广播是一种完全<strong>异步执行</strong>的广播，标准广播发出后，所有的广播接收器都会在同一时间接收到该广播，没有先后顺序，效率较高，且无法截断。</li><li><strong>有序广播</strong>：有序广播是一种<strong>同步执行</strong>的广播，有序广播发出后同一时间只能有一个广播接收器能够接收到，优先级高的广播会先接受，可选择截断。</li></ol><h2 id="注册广播"><a href="#注册广播" class="headerlink" title="注册广播"></a>注册广播</h2><p>广播的注册方法有两种：静态注册和动态注册。</p><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><blockquote><p>Android8.0以上静态注册的隐式广播无法发送，但仍然可以发送静态显示广播。</p></blockquote><p>首先创建一个简单的广播接收器，在其onReceive()方法内弹出一个Toast表示已收到广播：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyReceiver</span>: <span class="hljs-type">BroadcastReceiver</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>?, intent: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>        Toast.makeText(context, <span class="hljs-string">&quot;收到广播&quot;</span>, Toast.LENGTH_SHORT).show()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>AndroidManifest.xml</code>里注册广播接收器组件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;application&gt;<br>    &lt;receiver android:name=<span class="hljs-string">&quot;.broadcastreceiver.MyReceiver&quot;</span> /&gt;<br>&lt;/application&gt;<br></code></pre></td></tr></table></figure><p>发送显示广播：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">sendBroadcast(Intent(<span class="hljs-keyword">this</span>, MyReceiver::<span class="hljs-keyword">class</span>.java))<br></code></pre></td></tr></table></figure><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册 BroadcastReceiver 是在代码中定义并设置好一个 <strong>IntentFilter</strong> 对象，然后在需要注册的地方调用 <strong>Context.registerReceiver()</strong> 方法，调用 <strong>Context.unregisterReceiver()</strong> 方法取消注册，此时就不需要在清单文件中注册 Receiver 了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">registerReceiver(<span class="hljs-keyword">object</span> : BroadcastReceiver()&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(p0: <span class="hljs-type">Context</span>?, p1: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>        Toast.makeText(<span class="hljs-keyword">this</span><span class="hljs-symbol">@MainActivity</span>, <span class="hljs-string">&quot;收到广播&quot;</span>, Toast.LENGTH_SHORT).show()<br>    &#125;<br>&#125;, IntentFilter(<span class="hljs-string">&quot;com.course.broadcastreceiver&quot;</span>))<br></code></pre></td></tr></table></figure><h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><p>ContentProvider主要用于在<strong>不同的应用程序之间实现数据共享</strong>的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。目前，使用ContentProvider是Android实现跨程序共享数据的标准方式。</p><p>具体在两方面发挥作用：</p><ol><li>获取其他进程的数据</li><li>将自己的数据提供给其他进程</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/19/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/10/19/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Android性能优化"><a href="#Android性能优化" class="headerlink" title="Android性能优化"></a>Android性能优化</h1><p>性能优化是一个app很重要的一部分，一个性能优良的app从被下载到启动到使用都能给用户到来很好的体验。自然我们做性能优化也是从被下载（安装包优化）、启动（启动优化）、使用（渲染优化、耗电优化、内存优化………）等入手。因为我也是个菜鸟，所有东西都是现学的，所以过程中有任何问题都可以提出来，大家一起长知识。</p><h2 id="安装包优化"><a href="#安装包优化" class="headerlink" title="安装包优化"></a>安装包优化</h2><p>当今手机的内存普遍是128G或者256G，当用户长时间使用，产生了大量数据后，留给app安装的空间可能只有几十个G，甚至更少。所以一个app的大小可能就决定了用户是否选择你。</p><h6 id="优化方案："><a href="#优化方案：" class="headerlink" title="优化方案："></a>优化方案：</h6><ol><li><p>清理无用资源</p><p>在app打包的时候一些废弃的代码和无用的资源可能也会被打包，这无疑会增加app的体积。好在Android Studio有这么一个检测无用资源和代码的功能。具体方法是【Refactor】-&gt;【Remove Unused Resources..】</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220707220022.png" style="zoom: 80%;" /><p>再点击【Preview】可查看和选择无用的资源和代码。</p></li><li><p>使用Lint工具检查代码</p><p>Android-Lint是as集成的一个代码检查工具，它可以检测图片是否重复，优化xml布局等等。</p><p>具体使用是Android Studio -&gt; 【Code】-&gt; 【Inspect Code】</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708002040.png"></p><p>Lint问题的种类：</p><ul><li>Correctness 不够完美的编码，比如硬编码、使用过时 API 等</li><li>Performance 对性能有影响的编码，比如：静态引用，循环引用等</li><li>Internationalization 国际化，直接使用汉字，没有使用资源引用等</li><li>Security 不安全的编码，比如在 WebView 中允许使用 JavaScriptInterface 等</li><li>Usability 可用的，有更好的替换的 比如排版、图标格式建议.png格式 等</li><li>Accessibility 辅助选项，比如ImageView的contentDescription往往建议在属性中定义 等</li></ul><p>具体的一些问题种类的细分我这里就不多说了，可以看看这篇博客:</p><p><a href="https://www.freesion.com/article/250513772/">Android性能优化之 Android Lint - 灰信网（软件开发博客聚合） (freesion.com)</a></p></li><li><p>使用shrinkResources</p><p>我们知道缩小APK大小的方法除了开启混淆外</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">minifyEnabled <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>还有</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">shrinkResources <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>这里说一下，minifyEnabled 是用来删除无用的代码，shrinkResources是用来删除无用的文件（但其实不是真正的删除，只是保留文   件名但是没有内容）。还有要注意，shrinkResources需要与minifyEnabled 来配合使用，只有当minifyEnabled 为true的时候    shrinkResources才会起作用。但是有时候我们可能添加了一张图片只是作为验证，并未引用，这时候shrinkResources可能就会误删，怎么办呢？很简单，新增一个res&#x2F;raw&#x2F;keep.xml文件，并在文件如下编码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span> <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:keep</span>=<span class="hljs-string">&quot;@drawable/xxxx,@layout/xxxxx&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>keep里面就列举需要保留误删的资源。</p><p>注：string.xml中没有被引用的怎么设置都不会被删除，shrinkResources删除的只是drawable和layout</p></li><li><p>资源压缩</p><p>在Android中，使用的图片是比较多的，这些图片是很占用资源的，对图片进行压缩和择优选择也是app瘦身的一种方案。</p><p>（1）使用tinypng等图片压缩工具对图片进行压缩，然后替换之前的图片</p><p>（2）尽量将图片都用Webp格式的，其次是JPG格式，再是PNG格式</p><p>（3）使用SVG，矢量图能比位图节约30%~40%的空间</p><p>（4）尽量不要在项目中使用帧动画，一秒就十几张图片也是很耗内存的，使用Lottie等方案</p><p>（5）重用Bitmap，不使用了记得回收</p><p>（6）可以使用微信开源资源文件混淆工具——AndResGuard。一般可以压缩apk的1M左右大。</p></li><li><p>其他方法</p><ul><li><p>动态加载so库文件，插件化开发；</p></li><li><p>统一第三方库，在满足需求的前提下选择体积更小的库，仅引入需要的代码。比如图片加载库，按缓存的需要来我们可以对图片加载库做个排序：Picasso &lt; Android-Universal-Image-Loader &lt; Glide &lt; Fresco，Fresco体积比较大，一般用于图片缓存量比较大的app，比如壁纸app，一般Glide可满足日常需求，Picasso体积最小，它与和Square的网络库一起能发挥最大作用，因为Picasso可以选择将网络请求的缓存部分交给了okhttp实现；</p></li><li><p>避免使用枚举，可能几十个枚举才相当于一张图片，但是积少成多嘛；</p></li><li><p>在多国语言需求不大的情况下可以删除其他国家的语言，只保留中文和英文。</p></li><li><p>再深入一点的还有字节码优化等等等</p></li></ul></li></ol><h2 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h2><p>启动优化可以说是性能优化里很重要很重要的一个部分了，用户拿到你的app，第一印象自然是app启动的界面，app启动的流畅度和时间长短，可以说启动性能就是一个app的门面。（最讨厌app启动时候的广告了）</p><p>大家可能都听说过2-5-8原则：</p><ul><li>当用户在0-2秒之间得到响应时，会觉得系统响应得很快</li><li>当用户在2-5秒之间得到响应时，会感觉系统的响应速度还可以</li><li>当用户在5-8秒之间得到响应时，会感觉系统响应得速度很慢，但是还能接受</li><li>当用户在超过8秒还无法得到响应时，会感觉系统很垃圾，认为系统已经挂了</li></ul><p>所以不管你的app做的再怎么牛逼，用户点进你的app，反应速度让他很失望，用户也无继续使用的欲望。那么我们应该如何去规划整体的启动优化呢？具体方案如下：</p><h5 id="冷启动、热启动和温启动"><a href="#冷启动、热启动和温启动" class="headerlink" title="冷启动、热启动和温启动"></a>冷启动、热启动和温启动</h5><p>什么是冷启动、热启动、温启动？</p><ul><li>冷启动：系统不存在App进程（如APP首次启动或APP被完全杀死）时启动App称为冷启动。</li><li>热启动：按了Home键或其它情况app被切换到后台，再次启动App的过程。</li><li>温启动：温启动包含了冷启动的一些操作，不过App进程依然存在，这代表着它比热启动有更多的开销。</li></ul><p>由此可见启动最慢的是冷启动，最快的是热启动。着重优化的地方也是冷启动。</p><p>在冷启动下会进行如下的相关流程</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708125305.png"></p><p>与我们代码相关的只有创建Application之后到首帧绘制之前。</p><ol><li><h3 id="Application创建"><a href="#Application创建" class="headerlink" title="Application创建"></a>Application创建</h3><p>当Application启动时，空白的启动窗口将保留在屏幕上，直到系统首次完成绘制应用程序。此时，系统进程会交换应用程序的启动窗口，允许用户开始与应用程序进行交互。这就是为什么我们的程序启动时会先出现一段时间的黑屏(白屏)，但其实市面上很多app启动都是有一个logo的，再是页面。</p><p>如何解决？</p><p>在themes.xml定义一个主题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;WelcomeTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.NoActionBar&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--设置背景颜色或者图片--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/xxxx<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--设置没有ActionBar--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowNoTitle&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--设置顶部状态栏颜色--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:statusBarColor&quot;</span> &gt;</span>@color/xxxx<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ图片20220708143206.jpg" alt="img" style="zoom:80%;" /><p>但是这样也改变了activity启动后的theme，所以还得在onCreate方法中将主题还原，即</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setTheme(R.style.Theme_Universe); <span class="hljs-comment">//恢复原有的样式</span><br>        setContentView(R.layout.activity_main)<br>    &#125;<br></code></pre></td></tr></table></figure><p>当然也可另外用一个activity来用作启动的activity，在里面也可以做一些延时的操作或者加入开屏广告什么的一些操作。</p><p>我们很多时候并不是用系统默认的Application，更多的时候是自定义一个MyApplication，然后在里面做一些初始化的操作。但是如果需要初始化的东西太多了，比如友盟，Bugly，网络请求库，图片加载库，ARouter等，势必会拖慢app的启动速度。那怎么办呢？这些又都是必须要的。只能异步加载了，或者等应用内启动之后再初始化。这里给出一些比价简单的优化操作：</p><ol><li>可以在Application中封装两个方法一个onSyncLoad，一个onAsyncLoad。比如像友盟，Bugly这样的业务非必要的可以的异步加载。可以放在onAsyncLoad中初始化；对于图片，网络请求框架就放在onSyncLoad中初始化。可能有人会觉得onAsyncLoad中异步会额外开销一个Thread，但其实当一个app体量变大后，开销一个Thread带来的收益是远远大于原来同步初始化的</li><li>我们知道ContentProvider作为Android四大组件之一，它的onCreate方法是在Application.attachBaseContext() 和 Application.onCreate()之间执行的（原理后面说），所以我们也可以间接使用它来初始化操作以减轻Application的负担，这也是很多第三方库的做法，比如LeakCanary、Picasso。但是这样也有弊端，要知道ContentProvider属于四大组件之一也是比较重量级的，据测试，一个空ContentProvider启动就耗时2ms，如果数量再增加，那么可能性能优化就得不偿失了。所以JetPack新成员App Startup就诞生了。具体App Startup的使用非常简单，这里就不多说了，给出郭霖的文章：<a href="https://mp.weixin.qq.com/s/rverE0OGRnncB5-K-_Wesg">https://mp.weixin.qq.com/s/rverE0OGRnncB5-K-_Wesg</a></li><li>再比如地图，推送等，非第一时间需要的可以在主线程做延时启动。当程序已经启动起来之后，在进行初始化。</li></ol></li><li><h6 id="Activity创建"><a href="#Activity创建" class="headerlink" title="Activity创建"></a>Activity创建</h6></li></ol><p>Activity里面的优化和Application差不多，但是Activity.onCreate方法的开销是最大的，对整个app启动的影响也最大，所以绝对不能再里面执行太耗时的操作。其次是对布局优化也可以缩短onCreate的时间，具体见渲染优化。</p><p>这里再介绍几个用于检测app启动性能的工具：</p><ul><li><p>最简单的就是as自己的日志工具</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708180528.jpg" alt="D"></p><p>搜索词是Displayed，右边选No Files，然后就能看到各个Activity的启动时间了。</p></li><li><p>在Terminal中输入adb shell am start  -W 包名&#x2F;包名.首屏Activity  这一行命令就能看到页面的启动时间</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ图片20220708181942.png" alt="T" style="zoom:200%;" /><p>控制台输出了以下信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Starting: Intent &#123; act=android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.action</span><span class="hljs-selector-class">.MAIN</span> cat=<span class="hljs-selector-attr">[android.intent.category.LAUNCHER]</span> cmp=com<span class="hljs-selector-class">.example</span>.universe/<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.MainActivity</span> &#125;<br>Status: ok<br>LaunchState: COLD<br>Activity: com<span class="hljs-selector-class">.example</span>.universe/<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.MainActivity</span><br>TotalTime: <span class="hljs-number">3447</span><br>WaitTime: <span class="hljs-number">3450</span><br>Complete<br></code></pre></td></tr></table></figure><p>简单说一下</p><ul><li><p>LaunchState：代表启动方式</p></li><li><p>TotalTime：代表启动时间，包含创建进程+Application 初始化+Activity 初始化到界面显示。</p></li><li><p>WaitTime： 一般比TotalTime 大点，包含系统影响的耗时</p></li></ul></li><li><p>借助优化检测工具</p><p><strong>TraceView</strong></p><p>TraceView是以图形的形式展示执行时间、调用栈等信息，信息比较全面，包含所有线程。<br>使用TraceView检测生成生成的结果会放在Andrid&#x2F;data&#x2F;packagename&#x2F;files路径下。因为Traceview收集的信息比较全面，所以会导致运行开销严重，整体APP的运行会变慢，因此我们无法区分是不是Traceview影响了我们的启动时间。AS已经为我们内置了TraceVeiw，直接用</p><p>具体使用是AS - &gt; 【ProFiler】-&gt; 右侧SESSIONS 旁边的+号 -&gt; 选择你的手机，在选择一个进程  就会出现这样的画面</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708184448.png" alt="F"></p><p>图中A是一些事件的响应，比如点击，屏幕翻转等等</p><p>B是CPU的一些使用情况，这里会说</p><p>C是内存的一些使用情况，等会讲内存优化的时候会说</p><p>D是电量的一些情况，讲耗电优化会说</p><p>E是时间轴</p><p>这里我们点击B区，就会出现下列界面</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708185117.png" alt="G"></p><p>同样，A是一些事件的响应，B是CPU的执行情况，C是线程列表和线程占用CPU的情况，D是时间轴，E是记录这些情况成文件进行更加细致的分析，这里就不说明了，可以百度其用法。</p><p>以此我们可以更加直观的看出CPU的使用情况，从而找出问题解决问题。</p><p><strong>SysTrace</strong></p><p>Systrace是结合Android内核数据，生成HTML报告，从报告中我们可以看到各个线程的执行时间以及方法耗时和CPU执行时间等。它比TraceView更轻量，但用法差不多，具体用法可参考：<a href="https://www.jianshu.com/p/f83d84dcd0b8">Android Systrace使用介绍 - 简书 (jianshu.com)</a></p></li></ul><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>在Android的虚拟机中，每fork一个进程，它的内存是给定的，因为移动设备的内存相对PC比较小，资源紧张，因此一个app在运行过程中一定要管理好自己的那部分内存，以提高稳定性。在内存使用中经常出现的问题也是内存抖动和内存泄漏了。</p><h3 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h3><p>内存抖动是由于短时间内有大量对象进出JVM的新生区导致的，内存忽高忽低，有短时间内上升和下落的趋势，分析图成锯齿状。</p><p>它伴随着频繁的GC（Garbage Collection垃圾回收），频繁GC会大量占用UI线程和CPU资源，会导致APP整体卡顿，甚至OOM。</p><h5 id="先说为什么频繁GC会导致APP整体卡顿？"><a href="#先说为什么频繁GC会导致APP整体卡顿？" class="headerlink" title="先说为什么频繁GC会导致APP整体卡顿？"></a>先说为什么频繁GC会导致APP整体卡顿？</h5><p>在JVM的GC机制中，垃圾回收有单线程收集和多线程收集，但不管是哪种回收方式，在回收的时候所有用户线程都会被暂停（STW），具体原理涉及JVM的知识了，就不再深入了。所以频繁地GC，用户线程就会被频繁地暂停，自然app就会卡顿。</p><h5 id="为什么频繁GC也有可能会OOM？"><a href="#为什么频繁GC也有可能会OOM？" class="headerlink" title="为什么频繁GC也有可能会OOM？"></a>为什么频繁GC也有可能会OOM？</h5><p>先看一张图</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/IMG_20220708_230442.jpg" alt="A"></p><p>这里简单说一下JVM的空间担保机制，简单理解就是Java堆划分为新生代 （Young Generation）和老年代（Old Generation）两个区域，新生代空间比较少，只有1&#x2F;3，而老年代有2&#x2F;3，新生代中不断有对象被创建然后回收，只有少部分仍然存在的对象会进入老年代。而当频繁GC时，会导致新生代中有大量对象被创建，然后新生代空间就会不够用，这时候老年代就会划分一部分空间用来给新生代创建大量的对象。这就是JVM的空间担保机制。但是当老年代被划出一部分空间后，假如这时候有一个比较大的对象，比如一张图片，从新生区转移到了老年区，但是这时候老年区被缩小了，剩下的空间不够了，这时候就触发了OOM。</p><h5 id="怎么监测内存抖动？"><a href="#怎么监测内存抖动？" class="headerlink" title="怎么监测内存抖动？"></a>怎么监测内存抖动？</h5><p>AS有自带的检测内存抖动的工具—–Memory Monitor</p><p>其实这个在启动优化工具里面也提到过。</p><p>打开方式：Profiler -&gt;SESSIONS右边的加号选择你的手机在选择你的app   就会出现这样的界面</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708184448.png" alt="F"></p><p>这次我们不点B，选择C区Memory，这时候就会出现如下界面</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220709010830.jpg" alt="B"></p><p>A依然是一些事件的反应，B是内存使用的图形化显示，C是鼠标放在图形上就会有各个语言占用内存情况，D是时间轴，但这是内存使用正常的情况，当出现频繁GC的情况时</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220709013129.png"></p><p>是这样滴，底部还会有一排垃圾桶表示频繁回收。那么如何定位呢？我们看到左侧有三个选项：</p><ul><li>Capture heap dump：捕获堆转储，什么是堆转储？就是java的内存快照，简单来说就是把这些内存记录写入一个文件，文件类型是hprof，然后进行更细致的分析。更多的时候是结合MAT（Memory Analyzer tool）来分析内存泄漏，这也是比较老的方法，大家可查阅了解一下，但是这种方法比较低效（搞不好as会卡死），现在检测内存泄漏有更方便的工具—LeakCanary</li><li>Record native allocations：记录native相关对象的内存分配</li><li>Record java&#x2F;kotlin allocations：记录java&#x2F;kotlin相关对象的内存分配</li></ul><p>这里一般发生内存抖动都是由于频繁创建java&#x2F;kotlin对象引起的，所以我们选择第三个并点击Record，等待一会就会出现这样的界面</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220709015258.png" alt="A"></p><p>上面一排排的垃圾桶就表示在频繁GC，下面的表格显示了各个对象内存分配情况，我们点击最多的char数组</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220709020245.jpg" alt="A"></p><p>跟踪可以发现是stringPlus相关操作引起的GC频繁，再看String</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220709020233.jpg" alt="A"></p><p>这里就追踪到了，原来是MainActivity里面的manyGCTest方法的问题。再看源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        findViewById&lt;Button&gt;(R.id.button).setOnClickListener &#123;<br>            Thread&#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) manyGCTest()<br>            &#125;.start()<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manyGCTest</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;&quot;</span><br>        repeat(<span class="hljs-number">10000</span>)&#123;<br>            str += it<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">100</span>)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>给一个按钮设置监听，按下开启线程，在一个死循环里面进行10000次字符串拼接操作，实际上每次str+&#x3D;it都会创建一个对象然后进行字符串拼接，但如果我们换成这样，情况会有所好转</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        findViewById&lt;Button&gt;(R.id.button).setOnClickListener &#123;<br>            Thread&#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) manyGCTest()<br>            &#125;.start()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manyGCTest</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">/*var str = &quot;&quot;</span><br><span class="hljs-comment">        repeat(10000)&#123;</span><br><span class="hljs-comment">            str += it</span><br><span class="hljs-comment">        &#125;*/</span><br>        <span class="hljs-keyword">val</span> sb = StringBuilder()<br>        repeat(<span class="hljs-number">10000</span>)&#123;<br>            sb.append(it)<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">100</span>)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>内存抖动减轻</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220709021347.png"></p><p>这是因为StringBuilder做字符串拼接只会创建一次对象，所以我们在大量字符串拼接中能使用StringBuilder尽量使用StringBuilder。其实这样的情况也是比较常见的，比如在onDraw里面涉及了很多用Color.parseColor()来解析颜色，但是parseColor里面也涉及了很多字符串的操作，如果一个自定义View比较复杂这种操作很多的话这也会影响app的性能，再或者存储Cookie等等。具体的一些字符串拼接方式的区别这里也不多说了，给出一篇博客：[七种java字符串拼接详解 - &#96;&#96;&#96;…简单点 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/yysbolg/p/13532971.html">https://www.cnblogs.com/yysbolg/p/13532971.html</a>)</p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>内存泄漏可以说是面试必问的，也是我们开发者所必须熟知的。那么什么是内存泄漏呢？就是程序中已经动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费。简单来说就是一个对象该被回收却没有被回收，造成了内存浪费。那我们怎么知道一个对象怎么才能被GC回收呢？看一张图</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/IMG_20220708_233143.jpg" alt="A"></p><p>在JVM中判断一个对象是否应该被回收一般根据可达性分析，如果一个对象的根可达，那它就不应该被回收，反之应该被回收。那么什么是根呢？就是GC roots，GC roots 一般有静态变量，线程栈变量，常量池，JNI（指针）等。举个例子，在我们还没学架构之前一直用的MVC，即所有的网络相关的操作都在Activity中进行，然后用Handler进行线程切换。但是在Handler作为非静态内部类的时候是有可能发生内存泄漏的，因为非静态内部类Handler会持有外部Activity的引用，而message会持有Handler的引用（具体见Handler源码），message会被messageQueue引用，messageQueue又被Looper引用，Looper又被Threadlocal引用，而Threadlocal属于Thread的变量即线程栈变量（GC roots即变量的根）。如果此时message是个延迟消息，而恰好在这延迟的时间段里面Activity被销毁了但是因为它还在被message引用造成它有根，不能被及时回收而一直占用内存。比教好的方案是把Handle写成静态内部类，因为静态内部类是不会持有外部的引用的，或者在onDestroy里面移除所有message。</p><p>这里说个题外话，java的内存泄漏和C&#x2F;C++有什么区别呢？</p><p>在java中，一个进程其实就是一个JVM的实例，进程中的操作都是靠JVM托管的。假如我开启了两个java进程A和B，A用来打游戏，B用来学高数。假如这时候我不想学习了，就是B发生了内存泄漏，B进程就挂掉了，但这并不影响A进程的进行，你挂你的，我运行我的。但在C&#x2F;C++中就不一样了，C&#x2F;C++中没有JVM，发生内存泄漏了影响的是整个操作系统，这个时候只有重启操作系统才会使被浪费的空间得到重用。这也就是为什么电脑用久了不重启一次就会变卡，而手机不会。</p><h5 id="怎么检测内存泄漏呢？"><a href="#怎么检测内存泄漏呢？" class="headerlink" title="怎么检测内存泄漏呢？"></a>怎么检测内存泄漏呢？</h5><p>上面提及了一种方案，就是使用AS自带的Android Profiler工具再结合MAT分析，但这个做法比较低效，难度也比较大，而且如果app比较庞大容易卡死AS，现今比较常用的工具是LeakCanary，它的使用比较高效，方法也比较简单。其实LeakCanary也是基于MAT进行检测Android应用程序的开源工具。</p><p>具体使用：在你的App中加入如下依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">debugImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-android:x.x.x&#x27;</span><br></code></pre></td></tr></table></figure><p>然后在启动App的时候就额外出现一个金丝雀的图标</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/qq_pic_merged_1657355581046.jpg"></p><p>这是时候内存泄漏检测就开始了，在你操作App的时候，如果这时候发生了内存泄漏状态栏就会有通知，比如我的手机</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220709_163546.jpg" style="zoom:25%;" /><p>点击通知它就会开始下载文件然后开始分析，分析完之后又会给你一个通知，此时再点进去就能看到LeakCanary为我们生成的发生内存泄漏对象的引用树</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220709_163630.jpg" alt="A" style="zoom:25%;" /><p>可以很明显看到是SecondActivity被MyThread引用而发生内存泄漏，此时再看源码的确如此</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>        MyThread().start()<br>    &#125;<br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>:<span class="hljs-type">Thread</span>()&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>            sleep(<span class="hljs-number">6</span>*<span class="hljs-number">6</span>*<span class="hljs-number">1000</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我在进入SecondActivity的时候开启了一个线程并让这个线程睡眠36秒，这时候我再推出当前Activity它不内存泄漏才怪呢。</p><h3 id="LeakCanary源码分析"><a href="#LeakCanary源码分析" class="headerlink" title="LeakCanary源码分析"></a>LeakCanary源码分析</h3><p>上面简单介绍了一下使用LeakCanary排查内存泄漏的使用，那么它为什么这么”智能”呢？为啥我们就加了一行代码它就可以监测内存泄漏了捏？这里就涉及LeakCanary的源码了。</p><p>在理解LeakCanary源码之前我们先来了解一下java虚拟机里的强引用，软引用，弱引用和虚引用。</p><ul><li>强引用（Strong Reference）：强引用在代码中普遍的存在，类似于“Object obj &#x3D; new Object()”，只要某个对象有强引用与之关联，JVM则无法回收该对象，即使在内存不足的情况下，JVM宁愿抛出OOM错误，也不会回收这种对象。</li><li>软引用（Soft Reference）：软引用常常用来描述一些有用但是非必需的对象。对于软引用关联的对象，会在JVM内存不足时既OOM之前将这些对象列入回收范围，进行二次回收。如果这时回收还是没有足够的内存才会造成内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。软引用一般用于网页的缓存图片的缓存等等比较耗时的操作，但是这些操作目前一般使用LruChche来实现，因此目前代码中很少见到SoftReference。</li><li>弱引用（Weak Reference）：被弱引用关联的对象只能生产到下一次垃圾收集发生之前。当垃圾收集器工作室，无论内存是否足够，都会回收弱引用关联的对象。可以使用WeakReference类来实现弱引用。</li><li>虚引用（Phantom Reference）：虚引用也称之为幽灵引用，或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。也无法通过虚引用来取得一个对象的实例，为一个对象设置为虚引用的唯一目的是希望这个对象被回收器回收时能收到一个系统通知，在JDK1.2之后，提供了Phantom Reference类来实现虚引用。</li></ul><p>而LeakCanary核心原理就是利用弱引用和引用队列ReferenceQueue来检测Activity&#x2F;Fragment被销毁后是否被回收。如果弱引用的引用对象被垃圾回收器回收，虚拟机就会把这个弱引用加入到与之关联的引用队列中，我们就可以此特性来检查一个对象是否被垃圾回收器回收成功。我们将上述用代码简单实现就是下面这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> obj: Any? = Object()<br>    <span class="hljs-keyword">val</span> referenceQueue = ReferenceQueue&lt;Any?&gt;()<br>    <span class="hljs-keyword">val</span> weakReference = WeakReference&lt;Any?&gt;(obj, referenceQueue)<span class="hljs-comment">//将对象obj与软引用关联，再将软引用与引用队列关联</span><br>    <br>    <span class="hljs-keyword">var</span> ref = referenceQueue.poll()<span class="hljs-comment">//从引用队列取出软引用，此时obj未被回收，取出的是null</span><br>    println(<span class="hljs-string">&quot;gcBefore:<span class="hljs-subst">$&#123;ref&#125;</span>&quot;</span>)<br>    <br>    obj = <span class="hljs-literal">null</span><span class="hljs-comment">//将obj与Object()的引用断开，此时obj将被GC回收</span><br>    <br>    System.gc()<br>    Thread.sleep(<span class="hljs-number">2000</span>)<br>    <br>    ref = referenceQueue.poll()<span class="hljs-comment">//obj被回收，软引用入列，取出不为null</span><br>    println(<span class="hljs-string">&quot;gcAfter:<span class="hljs-subst">$&#123;ref&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcBefore:null<br>gcAfter:java.lang.ref.WeakReference@<span class="hljs-number">60</span>f82f98<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>恰好印证。那么我们知道了核心原理，是否可以实现一个简单版的LeakCanary捏？说干就干！</p><p>首先，我们需要封装一下我们的弱引用，因为往往我们观测的是多个对象，那么就有多个弱引用，所以我们需要给每个弱引用设置一个Key方便查找。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyWeakCanary</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">WeakReference</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> key: String<br><br>    <span class="hljs-keyword">constructor</span>(referent: T, key: String) : <span class="hljs-keyword">super</span>(referent) &#123;<br>        <span class="hljs-keyword">this</span>.key = key<br>    &#125;<br><br>    <span class="hljs-keyword">constructor</span>(referent: T, queue: ReferenceQueue&lt;<span class="hljs-keyword">in</span> T?&gt;, key: String) : <span class="hljs-keyword">super</span>(referent, queue) &#123;<br>        <span class="hljs-keyword">this</span>.key = key<br>    &#125;<br><br><span class="hljs-comment">//重写toString，方便观察值</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;KeyWeakReference(key=<span class="hljs-variable">$key</span>)&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>弱引用简单封装了一下，那么还差个观察者，你要监测肯定需要一个观察者嘛。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br><br>    <span class="hljs-comment">//监测列表</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> watchedReferences = mutableMapOf&lt;String, KeyWeakReference&lt;Any?&gt;&gt;()<br><br>    <span class="hljs-comment">//保留列表</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> retainedReferences = mutableMapOf&lt;String, KeyWeakReference&lt;Any?&gt;&gt;()<br><br>    <span class="hljs-comment">//引用队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> queue = ReferenceQueue&lt;Any?&gt;()<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">watch</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>?)</span></span> &#123;<br>        <span class="hljs-comment">//生成UUID Key，便于从列表取出相应的引用</span><br>        <span class="hljs-keyword">val</span> key = UUID.randomUUID().toString()<br><br>        <span class="hljs-keyword">val</span> reference = KeyWeakReference(obj, queue, key)<span class="hljs-comment">//弱引用引用对象，引用对象与弱引用关联</span><br><br>        <span class="hljs-comment">//登记</span><br>        watchedReferences[key] = reference<br><br>        <span class="hljs-comment">//开启子线程监测对象是否泄漏</span><br>        <span class="hljs-keyword">val</span> executor = Executors.newSingleThreadExecutor()<br>        executor.execute &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>)<br>            moveToRetain(key)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//将符合泄漏的对象转移到留存区</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveToRetain</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> &#123;<br><br>        <span class="hljs-keyword">var</span> ref: KeyWeakReference&lt;Any?&gt;? = <span class="hljs-literal">null</span><br><br>        <span class="hljs-keyword">do</span> &#123;<br>            queue.poll()?.also &#123; ref = it <span class="hljs-keyword">as</span> KeyWeakReference&lt;Any?&gt; &#125;<br>            <span class="hljs-comment">//回收成功，没有发生内存泄漏的情况</span><br>            ref?.key.let &#123;<br>                watchedReferences.remove(it)<br>                retainedReferences.remove(it)<br>            &#125;<br>            ref = <span class="hljs-literal">null</span><br>        &#125; <span class="hljs-keyword">while</span> (ref != <span class="hljs-literal">null</span>)<br>        <br>        <span class="hljs-comment">//如果没有回收成功，那这个对象那这个对象肯定还在观察区，将其转移到留存区</span><br>        watchedReferences.remove(key)?.also &#123;<br>            retainedReferences[key] = it<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//供外部取出内存泄漏对象的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getReferences</span><span class="hljs-params">()</span></span>:MutableMap&lt;String,KeyWeakReference&lt;Any?&gt;&gt;&#123;<br>        <span class="hljs-keyword">return</span> retainedReferences<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，我们创建了观察列表和留存列表，这就好比现在的疫情，从外省回来会被隔离（观察列表），如果观察你有新冠就将你运往隔离医院治疗（留存列表）。然后就是观察方法，传入观察对象，之后用java自带的UUID工具生成唯一的UUID给弱引用方便根据key查询弱引用，之后是弱引用引用对象，引用队列与弱引用关联，再把该弱引用记录进观察区，之后用线程池开启子线程进行内存监测。在内存检测方法里先从引用队列拿出一个引用对象，若为空，则表明它没有被回收，观察区也就不会将它移除，之后下面remove它的时候就不为null，它就会被转移进留存区。之后外界通过这个留存区取出内存泄漏的对象进行分析通知一系列操作。</p><p>然后在主线程测试一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> obj:Any? = Object()<br>    <span class="hljs-keyword">val</span> watcher = Watcher()<br>    watcher.watch(obj)<br><br>    obj = <span class="hljs-literal">null</span><span class="hljs-comment">//改变obj为null的状态来模拟内存泄漏与否</span><br>    System.gc()<br><br>    Thread.sleep(<span class="hljs-number">2000</span>)<br><br>    watcher.getReferences().forEach &#123; (key, reference) -&gt;<br>        println(<span class="hljs-string">&quot;key:<span class="hljs-variable">$key</span>,<span class="hljs-variable">$reference</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将obj置为null此时调用GC obj将被回收，无输出。再将这行注释，模拟obj被引用的情况，此时GC无法将其回收，留存区有值，打印：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">key:ca1485f4-<span class="hljs-number">929</span>a-<span class="hljs-number">45</span>f2-<span class="hljs-number">8977</span>-<span class="hljs-number">483</span>f05245f0d,KeyWeakReference(key=ca1485f4-<span class="hljs-number">929</span>a-<span class="hljs-number">45</span>f2-<span class="hljs-number">8977</span>-<span class="hljs-number">483</span>f05245f0d)<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>证明我们这个简易版的（可以说很丑陋）内存泄漏检测工具是成功的。但实际上，LeakCanary的做法比我们这个更加细节，我们这个只能检测单个对象，而LeakCanary对Activity、Fragment、Service、RootView、Viewmodel都进行了生命周期监听，并且对泄漏对象的通报和分析都是在内部进行的。</p><p>我们现在来看看它的源码，在看他的源码之前我们先问几个问题</p><ol><li>在LeakCanary1.0版本之前是需要在Application里面初始化的，2.0版本之后直接添加依赖就可以用了，那之后的版本它在哪初始化的捏？</li><li>LeakCanary是怎么对Activity、fragment（view和fragment本身）、Service、RootView、Viewmodel进行生命周期的监听的捏？</li><li>检测到泄漏之后是怎么处理的呢？</li></ol><p>相信带着这几个问题去看他的源码会更好理解。</p><p>首先看LeakCanary是在哪里初始化的？其实，在1.0版本之前，LeakCanary都是在自定义的Application里面初始化的，在2.0之后只需添加一行依赖即可。之前也提到过ContentProvider得onCreate()是在Application.onCreate前面执行的，不难想到LeakCanary就是这么许哦的。</p><h5 id="为什么ContentProvider的onCreate方法是在Application前面执行的呢？"><a href="#为什么ContentProvider的onCreate方法是在Application前面执行的呢？" class="headerlink" title="为什么ContentProvider的onCreate方法是在Application前面执行的呢？"></a>为什么ContentProvider的onCreate方法是在Application前面执行的呢？</h5><p>这就要看看ActivityThread的源码了，要知道他们两个的onCreate先后顺序肯定要先理清Application的创建流程，因为Application是伴随整个app的生命周期的。看到ActivityThread的main函数，我们看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ...<br>        Looper.prepareMainLooper();<br>...<br>        <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>        thread.attach(<span class="hljs-literal">false</span>, startSeq);<br>    ...<br>        Looper.loop();<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>Application和整个app的生命周期那肯定也伴随着主线程的启动与消亡，那肯定跟thread.attach有关，跟进看一看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(<span class="hljs-type">boolean</span> system, <span class="hljs-type">long</span> startSeq)</span> &#123;<br>sCurrentActivityThread = <span class="hljs-built_in">this</span>;<br>mSystemThread = system;<br><span class="hljs-keyword">if</span> (!system) &#123;<br>    android.ddm.DdmHandleAppName.setAppName(<span class="hljs-string">&quot;&lt;pre-initialized&gt;&quot;</span>,<br>                                            UserHandle.myUserId());<br>    RuntimeInit.setApplicationObject(mAppThread.asBinder());<br>    <span class="hljs-comment">// mgr为ActivityManagerService实例</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">mgr</span> <span class="hljs-operator">=</span> ActivityManager.getService();<br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// mAppThread为ApplicationThread实例,ApplicationThread是ActivityThread与AMS交互的桥梁</span><br>        mgr.attachApplication(mAppThread, startSeq);<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>        <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();<br>    &#125;<br>    ...<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里获取AMS之后调用了attachApplication(mAppThread, startSeq)，跟进看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachApplication</span><span class="hljs-params">(IApplicationThread thread, <span class="hljs-type">long</span> startSeq)</span> &#123;<br>    <span class="hljs-keyword">if</span> (thread == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(<span class="hljs-string">&quot;Invalid application interface&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">callingPid</span> <span class="hljs-operator">=</span> Binder.getCallingPid();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">callingUid</span> <span class="hljs-operator">=</span> Binder.getCallingUid();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">origId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>        attachApplicationLocked(thread, callingPid, callingUid, startSeq);<span class="hljs-comment">//这里又调用了AMS的内部方法，跟踪下去</span><br>        Binder.restoreCallingIdentity(origId);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">attachApplicationLocked</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IApplicationThread thread, <span class="hljs-type">int</span> pid, <span class="hljs-type">int</span> callingUid, <span class="hljs-type">long</span> startSeq)</span> &#123;<br>...<br><span class="hljs-keyword">if</span> (app.isolatedEntryPoint != <span class="hljs-literal">null</span>) &#123;<br>   <span class="hljs-comment">//判断是否是isolato进程，这个可通过设置service的android:isolatedProcess开启，设置该服务是否</span><br>       <span class="hljs-comment">//作为一个单独的进程运行，如果设置为true，此服务将在与系统其余部分隔离的特殊进程下运行，并且没有自己的权限，与它唯一//的通信是通过服务API（绑定和启动),这个我们一般不会去这么做，直接略过</span><br>   thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr2 != <span class="hljs-literal">null</span>) &#123;<br>   thread.bindApplication(processName, appInfo, providerList,<span class="hljs-comment">//跟踪到者发现调用了bindApplication</span><br>           instr2.mClass,<br>           profilerInfo, instr2.mArguments,<br>           instr2.mWatcher,<br>           instr2.mUiAutomationConnection, testMode,<br>           mBinderTransactionTrackingEnabled, enableTrackAllocation,<br>           isRestrictedBackupMode || !normalMode, app.isPersistent(),<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),<br>           app.compat, getCommonServicesLocked(app.isolated),<br>           mCoreSettingsObserver.getCoreSettingsLocked(),<br>           buildSerial, autofillOptions, contentCaptureOptions,<br>           app.mDisabledCompatChanges);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>   thread.bindApplication(processName, appInfo, providerList, <span class="hljs-literal">null</span>, profilerInfo,<span class="hljs-comment">//同样是这个方法的重载</span><br>           <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, testMode,<br>           mBinderTransactionTrackingEnabled, enableTrackAllocation,<br>           isRestrictedBackupMode || !normalMode, app.isPersistent(),<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),<br>           app.compat, getCommonServicesLocked(app.isolated),<br>           mCoreSettingsObserver.getCoreSettingsLocked(),<br>           buildSerial, autofillOptions, contentCaptureOptions,<br>           app.mDisabledCompatChanges);<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们继续点进thread.bindApplication看看它做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindApplication</span><span class="hljs-params">(String processName, ApplicationInfo appInfo,</span><br><span class="hljs-params">                ProviderInfoList providerList, ComponentName instrumentationName,</span><br><span class="hljs-params">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="hljs-params">                IInstrumentationWatcher instrumentationWatcher,</span><br><span class="hljs-params">                IUiAutomationConnection instrumentationUiConnection, <span class="hljs-type">int</span> debugMode,</span><br><span class="hljs-params">                <span class="hljs-type">boolean</span> enableBinderTracking, <span class="hljs-type">boolean</span> trackAllocation,</span><br><span class="hljs-params">                <span class="hljs-type">boolean</span> isRestrictedBackupMode, <span class="hljs-type">boolean</span> persistent, Configuration config,</span><br><span class="hljs-params">                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span><br><span class="hljs-params">                String buildSerial, AutofillOptions autofillOptions,</span><br><span class="hljs-params">                ContentCaptureOptions contentCaptureOptions, <span class="hljs-type">long</span>[] disabledCompatChanges,</span><br><span class="hljs-params">                SharedMemory serializedSystemFontMap)</span> &#123;<br>...<br>           <br>            sendMessage(H.BIND_APPLICATION, data);<span class="hljs-comment">//看这里</span><br>        &#125;<br></code></pre></td></tr></table></figure><p>找来找去发现没有关于application的函数了，但是我们可以看到最后一行调用了sendMessage函数，并传了H.BIND_APPLICATION这个参数，那么我们点进去看看它是否跟bindApplication有关捏？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-type">int</span> what, Object obj)</span> &#123;<br>        sendMessage(what, obj, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>继续跟进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-type">int</span> what, Object obj, <span class="hljs-type">int</span> arg1, <span class="hljs-type">int</span> arg2, <span class="hljs-type">boolean</span> async)</span> &#123;<br>        <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) &#123;<br>            Slog.v(TAG,<br>                    <span class="hljs-string">&quot;SCHEDULE &quot;</span> + what + <span class="hljs-string">&quot; &quot;</span> + mH.codeToString(what) + <span class="hljs-string">&quot;: &quot;</span> + arg1 + <span class="hljs-string">&quot; / &quot;</span> + obj);<br>        &#125;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain();<br>        msg.what = what;<br>        msg.obj = obj;<br>        msg.arg1 = arg1;<br>        msg.arg2 = arg2;<br>        <span class="hljs-keyword">if</span> (async) &#123;<br>            msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>        &#125;<br>        mH.sendMessage(msg);<span class="hljs-comment">//发现这里发送了一个消息，传入的message携带的信息就是上面传入的H.BIND_APPLICATION</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>我们发现这里调用了mH的sendMessage方法，mH会不会就是Handler?跟进mH看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">H</span> <span class="hljs-variable">mH</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">H</span>();<br></code></pre></td></tr></table></figure><p>是H的对象，那H是否继承了Handler方法呢？点进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    ...<br>     <span class="hljs-comment">//通过Handler进入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br><span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));<br>            <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                <span class="hljs-keyword">case</span> BIND_APPLICATION:<span class="hljs-comment">//根据我们传入的值进入这个分支</span><br>                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;bindApplication&quot;</span>);<br>                    <span class="hljs-type">AppBindData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (AppBindData)msg.obj;<br>                    handleBindApplication(data);<span class="hljs-comment">//在这里处理了Application的绑定</span><br>                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> EXIT_APPLICATION:<br>                    <span class="hljs-keyword">if</span> (mInitialApplication != <span class="hljs-literal">null</span>) &#123;<br>                        mInitialApplication.onTerminate();<br>                    &#125;<br>                    Looper.myLooper().quit();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> RECEIVER:<br>                ...<br>                &#125;<br>          ...<br>         &#125;<br>    ...<br>  &#125;<br></code></pre></td></tr></table></figure><p>发现果然是这样。并且实现了handle Message方法，那上面我们sendMessage最终通过Handler肯定执行handle Message方法，并且根据我们传入的H.BIND_APPLICATION进入了第一个分支，继续跟进handleBindApplication(data);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleBindApplication</span><span class="hljs-params">(AppBindData data)</span> &#123;<br>        ...<br>          <span class="hljs-comment">//创建appContext</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> ContextImpl.createAppContext(<span class="hljs-built_in">this</span>, data.info);<span class="hljs-comment">//6660</span><br>    ...<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//在这创建了application</span><br>            app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-literal">null</span>);<span class="hljs-comment">//6723</span><br><br>            ...<br>            <span class="hljs-keyword">if</span> (!data.restrictedBackupMode) &#123;<br>                <span class="hljs-keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;<span class="hljs-comment">//6747</span><br>                    installContentProviders(app, data.providers);<span class="hljs-comment">//可以看到这里应该就是启动ContentProvider的地方</span><br>                &#125;<br>            &#125;<br><br>           ...<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//看函数名不难发现这儿就是回调Applicatio.onCreate的地方  6762</span><br>                mInstrumentation.callApplicationOnCreate(app);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                      <span class="hljs-string">&quot;Unable to create application &quot;</span> + app.getClass().getName()<br>                      + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>                &#125;<br>            &#125;<br>...<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到，先创建appContext和application，具体创建过程这里就不细细分析了，这里我们只是简单看看ContentProvier和Application的onCreate执行顺序。然后是installContentProviders，那这里肯定就和ContentProvider有关了，等会再分析，先看下面的mInstrumentation.callApplicationOnCreate(app)，我们跟进发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callApplicationOnCreate</span><span class="hljs-params">(Application app)</span> &#123;<br>        app.onCreate();<br>    &#125;<br></code></pre></td></tr></table></figure><p>其实就是调用了application的onCreate方法，那我们再跟进前面的installContentProviders看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installContentProviders</span><span class="hljs-params">(</span><br><span class="hljs-params">            Context context, List&lt;ProviderInfo&gt; providers)</span> &#123;<br>        <span class="hljs-keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (ProviderInfo cpi : providers) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_PROVIDER) &#123;<br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">128</span>);<br>                buf.append(<span class="hljs-string">&quot;Pub &quot;</span>);<br>                buf.append(cpi.authority);<br>                buf.append(<span class="hljs-string">&quot;: &quot;</span>);<br>                buf.append(cpi.name);<br>                Log.i(TAG, buf.toString());<br>            &#125;<br>            <span class="hljs-type">ContentProviderHolder</span> <span class="hljs-variable">cph</span> <span class="hljs-operator">=</span> installProvider(context, <span class="hljs-literal">null</span>, cpi,<span class="hljs-comment">//在这里进行了ContentProvider的一些创建</span><br>                    <span class="hljs-literal">false</span> <span class="hljs-comment">/*noisy*/</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*noReleaseNeeded*/</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*stable*/</span>);<br>            <span class="hljs-keyword">if</span> (cph != <span class="hljs-literal">null</span>) &#123;<br>                cph.noReleaseNeeded = <span class="hljs-literal">true</span>;<br>                results.add(cph);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ActivityManager.getService().publishContentProviders(<br>                getApplicationThread(), results);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>            <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>继续跟进installProvider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ContentProviderHolder <span class="hljs-title function_">installProvider</span><span class="hljs-params">(Context context,</span><br><span class="hljs-params">            ContentProviderHolder holder, ProviderInfo info,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> noisy, <span class="hljs-type">boolean</span> noReleaseNeeded, <span class="hljs-type">boolean</span> stable)</span> &#123;<br>        <span class="hljs-type">ContentProvider</span> <span class="hljs-variable">localProvider</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        IContentProvider provider;<br>        <span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span> || holder.provider == <span class="hljs-literal">null</span>) &#123;<br>            ...<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">final</span> java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> c.getClassLoader();<br>                <span class="hljs-type">LoadedApk</span> <span class="hljs-variable">packageInfo</span> <span class="hljs-operator">=</span> peekPackageInfo(ai.packageName, <span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (packageInfo == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// System startup case.</span><br>                    packageInfo = getSystemContext().mPackageInfo;<br>                &#125;<br>                localProvider = packageInfo.getAppFactory()<br>                        .instantiateProvider(cl, info.name);<br>                provider = localProvider.getIContentProvider();<br>                <span class="hljs-keyword">if</span> (provider == <span class="hljs-literal">null</span>) &#123;<br>                    Slog.e(TAG, <span class="hljs-string">&quot;Failed to instantiate class &quot;</span> +<br>                          info.name + <span class="hljs-string">&quot; from sourceDir &quot;</span> +<br>                          info.applicationInfo.sourceDir);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (DEBUG_PROVIDER) Slog.v(<br>                    TAG, <span class="hljs-string">&quot;Instantiating local provider &quot;</span> + info.name);<br>                <span class="hljs-comment">// XXX Need to create the correct context for this provider.</span><br>                localProvider.attachInfo(c, info);<br>            &#125; <span class="hljs-keyword">catch</span> (java.lang.Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(<span class="hljs-literal">null</span>, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                            <span class="hljs-string">&quot;Unable to get provider &quot;</span> + info.name<br>                            + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            provider = holder.provider;<br>            <span class="hljs-keyword">if</span> (DEBUG_PROVIDER) Slog.v(TAG, <span class="hljs-string">&quot;Installing external provider &quot;</span> + info.authority + <span class="hljs-string">&quot;: &quot;</span><br>                    + info.name);<br>        &#125;<br>...<br>        <span class="hljs-keyword">return</span> retHolder;<br>    &#125;<br></code></pre></td></tr></table></figure><p>看到这句英文注释Need to create the correct context for this provider.需要为此提供者创建正确的上下文，那肯定就是他了，跟进localProvider.attachInfo(c, info)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachInfo</span><span class="hljs-params">(Context context, ProviderInfo info, <span class="hljs-type">boolean</span> testing)</span> &#123;<br>        mNoPerms = testing;<br>        mCallingAttributionSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Only allow it to be set once, so after the content service gives</span><br><span class="hljs-comment">         * this to us clients can&#x27;t change it.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (mContext == <span class="hljs-literal">null</span>) &#123;<br>            mContext = context;<br>            <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span> &amp;&amp; mTransport != <span class="hljs-literal">null</span>) &#123;<br>                mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(<br>                        Context.APP_OPS_SERVICE);<br>            &#125;<br>            mMyUid = Process.myUid();<br>            <span class="hljs-keyword">if</span> (info != <span class="hljs-literal">null</span>) &#123;<br>                setReadPermission(info.readPermission);<br>                setWritePermission(info.writePermission);<br>                setPathPermissions(info.pathPermissions);<br>                mExported = info.exported;<br>                mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != <span class="hljs-number">0</span>;<br>                setAuthorities(info.authority);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (Build.IS_DEBUGGABLE) &#123;<br>                setTransportLoggingEnabled(Log.isLoggable(getClass().getSimpleName(),<br>                        Log.VERBOSE));<br>            &#125;<br>            ContentProvider.<span class="hljs-built_in">this</span>.onCreate();<span class="hljs-comment">//在这里回调了contentProvider的onCreate</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>最终我们在这发现回调了onCreate。这里我们只是根据函数名+源码注释+猜测去验证了他们两个的执行顺序，更多细枝末节就没看（其实是看不懂），如果大家想真正搞明白ContentProvider和Application完整的创建流程，大家可以去研究一下Android的源码。</p><p>知道了这个之后我们就能理解LeakCanary的做法了，翻其源码也确实是这样。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.squareup.leakcanary.objectwatcher&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;leakcanary.internal.MainProcessAppWatcherInstaller&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.leakcanary-installer&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;@bool/leak_canary_watcher_auto_install&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那可能有人会疑问，为啥它那定义的清单文件我这也能用捏？其实这是Gradle的功劳，一个app是只能有一个清单文件的，在构建应用的时候，Gradle会合并所有的清单文件，所有文件优先级如下</p><ol><li>Product flavors 和构建类型所指定的清单文件。</li><li>应用程序的主清单文件。</li><li>类库的清单文件。</li></ol><p>具体的合并逻辑就涉及Gradle的东西了，这里就不说了。那好，那我们的第一个问题就解决了。</p><h5 id="LeakCanary是如何监听的"><a href="#LeakCanary是如何监听的" class="headerlink" title="LeakCanary是如何监听的"></a>LeakCanary是如何监听的</h5><p>现在我们看MainProcessAppWatcherInstaller</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainProcessAppWatcherInstaller</span> : <span class="hljs-type">ContentProvider</span>() &#123;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> application = context!!.applicationContext <span class="hljs-keyword">as</span> Application<br>    AppWatcher.manualInstall(application)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化了AppWatcher</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@JvmOverloads</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manualInstall</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  application: <span class="hljs-type">Application</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  retainedDelayMillis: <span class="hljs-type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>)</span></span>,<span class="hljs-comment">//对检测对象延迟5秒检测</span><br>  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)<span class="hljs-comment">//默认的一些观察器</span><br>) &#123;<br>  checkMainThread()<br>  <span class="hljs-keyword">if</span> (isInstalled) &#123;<br>    <span class="hljs-keyword">throw</span> IllegalStateException(<br>      <span class="hljs-string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause<br>    )<br>  &#125;<br>  check(retainedDelayMillis &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-string">&quot;retainedDelayMillis <span class="hljs-variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span><br>  &#125;<br>  <span class="hljs-keyword">this</span>.retainedDelayMillis = retainedDelayMillis<br>  <span class="hljs-keyword">if</span> (application.isDebuggableBuild) &#123;<br>    LogcatSharkLog.install()<span class="hljs-comment">//日志的初始化</span><br>  &#125;<br>  <span class="hljs-comment">//核心组件，用于检测泄漏和对堆转储(head dump)的分析</span><br>  LeakCanaryDelegate.loadLeakCanary(application)<br><br>  <span class="hljs-comment">//对每一个检测器进行初始化</span><br>  watchersToInstall.forEach &#123;<br>    it.install()<br>  &#125;<br>  <span class="hljs-comment">// Only install after we&#x27;re fully done with init.</span><br>  installCause = RuntimeException(<span class="hljs-string">&quot;manualInstall() first called here&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先不看核心组件，它比较复杂，我们先看看默认的检测器是如何对Activity、Fragment、Viewmodel等的监听的，先看appDefaultWatchers(application)这个生成默认检测器的方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">appDefaultWatchers</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  application: <span class="hljs-type">Application</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  reachabilityWatcher: <span class="hljs-type">ReachabilityWatcher</span> = objectWatcher</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: List&lt;InstallableWatcher&gt; &#123;<br>  <span class="hljs-keyword">return</span> listOf(<br>    ActivityWatcher(application, reachabilityWatcher),<span class="hljs-comment">//对Activity的检测器</span><br>    FragmentAndViewModelWatcher(application, reachabilityWatcher),<span class="hljs-comment">//对Fragment和Viewmodel的检测器</span><br>    RootViewWatcher(reachabilityWatcher),<span class="hljs-comment">//对RootView的检测器</span><br>    ServiceWatcher(reachabilityWatcher)<span class="hljs-comment">//对Service的检测器</span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>创建各个检测器，传入objectWatcher和application，这四个监听器我们一个一个来看</p><h6 id="ActivityWatcher"><a href="#ActivityWatcher" class="headerlink" title="ActivityWatcher"></a><strong>ActivityWatcher</strong></h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityWatcher</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> application: Application,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : InstallableWatcher &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycleCallbacks =<br>    <span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityDestroyed</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>        reachabilityWatcher.expectWeaklyReachable(<br>          activity, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span><br>        )<br>      &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span> &#123;<br>    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)<span class="hljs-comment">//注册Activity的生命周期监听</span><br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">uninstall</span><span class="hljs-params">()</span></span> &#123;<br>    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，通过Activity生命周期对的Application.ActivityLifecycleCallbacks回调来达到监听Activity的结束。其实就是在Activity快onDestroy的时候调用了Application.ActivityLifecycleCallbacks的onActivityDestroyed。然后在onActivityDestroyed里面调用了reachabilityWatcher的expectWeaklyReachable，reachabilityWatcher就是刚刚创建的时候传进来的，我们返回去看看reachabilityWatcher对expectWeaklyReachable的实现。跟踪发现，传进来的是objectWatcher，点击跟踪</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The [ObjectWatcher] used by AppWatcher to detect retained objects.</span><br><span class="hljs-comment"> * Only set when [isInstalled] is true.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">val</span> objectWatcher = ObjectWatcher(<br>  clock = &#123; SystemClock.uptimeMillis() &#125;,<br>  checkRetainedExecutor = &#123;<br>    check(isInstalled) &#123;<br>      <span class="hljs-string">&quot;AppWatcher not installed&quot;</span><br>    &#125;<br>    mainHandler.postDelayed(it, retainedDelayMillis)<br>  &#125;,<br>  isEnabled = &#123; <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure><p>我们这里看到传入时间、一个Executor任务执行器，该任务执行器将传入的任务交给主线程的Handler延时处理，延时retainedDelayMillis就是刚刚初始化AppWatcher默认设置的5秒，看看ObjectWatcher对expectWeaklyReachable的实现，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">expectWeaklyReachable</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  watchedObject: <span class="hljs-type">Any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  description: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (!isEnabled()) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  removeWeaklyReachableObjects()<span class="hljs-comment">//先清空观察区里已经被回收的对象</span><br>  <span class="hljs-keyword">val</span> key = UUID.randomUUID()<br>    .toString()<br>  <span class="hljs-keyword">val</span> watchUptimeMillis = clock.uptimeMillis()<br>  <span class="hljs-keyword">val</span> reference =<br>    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)<br>  SharkLog.d &#123;<br>    <span class="hljs-string">&quot;Watching &quot;</span> +<br>      (<span class="hljs-keyword">if</span> (watchedObject <span class="hljs-keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;instance of <span class="hljs-subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +<br>      (<span class="hljs-keyword">if</span> (description.isNotEmpty()) <span class="hljs-string">&quot; (<span class="hljs-variable">$description</span>)&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>) +<br>      <span class="hljs-string">&quot; with key <span class="hljs-variable">$key</span>&quot;</span><br>  &#125;<br><br>  watchedObjects[key] = reference<br>  checkRetainedExecutor.execute &#123;<br>    moveToRetained(key)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实之前仿写的LeakCanary有点故意模仿LeakCanary的意思，这不LeakCanary里面也有观察区和留存区，只不过我们为了好获取泄漏对象而用了一个列表存储，这里没有列表存储，而是直接回调出去通知。每次观测之前先清除观察区已经被回收的对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeWeaklyReachableObjects</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span><br>  <span class="hljs-comment">// reachable. This is before finalization or garbage collection has actually happened.</span><br>  <span class="hljs-keyword">var</span> ref: KeyedWeakReference?<br>  <span class="hljs-keyword">do</span> &#123;<br>    ref = queue.poll() <span class="hljs-keyword">as</span> KeyedWeakReference?<br>    <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//不为空说明已经被回收</span><br>      watchedObjects.remove(ref.key)<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (ref != <span class="hljs-literal">null</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就和我们刚仿写的差不多，生成一个唯一的UUID，将弱引用引用对象，再登记，只不过这里它记录了时间。最后执行moveToRetained(key)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveToRetained</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> &#123;<br>  removeWeaklyReachableObjects()<br>  <span class="hljs-keyword">val</span> retainedRef = watchedObjects[key]<br>  <span class="hljs-keyword">if</span> (retainedRef != <span class="hljs-literal">null</span>) &#123;<br>    retainedRef.retainedUptimeMillis = clock.uptimeMillis()<br>      <span class="hljs-comment">//责任链模式</span><br>    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候如果还有对象存在观察区，说明已经是可能内存泄漏的对象，然后记录此时的时间，再回调监听，onObjectRetainedListeners在哪设置的呢，在刚刚的核心组件里面，等会分析。</p><p>至此我们分析完LeakCanary是如何监听Activity生命周期和检测是否泄露的。接下来看Fragment和Viewmodel</p><h6 id="FragmentAndViewModelWatcher"><a href="#FragmentAndViewModelWatcher" class="headerlink" title="FragmentAndViewModelWatcher"></a><strong>FragmentAndViewModelWatcher</strong></h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentAndViewModelWatcher</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> application: Application,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : InstallableWatcher &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentDestroyWatchers: List&lt;(Activity) -&gt; <span class="hljs-built_in">Unit</span>&gt; = run &#123;<br>    <span class="hljs-keyword">val</span> fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; <span class="hljs-built_in">Unit</span>&gt;()<br><br>      <span class="hljs-comment">//版本的适配</span><br>    <span class="hljs-keyword">if</span> (SDK_INT &gt;= O) &#123;<br>      fragmentDestroyWatchers.add(<br>        AndroidOFragmentDestroyWatcher(reachabilityWatcher)<br>      )<br>    &#125;<br><br>    getWatcherIfAvailable(<br>      ANDROIDX_FRAGMENT_CLASS_NAME,<br>      ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<span class="hljs-comment">//对应androidx版本</span><br>      reachabilityWatcher<br>    )?.let &#123;<br>      fragmentDestroyWatchers.add(it)<br>    &#125;<br><br>    getWatcherIfAvailable(<br>      ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,<br>      ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<span class="hljs-comment">//对应之前的老版本</span><br>      reachabilityWatcher<br>    )?.let &#123;<br>      fragmentDestroyWatchers.add(it)<br>    &#125;<br>    fragmentDestroyWatchers<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycleCallbacks =<br>    <span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        activity: <span class="hljs-type">Activity</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        savedInstanceState: <span class="hljs-type">Bundle</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">      )</span></span> &#123;<br>          <span class="hljs-comment">//不同版本的fragmentDestroyWatcher进行监听注册</span><br>        <span class="hljs-keyword">for</span> (watcher <span class="hljs-keyword">in</span> fragmentDestroyWatchers) &#123;<br>          watcher(activity)<br>        &#125;<br>      &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span> &#123;<br>    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">uninstall</span><span class="hljs-params">()</span></span> &#123;<br>    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)<br>  &#125;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里给activity注册一个监听，然后遍历里面的fragmentwatcher调用incoke设置fragment的监听，其他版本的fragmentDestroyWatcher就不看了和ActivityWatcher差不多，我们看看AndroidXFragmentDestroyWatcher</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidXFragmentDestroyWatcher</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : (Activity) -&gt; <span class="hljs-built_in">Unit</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentLifecycleCallbacks = <span class="hljs-keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentCreated</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      fragment: <span class="hljs-type">Fragment</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      savedInstanceState: <span class="hljs-type">Bundle</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        <span class="hljs-comment">//监听viewmodel相关</span><br>      ViewModelClearedWatcher.install(fragment, reachabilityWatcher)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentViewDestroyed</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      fragment: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      <span class="hljs-keyword">val</span> view = fragment.view<br>      <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">//对view泄漏的回调</span><br>        reachabilityWatcher.expectWeaklyReachable(<br>          view, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback &quot;</span> +<br>          <span class="hljs-string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span><br>        )<br>      &#125;<br>    &#125;<br><br>      <span class="hljs-comment">//和activitywatcher一样，不多说</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentDestroyed</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      fragment: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      reachabilityWatcher.expectWeaklyReachable(<br>        fragment, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback&quot;</span><br>      )<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">is</span> FragmentActivity) &#123;<br>      <span class="hljs-keyword">val</span> supportFragmentManager = activity.supportFragmentManager<br>        <span class="hljs-comment">//通过fragmentmanager监听fragment生命周期</span><br>      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="hljs-literal">true</span>)<br>        <span class="hljs-comment">//初始化viewmodel</span><br>      ViewModelClearedWatcher.install(activity, reachabilityWatcher)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实跟activity的差不多，不过是通过activity设置fragment的监听，这里可能有个高阶函数大家没见过，也是invoke的一种用法吧，可以了解一下。好，我们现在来看看对viewmodel的监听过程：</p><h6 id="ViewModelClearedWatcher"><a href="#ViewModelClearedWatcher" class="headerlink" title="ViewModelClearedWatcher"></a><strong>ViewModelClearedWatcher</strong></h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModelClearedWatcher</span>(<br>  storeOwner: ViewModelStoreOwner,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : ViewModel() &#123;<br><br>  <span class="hljs-comment">// We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,</span><br>  <span class="hljs-comment">// however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0</span><br>  <span class="hljs-comment">// does not have ViewModelStore#keys. All versions currently have the mMap field.</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModelMap: Map&lt;String, ViewModel&gt;? = <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//通过反射获取viewmodelstore</span><br>    <span class="hljs-keyword">val</span> mMapField = ViewModelStore::<span class="hljs-keyword">class</span>.java.getDeclaredField(<span class="hljs-string">&quot;mMap&quot;</span>)<br>    mMapField.isAccessible = <span class="hljs-literal">true</span><br>    <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>    mMapField[storeOwner.viewModelStore] <span class="hljs-keyword">as</span> Map&lt;String, ViewModel&gt;<br>  &#125; <span class="hljs-keyword">catch</span> (ignored: Exception) &#123;<br>    <span class="hljs-literal">null</span><br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-comment">//当此viewmodel销毁时，意味着viewmodelstore里其他的viewmodel也将被销毁</span><br>    viewModelMap?.values?.forEach &#123; viewModel -&gt;<br>      reachabilityWatcher.expectWeaklyReachable(<br>        viewModel, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;viewModel::class.java.name&#125;</span> received ViewModel#onCleared() callback&quot;</span><br>      )<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      storeOwner: <span class="hljs-type">ViewModelStoreOwner</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      reachabilityWatcher: <span class="hljs-type">ReachabilityWatcher</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        <span class="hljs-comment">//这就很巧妙，通过将自己插入viewmodelstore来监控通一宿主的viewmodel</span><br>      <span class="hljs-keyword">val</span> provider = ViewModelProvider(storeOwner, <span class="hljs-keyword">object</span> : Factory &#123;<br>        <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : ViewModel?&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(modelClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T =<br>          ViewModelClearedWatcher(storeOwner, reachabilityWatcher) <span class="hljs-keyword">as</span> T<br>      &#125;)<br>      provider.<span class="hljs-keyword">get</span>(ViewModelClearedWatcher::<span class="hljs-keyword">class</span>.java)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现它居然是个viewmodel，而且它还把它自己插入了宿主的viewmodelstore。把自己当作间谍插入敌军来达到监听的目的。具体viewmodestore是如何管理同一宿主的多个viewmodel的这里就不解释了，大家可以看看viewmodel的源码（其实是我不会）。</p><p>好，再来看看rootView</p><h6 id="RootViewWatcher"><a href="#RootViewWatcher" class="headerlink" title="RootViewWatcher"></a><strong>RootViewWatcher</strong></h6><p>有人可能会问rootview也会发生内存泄露吗？会的，只是不常见，比如，此时我自定义了一个Toast弹窗，弹的是xml的布局，然后Toast被我声明成了静态方法，这时候如果我一弹窗，消失，之后LeakCanary就提醒你了，内存泄漏。自定义的toast代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> ToastUtil &#123;<br>    <span class="hljs-keyword">var</span> mToast: Toast? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> inflater = LayoutInflater.from(App.appContext)<br>        <span class="hljs-keyword">val</span> toastView: View = inflater.inflate(R.layout.toast, <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">if</span> (mToast == <span class="hljs-literal">null</span>) &#123;<br>            mToast = Toast(App.appContext)<br>        &#125;<br>        mToast!!.setGravity(Gravity.TOP, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        mToast!!.duration = Toast.LENGTH_SHORT<br>        mToast!!.view = toastView<br>        mToast!!.show()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的自定义Toast工具是内存泄漏的，为什么捏，因为object单例内部的变量是静态的，所以mToast是静态的，而它又引用了toastView，而toastView是rootView绘制的xml布局（原理见view的绘制），因此一系列下来导致弹完吐司之后，rootView绘制完了而还在被mToastView引用导致内存泄漏。事实上，你会发现，mToast.view已经被废弃，谷歌官方也不建议我们自定义toast，因为这样确实容易造成内存泄漏，更推荐我们自定义snackBar。</p><p>我们再看RootViewWatcher</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RootViewWatcher</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : InstallableWatcher &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> listener = OnRootViewAddedListener &#123; rootView -&gt;<br>    ...<br>    <span class="hljs-keyword">if</span> (trackDetached) &#123;<br>      rootView.addOnAttachStateChangeListener(<span class="hljs-keyword">object</span> : OnAttachStateChangeListener &#123;<br><br>        <span class="hljs-keyword">val</span> watchDetachedView = Runnable &#123;<br>          reachabilityWatcher.expectWeaklyReachable(<br>            rootView, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;rootView::class.java.name&#125;</span> received View#onDetachedFromWindow() callback&quot;</span><br>          )<br>        &#125;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> &#123;<br>          mainHandler.removeCallbacks(watchDetachedView)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> &#123;<br>          mainHandler.post(watchDetachedView)<br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span> &#123;<br>    Curtains.onRootViewsChangedListeners += listener<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">uninstall</span><span class="hljs-params">()</span></span> &#123;<br>    Curtains.onRootViewsChangedListeners -= listener<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也不过是对rootview注册监听，具体的原理不说了，跟Activity的方式差不多。</p><h6 id="ServiceWatcher"><a href="#ServiceWatcher" class="headerlink" title="ServiceWatcher"></a><strong>ServiceWatcher</strong></h6><p>我们再看看ServiceWatcher</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceWatcher</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher) : InstallableWatcher &#123;<br>    ...<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span> &#123;<br>    checkMainThread()<br>    check(uninstallActivityThreadHandlerCallback == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-string">&quot;ServiceWatcher already installed&quot;</span><br>    &#125;<br>    check(uninstallActivityManager == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-string">&quot;ServiceWatcher already installed&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// hook ActivityThread 里面的 mH 的 mCallback</span><br>      swapActivityThreadHandlerCallback &#123; mCallback -&gt;<br>        uninstallActivityThreadHandlerCallback = &#123;<br>          swapActivityThreadHandlerCallback &#123;<br>            mCallback<br>          &#125;<br>        &#125;<br>        <span class="hljs-comment">// 代理对象，替换原来的Callback</span><br>        Handler.Callback &#123; msg -&gt;<br>          <span class="hljs-comment">// https://github.com/square/leakcanary/issues/2114</span><br>          <span class="hljs-comment">// On some Motorola devices (Moto E5 and G6), the msg.obj returns an ActivityClientRecord</span><br>          <span class="hljs-comment">// instead of an IBinder. This crashes on a ClassCastException. Adding a type check</span><br>          <span class="hljs-comment">// here to prevent the crash.</span><br>          <span class="hljs-keyword">if</span> (msg.obj !<span class="hljs-keyword">is</span> IBinder) &#123;<br>            <span class="hljs-keyword">return</span><span class="hljs-symbol">@Callback</span> <span class="hljs-literal">false</span><br>          &#125;<br><br>          <span class="hljs-comment">// 拦截 STOP_SERVICE 消息，这里主要是预处理获取到即将要被 destroy 的 service 对象</span><br>          <span class="hljs-keyword">if</span> (msg.what == STOP_SERVICE) &#123;<br>            <span class="hljs-keyword">val</span> key = msg.obj <span class="hljs-keyword">as</span> IBinder<br>            activityThreadServices[key]?.let &#123;<br>              onServicePreDestroy(key, it)<br>            &#125;<br>          &#125;<br>          <span class="hljs-comment">// 执行原有逻辑</span><br>          mCallback?.handleMessage(msg) ?: <span class="hljs-literal">false</span><br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// hook 替换原来的ActivityManageService 对象</span><br>      swapActivityManager &#123; activityManagerInterface, activityManagerInstance -&gt;<br>        uninstallActivityManager = &#123;<br>          swapActivityManager &#123; _, _ -&gt;<br>            activityManagerInstance<br>          &#125;<br>        &#125;<br>        <span class="hljs-comment">// 动态代理对象</span><br>        Proxy.newProxyInstance(<br>          activityManagerInterface.classLoader, arrayOf(activityManagerInterface)<br>        ) &#123; _, method, args -&gt;<br>          <span class="hljs-comment">// hook 到 service 真正 destroy 的时机，这里没法获取到servcie对象，所以要前面的预操作：onServicePreDestroy</span><br>          <span class="hljs-keyword">if</span> (METHOD_SERVICE_DONE_EXECUTING == method.name) &#123;<br>            <span class="hljs-keyword">val</span> token = args!![<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> IBinder<br>            <span class="hljs-keyword">if</span> (servicesToBeDestroyed.containsKey(token)) &#123;<br>              <span class="hljs-comment">// 回调监测</span><br>              onServiceDestroyed(token)<br>            &#125;<br>          &#125;<br>          <span class="hljs-comment">// 执行原有逻辑</span><br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span>) &#123;<br>              method.invoke(activityManagerInstance)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              method.invoke(activityManagerInstance, *args)<br>            &#125;<br>          &#125; <span class="hljs-keyword">catch</span> (invocationException: InvocationTargetException) &#123;<br>            <span class="hljs-keyword">throw</span> invocationException.targetException<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (ignored: Throwable) &#123;<br>      SharkLog.d(ignored) &#123; <span class="hljs-string">&quot;Could not watch destroyed services&quot;</span> &#125;<br>    &#125;<br>  &#125;<br>    ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceDestroyed</span><span class="hljs-params">(token: <span class="hljs-type">IBinder</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 通过 token 匹配到预处理时获取到的 service 对象</span><br>    servicesToBeDestroyed.remove(token)?.also &#123; serviceWeakReference -&gt;<br>      serviceWeakReference.<span class="hljs-keyword">get</span>()?.let &#123; service -&gt;<br>      <span class="hljs-comment">// 将 service 对象加入到 watchedObjects 里面，之后就和activity一样了</span><br>        reachabilityWatcher.expectWeaklyReachable(<br>          service, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;service::class.java.name&#125;</span> received Service#onDestroy() callback&quot;</span><br>        )<br>      &#125;<br>    &#125;<br>  &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>对Service的监控可能就比较奇怪了，因为Service没有对外公开Service生命周期的监听方式，所以只能hook ，所以这里面就涉及了Service的底层原理和hook技术，要真正理解的话得知道Service的底层原理的hook，这里简单说一下：启动Service的时候，在ActivityThread里面都会有记录，启动的Service都会存进mServices里面，onDestory的时候，AMS会用Handler发给ActivityThread告诉某某Service要销毁了，此时ActivityThread就会通过IActivityManger回调Service的onDestory方法，IActivityManger存储了四大组件的周期函数，所以通过它来调用Service的周期函数。因此原理也是这样，通过hook AMS发过来Service onDestory的信息记录Service，进而在IActivityManger回调Service onDestory的时候找到这个Service并监测。</p><h5 id="监听之后是怎么处理的呢？"><a href="#监听之后是怎么处理的呢？" class="headerlink" title="监听之后是怎么处理的呢？"></a>监听之后是怎么处理的呢？</h5><p>现在几个监测的类讲完了，那么第二个问题也解决了，接下来我们看看刚刚还没呢分析的核心组件</p><h6 id="InternalLeakCanary"><a href="#InternalLeakCanary" class="headerlink" title="InternalLeakCanary"></a><strong>InternalLeakCanary</strong></h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@JvmOverloads</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manualInstall</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  application: <span class="hljs-type">Application</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  retainedDelayMillis: <span class="hljs-type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>)</span></span>,<span class="hljs-comment">//对检测对象延迟5秒检测</span><br>  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)<span class="hljs-comment">//默认的一些观察器</span><br>) &#123;<br>  checkMainThread()<br>  <span class="hljs-keyword">if</span> (isInstalled) &#123;<br>    <span class="hljs-keyword">throw</span> IllegalStateException(<br>      <span class="hljs-string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause<br>    )<br>  &#125;<br>  check(retainedDelayMillis &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-string">&quot;retainedDelayMillis <span class="hljs-variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span><br>  &#125;<br>  <span class="hljs-keyword">this</span>.retainedDelayMillis = retainedDelayMillis<br>  <span class="hljs-keyword">if</span> (application.isDebuggableBuild) &#123;<br>    LogcatSharkLog.install()<span class="hljs-comment">//日志的初始化</span><br>  &#125;<br>  <span class="hljs-comment">//核心组件，用于检测泄漏和对堆转储(head dump)的分析</span><br>  LeakCanaryDelegate.loadLeakCanary(application)<br><br>  <span class="hljs-comment">//对每一个检测器进行初始化</span><br>  watchersToInstall.forEach &#123;<br>    it.install()<br>  &#125;<br>  <span class="hljs-comment">// Only install after we&#x27;re fully done with init.</span><br>  installCause = RuntimeException(<span class="hljs-string">&quot;manualInstall() first called here&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>看看LeakCanaryDelegate.loadLeakCanary(application)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> LeakCanaryDelegate &#123;<br><br>  <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>  <span class="hljs-keyword">val</span> loadLeakCanary <span class="hljs-keyword">by</span> lazy &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//通过反射实例化InternalLeakCanary，并调用了invoke方法</span><br>      <span class="hljs-keyword">val</span> leakCanaryListener = Class.forName(<span class="hljs-string">&quot;leakcanary.internal.InternalLeakCanary&quot;</span>)<br>      leakCanaryListener.getDeclaredField(<span class="hljs-string">&quot;INSTANCE&quot;</span>)<br>        .<span class="hljs-keyword">get</span>(<span class="hljs-literal">null</span>) <span class="hljs-keyword">as</span> (Application) -&gt; <span class="hljs-built_in">Unit</span><br>    &#125; <span class="hljs-keyword">catch</span> (ignored: Throwable) &#123;<br>      NoLeakCanary<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">object</span> NoLeakCanary : (Application) -&gt; <span class="hljs-built_in">Unit</span>, OnObjectRetainedListener &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onObjectRetained</span><span class="hljs-params">()</span></span> &#123;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要通过反射实例化咧？因为InternalLeakCanary在另一个模块，而他又是internal，所以只能通过反射了。那我们看看InternalLeakCanary复写的invoke方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>  _application = application<span class="hljs-comment">//传入application</span><br><br>  checkRunningInDebuggableBuild()<br><br>    <span class="hljs-comment">//哦~原来是在这设置的OnObjectRetainedListener</span><br>  AppWatcher.objectWatcher.addOnObjectRetainedListener(<span class="hljs-keyword">this</span>)<br><br>    <span class="hljs-comment">//创建gc触发器，这样的GC更容易触发垃圾回收</span><br>  <span class="hljs-keyword">val</span> gcTrigger = GcTrigger.Default<br><br>  <span class="hljs-keyword">val</span> configProvider = &#123; LeakCanary.config &#125;<br><br>  <span class="hljs-keyword">val</span> handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)<br>  handlerThread.start()<br>  <span class="hljs-keyword">val</span> backgroundHandler = Handler(handlerThread.looper)<br><br>    <span class="hljs-comment">// 创建分析heap dump的启动器,heap dump堆转储，上面提过</span><br>  heapDumpTrigger = HeapDumpTrigger(<br>    application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger,<br>    configProvider<br>  )<br>    <span class="hljs-comment">// 应用前后台监听，前后台监听逻辑差异化处理</span><br>  application.registerVisibilityListener &#123; applicationVisible -&gt;<br>    <span class="hljs-keyword">this</span>.applicationVisible = applicationVisible<br>    heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)<br>  &#125;<br>  registerResumedActivityListener(application)<br>    <span class="hljs-comment">//桌面添加图标</span><br>  addDynamicShortcut(application)<br><br>  <span class="hljs-comment">// We post so that the log happens after Application.onCreate()</span><br>  mainHandler.post &#123;<br>    <span class="hljs-comment">// https://github.com/square/leakcanary/issues/1981</span><br>    <span class="hljs-comment">// We post to a background handler because HeapDumpControl.iCanHasHeap() checks a shared pref</span><br>    <span class="hljs-comment">// which blocks until loaded and that creates a StrictMode violation.</span><br>    backgroundHandler.post &#123;<br>      SharkLog.d &#123;<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()) &#123;<br>          <span class="hljs-keyword">is</span> Yup -&gt; application.getString(R.string.leak_canary_heap_dump_enabled_text)<br>          <span class="hljs-keyword">is</span> Nope -&gt; application.getString(<br>            R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()<br>          )<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原来我们之前在moveToRetain里回调的方法在这注册的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveToRetained</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> &#123;<br>  removeWeaklyReachableObjects()<br>  <span class="hljs-keyword">val</span> retainedRef = watchedObjects[key]<br>  <span class="hljs-keyword">if</span> (retainedRef != <span class="hljs-literal">null</span>) &#123;<br>    retainedRef.retainedUptimeMillis = clock.uptimeMillis()<br>      <span class="hljs-comment">//责任链模式</span><br>    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那我们看看InternalLeakCanary对onObjectRetained()的实现，发现其调用的是scheduleRetainedObjectCheck()</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>::heapDumpTrigger.isInitialized) &#123;<br>    heapDumpTrigger.scheduleRetainedObjectCheck()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用的是scheduleRetainedObjectCheck()</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  delayMillis: <span class="hljs-type">Long</span> = <span class="hljs-number">0</span>L</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  <span class="hljs-keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt<br>  <span class="hljs-keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//通过记录时间戳来避免重复检测</span><br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  checkScheduledAt = SystemClock.uptimeMillis() + delayMillis<span class="hljs-comment">//记录时间</span><br>  backgroundHandler.postDelayed(&#123;<br>    checkScheduledAt = <span class="hljs-number">0</span><br>    checkRetainedObjects()<span class="hljs-comment">//检测留存的对象</span><br>  &#125;, delayMillis)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过记录时间避免重复检测，然后向子线程post了一Runnable，瞅瞅checkRetainedObjects</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkRetainedObjects</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//是否能够heap dump</span><br>  <span class="hljs-keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()<br><br>  <span class="hljs-keyword">val</span> config = configProvider()<br><br>  <span class="hljs-keyword">if</span> (iCanHasHeap <span class="hljs-keyword">is</span> Nope) &#123;<br>    <span class="hljs-keyword">if</span> (iCanHasHeap <span class="hljs-keyword">is</span> NotifyingNope) &#123;<span class="hljs-comment">//发送一个通知，用户点击后通过</span><br>      <span class="hljs-comment">// Before notifying that we can&#x27;t dump heap, let&#x27;s check if we still have retained object.</span><br>        <span class="hljs-keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount<br><br>        <span class="hljs-keyword">if</span> (retainedReferenceCount &gt; <span class="hljs-number">0</span>) &#123;<br>          gcTrigger.runGc()<span class="hljs-comment">//分析前再确保一次是否真的泄漏，调用一次GC</span><br>          retainedReferenceCount = objectWatcher.retainedObjectCount<br>        &#125;<br><br>        <span class="hljs-keyword">val</span> nopeReason = iCanHasHeap.reason()<br>        <span class="hljs-comment">//主要是判断是否达到阈值，前台的时候是&gt;=5个会触发，后台是&gt;=1个就会触发</span><br>        <span class="hljs-keyword">val</span> wouldDump = !checkRetainedCount(<br>          retainedReferenceCount, config.retainedVisibleThreshold, nopeReason<br>        )<br><br>        <span class="hljs-keyword">if</span> (wouldDump) &#123;<br>          <span class="hljs-keyword">val</span> uppercaseReason = nopeReason[<span class="hljs-number">0</span>].toUpperCase() + nopeReason.substring(<span class="hljs-number">1</span>)<br>          onRetainInstanceListener.onEvent(DumpingDisabled(uppercaseReason))<br>          showRetainedCountNotification(<span class="hljs-comment">//通知</span><br>            objectCount = retainedReferenceCount,<br>            contentText = uppercaseReason<br>          )<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      SharkLog.d &#123;<br>        application.getString(<br>          R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()<br>        )<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><span class="hljs-comment">//如果不能堆转储，进行了一些列操作，然后再尝试分析</span><br>  <span class="hljs-keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount<br><br>  <span class="hljs-keyword">if</span> (retainedReferenceCount &gt; <span class="hljs-number">0</span>) &#123;<br>    gcTrigger.runGc()<br>    retainedReferenceCount = objectWatcher.retainedObjectCount<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">val</span> now = SystemClock.uptimeMillis()<br>  <span class="hljs-keyword">val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis<br>  <span class="hljs-keyword">if</span> (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;<br>    onRetainInstanceListener.onEvent(DumpHappenedRecently)<br>    showRetainedCountNotification(<br>      objectCount = retainedReferenceCount,<br>      contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)<br>    )<br>    scheduleRetainedObjectCheck(<br>      delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis<br>    )<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  dismissRetainedCountNotification()<br>  <span class="hljs-keyword">val</span> visibility = <span class="hljs-keyword">if</span> (applicationVisible) <span class="hljs-string">&quot;visible&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;not visible&quot;</span><br>    <span class="hljs-comment">//分析hprof文件</span><br>  dumpHeap(<br>    retainedReferenceCount = retainedReferenceCount,<br>    retry = <span class="hljs-literal">true</span>,<br>    reason = <span class="hljs-string">&quot;<span class="hljs-variable">$retainedReferenceCount</span> retained objects, app is <span class="hljs-variable">$visibility</span>&quot;</span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>先看看能不能堆转储，如果可以，就发送通知，如果不能，做了一系列操作，再尝试分析，其实这跟MAT有点类似，MAT也是不能直接就解析hprof文件，最后你会发现，最终调用的都是dumpHeap()方法，我们看dumpHeap方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">HeapDumpTrigger.kt<br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpHeap</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  retainedReferenceCount: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  retry: <span class="hljs-type">Boolean</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  reason: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  <span class="hljs-keyword">val</span> directoryProvider =<br>    InternalLeakCanary.createLeakDirectoryProvider(InternalLeakCanary.application)<br>  <span class="hljs-keyword">val</span> heapDumpFile = directoryProvider.newHeapDumpFile()<span class="hljs-comment">//创建导出的文件夹</span><br><br>  <span class="hljs-keyword">val</span> durationMillis: <span class="hljs-built_in">Long</span><br>  <span class="hljs-keyword">if</span> (currentEventUniqueId == <span class="hljs-literal">null</span>) &#123;<br>    currentEventUniqueId = UUID.randomUUID().toString()<br>  &#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>    InternalLeakCanary.sendEvent(DumpingHeap(currentEventUniqueId!!))<br>    <span class="hljs-keyword">if</span> (heapDumpFile == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">&quot;Could not create heap dump file&quot;</span>)<br>    &#125;<br>    saveResourceIdNamesToMemory()<br>    <span class="hljs-keyword">val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()<br>    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis<br>    durationMillis = measureDurationMillis &#123;<br>      configProvider().heapDumper.dumpHeap(heapDumpFile)<span class="hljs-comment">//主要方法，用系统导出堆转储文件</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (heapDumpFile.length() == <span class="hljs-number">0L</span>) &#123;<br>      <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">&quot;Dumped heap file is 0 byte length&quot;</span>)<br>    &#125;<br>    lastDisplayedRetainedObjectCount = <span class="hljs-number">0</span><br>    lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()<br>    objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)<br>    currentEventUniqueId = UUID.randomUUID().toString()<br>      <span class="hljs-comment">//将导出情况回调出去，根据失败和成功给用户弹通知（一般是成功）</span><br>    InternalLeakCanary.sendEvent(HeapDump(currentEventUniqueId!!, heapDumpFile, durationMillis, reason))<br>  &#125; <span class="hljs-keyword">catch</span> (throwable: Throwable) &#123;<br>    InternalLeakCanary.sendEvent(HeapDumpFailed(currentEventUniqueId!!, throwable, retry))<br>    <span class="hljs-keyword">if</span> (retry) &#123;<br>      scheduleRetainedObjectCheck(<br>        delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS<br>      )<br>    &#125;<br>    showRetainedCountNotification(<br>      objectCount = retainedReferenceCount,<br>      contentText = application.getString(<br>        R.string.leak_canary_notification_retained_dump_failed<br>      )<br>    )<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先创建了文件夹然后是保存时间，ID啊一些的操作，最主要的是configProvider().heapDumper.dumpHeap(heapDumpFile)，查找它的实现其实就是</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> AndroidDebugHeapDumper : HeapDumper &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpHeap</span><span class="hljs-params">(heapDumpFile: <span class="hljs-type">File</span>)</span></span> &#123;<br>    Debug.dumpHprofData(heapDumpFile.absolutePath)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用系统的Debug工具调出hprof文件。之后我们看导出成功回调做了什么事情</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> RemoteWorkManagerHeapAnalyzer : EventListener &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> REMOTE_SERVICE_CLASS_NAME = <span class="hljs-string">&quot;leakcanary.internal.RemoteLeakCanaryWorkerService&quot;</span><br><br>  <span class="hljs-keyword">internal</span> <span class="hljs-keyword">val</span> remoteLeakCanaryServiceInClasspath <span class="hljs-keyword">by</span> lazy &#123;<span class="hljs-comment">//返回true</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      Class.forName(REMOTE_SERVICE_CLASS_NAME)<br>      <span class="hljs-literal">true</span><br>    &#125; <span class="hljs-keyword">catch</span> (ignored: Throwable) &#123;<br>      <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(event: <span class="hljs-type">Event</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">is</span> HeapDump) &#123;<br>      <span class="hljs-keyword">val</span> application = InternalLeakCanary.application<br>      <span class="hljs-keyword">val</span> heapAnalysisRequest =<span class="hljs-comment">//构建一个workmanagerRequest，执行一次</span><br>        OneTimeWorkRequest.Builder(RemoteHeapAnalyzerWorker::<span class="hljs-keyword">class</span>.java).apply &#123;<br>          <span class="hljs-keyword">val</span> dataBuilder = Data.Builder()<br>            .putString(ARGUMENT_PACKAGE_NAME, application.packageName)<br>            .putString(ARGUMENT_CLASS_NAME, REMOTE_SERVICE_CLASS_NAME)<br>          setInputData(event.asWorkerInputData(dataBuilder))<br>          with(WorkManagerHeapAnalyzer) &#123;<span class="hljs-comment">//任务内容在WorkManagerHeapAnalyzer里面</span><br>            addExpeditedFlag()<br>          &#125;<br>        &#125;.build()<br>      SharkLog.d &#123; <span class="hljs-string">&quot;Enqueuing heap analysis for <span class="hljs-subst">$&#123;event.file&#125;</span> on WorkManager remote worker&quot;</span> &#125;<br>      <span class="hljs-keyword">val</span> workManager = WorkManager.getInstance(application)<br>      workManager.enqueue(heapAnalysisRequest)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现根据回调的Event类型，回调到了这里，传进来的Event就是HeapDump，可以看到用WorkManager创建了一个异步任务WorkManagerHeapAnalyzer，然后执行</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteHeapAnalyzerWorker</span>(appContext: Context, workerParams: WorkerParameters) :<br>  RemoteListenableWorker(appContext, workerParams) &#123;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startRemoteWork</span><span class="hljs-params">()</span></span>: ListenableFuture&lt;Result&gt; &#123;<br>    <span class="hljs-keyword">val</span> heapDump = inputData.asEvent&lt;HeapDump&gt;()<br>    <span class="hljs-keyword">val</span> result = SettableFuture.create&lt;Result&gt;()<br>    heapAnalyzerThreadHandler.post &#123;<span class="hljs-comment">//开启子线程执行分析任务</span><br>      <span class="hljs-keyword">val</span> doneEvent = AndroidDebugHeapAnalyzer.runAnalysisBlocking(heapDump, isCanceled = &#123;<br>        result.isCancelled<br>      &#125;) &#123; progressEvent -&gt;<br>        <span class="hljs-keyword">if</span> (!result.isCancelled) &#123;<span class="hljs-comment">//将分析进度发送出去</span><br>          InternalLeakCanary.sendEvent(progressEvent)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (result.isCancelled) &#123;<br>        SharkLog.d &#123; <span class="hljs-string">&quot;Remote heap analysis for <span class="hljs-subst">$&#123;heapDump.file&#125;</span> was canceled&quot;</span> &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        InternalLeakCanary.sendEvent(doneEvent)<span class="hljs-comment">//结束</span><br>        result.<span class="hljs-keyword">set</span>(Result.success())<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getForegroundInfoAsync</span><span class="hljs-params">()</span></span>: ListenableFuture&lt;ForegroundInfo&gt; &#123;<br>    <span class="hljs-keyword">return</span> applicationContext.heapAnalysisForegroundInfoAsync()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>heapAnalyzerThreadHandler实际上就是开启一个子线程然后执行runAnalysisBlocking，runAnalysisBlocking里面就是把文件交给了HeapAnalyzer去分析，HeapAnalyzer然后用Shark 分析hprof文件，具体Shark分析的原理就不说了，我也没怎么研究过，我觉得也没有用，会用就行了。Shark是LeakCanary的一个分析hprof文件的模块，因此我们也可以用shark开发一个用于线上的SDK，LeakCanary现在是不支持线上检测的。</p><p>用一张图总结一下它的原理其实就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sequence">AppWatcher -&gt; objectWatcher:检测到泄漏<br>objectWatcher -&gt; InternalLeakCanary:5秒后gc还是没回收<br>InternalLeakCanary-&gt;HeapDumpTrigger:scheduleRetainedObjectCheck()<br>HeapDumpTrigger-&gt;HeapAnalyzerThreadHandler:再强制GC一次，还是泄漏<br>HeapAnalyzerThreadHandler-&gt;HeapAnalyzer:dumpHeap()<br>HeapAnalyzer-&gt;Shark分析:<br>Shark分析 -&gt; dataBase:发出通知，数据存进数据库<br><br></code></pre></td></tr></table></figure><p>可能还有人会疑另一个叫Leaks的app图标怎么生成的，其实它也不算是个app，它是你app的一部分，不信你把Leaks卸载了，你的app也会跟着卸载。实现这个很简单，用<activity-alias>标签就能实现。示例如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">    <span class="hljs-attr">.</span> <span class="hljs-attr">.</span> <span class="hljs-attr">.</span>&gt;</span><br>    <br>    . . .<br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.SecondActivity&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activity-alias</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.jason.demo.dynamicshortcut.ShortcutLauncherActivity&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_alias&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;ActivityAlias&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:targetActivity</span>=<span class="hljs-string">&quot;.SecondActivity&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">activity-alias</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>android:targetActivity</code> 指定所必须的打开的目标 Activity，对应着一个在 <code>AndroidManifest.xml</code> 中申明的 <code>&lt;activity&gt;</code>。<code>android:name</code> 是别名的唯一名称，<strong>不引用实际类</strong>。<code>android:icon</code> 以及 <code>android:label</code> 指定一个新的图标和标签给用户。之后就能看见你的app生成了两个图标。</p><p>你如果不想LeakCanary自动初始化也是可以的。设置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bool</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;leak_canary_watcher_auto_install&quot;</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在你想要初始化的地方AppWatcher.manualInstall即可</p><p>好了，LeakCanary源码算简单分析了一下，不算细致，可以借鉴一下。下面是一些常见的内存泄漏</p><ol><li><p>单例模式引发的内存泄漏</p><p>原因：单例模式里的静态实例持有对象的引用，导致对象无法被回收，常见为持有Activity的引用</p><p>优化：改为持有Application的引用，或者不持有使用的时候传递。</p></li><li><p>集合操作不当引发的内存泄漏</p><p>原因：集合只增不减</p><p>优化：有对应的删除或卸载操作</p></li><li><p>线程的操作不当引发的内存泄漏</p><p>原因：线程持有对象的引用在后台执行，与对象的生命周期不一致</p><p>优化：静态实例+弱引用(WeakReference)方式，使其生命周期一致</p></li><li><p>匿名内部类&#x2F;非静态内部类操作不当引发的内存泄漏</p><p>原因：内部类持有对象引用，导致无法释放，比如各种回调</p><p>优化：保持生命周期一致，改为静态实例+对象的弱引用方式（WeakReference）</p></li><li><p>常用的资源未关闭回收引发的内存泄漏</p><p>原因：BroadcastReceiver，File，Cursor，IO流，Bitmap等资源使用未关闭</p><p>优化：使用后有对应的关闭和卸载机制</p></li><li><p>Handler使用不当造成的内存泄漏</p><p>原因：Handler持有Activity的引用，其发送的Message中持有Handler的引用，当队列处理Message的时间过长会导致Handler无法被回收</p><p>优化：静态实例+弱引用(WeakReference)方式</p></li></ol><h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><p>在上一章我们说activity在onCreate的时候会绘制布局，这也是性能优化很重要的一个点。</p><p>通过学习view的绘制流程我们知道，对于屏幕刷新频率60hz的手机来说，如果在1000&#x2F;60&#x3D;16.67ms内没有把这一帧的任务执行完毕，就会发生丢帧的现象，丢帧是造成界面卡顿的直接原因，渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout等计算操作，GPU负责Rasterization（栅格化）操作。</p><p>所谓栅格化，就是将矢量图形转换为位图的过程，手机上显示是按照一个个像素来显示的，比如将一个Button、TextView等组件拆分成一个个像素显示到手机屏幕上。而UI渲染优化的目的就是减轻CPU、GPU的压力，除去不必要的操作，保证每帧16ms以内处理完所有的CPU与GPU的计算、绘制、渲染等等操作，使UI顺滑、流畅的显示出来。</p><h4 id="过度绘制"><a href="#过度绘制" class="headerlink" title="过度绘制"></a>过度绘制</h4><p>UI渲染优化的第一步就是找到Overdraw（过度绘制），即描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在重叠的UI布局中，如果不可见的UI也在做绘制的操作或者后一个控件将前一个控件遮挡，会导致某些像素区域被绘制了多次，从而增加了CPU、GPU的压力。</p><p>那么如何找出布局中Overdraw的地方呢？很简单，就是打开手机里开发者选项，然后将调试GPU过度绘制的开关打开即可，然后就可以看到应用的布局是否被Overdraw，比如我打开了调试过度绘制的开关，然后看QQ是这样的<br><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220712_174301.jpg" style="zoom: 25%;" /><br>蓝色、淡绿、淡红、深红代表了4种不同程度的Overdraw情况，1x、2x、3x和4x分别表示同一像素上同一帧的时间内被绘制了多次，1x就表示一次(最理想情况)，4x表示4次(最差的情况)，而我们做性能优化时，考虑消除的就是3x和4x。</p><p>其次是自定义view时的过度绘制，我们知道，自定义View的时候有时会重写onDraw方法，但是Android系统是无法检测onDraw里面具体会执行什么操作，从而系统无法为我们做一些优化。这样对编程人员要求就高了，如果View有大量重叠的地方就会造成CPU、GPU资源的浪费，此时我们可以使用canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视，还有clipPath()也是可以减少过度绘制的，只不过可能效果甚微。</p><h4 id="合理布局"><a href="#合理布局" class="headerlink" title="合理布局"></a>合理布局</h4><p>在Android种系统对View进行测量、布局和绘制时，都是通过对View树的遍历来进行操作的。如果一个View树的高度太高就会严重影响测量、布局和绘制的速度。Google设计嵌套View最多是10层否则会崩溃。现在版本种Google使用RelativeLayout替代LineraLayout作为默认根布局，目的就是降低LineraLayout嵌套产生布局树的高度，从而提高UI渲染的效率。一下是合理布局的一些建议</p><ol><li>布局重用，对于多次重用的布局使用<include>标签来达到重用的目的，对于根布局一样的，可使用<merge>标签取消冗余的viewgroup。比如我我们使用<include>标签的时候可能include里面的布局最外层是<LinearLayout>，而在外部的外层布局也是<LinearLayout>，这时候就可以用<merge>标签替换里面的<LinearLayout>，然后系统就会把include的布局放到外部的LinearLayout而忽视merge，从而减少一层嵌套。</li><li>对于一些复杂的布局我们有时候是不需要一来就全部加载的，这时候就可以用<ViewStub>标签来实现延迟加载，那有人可能会问，我直接设置控件的visible和invisible不行吗，是可以。但是设置visibility属性布局依然会被加载，只是不显示罢了，而VeiwStub只有被设置成visible时才会被加载。</li><li>减少布局层级当布局层级太多的时候可以考虑Constranlayout，这个布局性能很好，适配好还能减少布局间的嵌套，其次可以考虑RelaticeLayout。</li><li>减少不必要的背景设置，减少复杂shape等。能用父布局的背景，子布局就没必要再设置背景。</li></ol><p>那么怎样更直观地看自己App的布局层级呢？AS已经为我们集成了这么一个工具，具体打开的地方（需启动一个app）：</p><p>Tools -&gt; Layout Inspector</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220712180704.png"></p><p>左边是你app的布局树，中间是布局预览，右边是布局属性。借此可以全局分析你的app布局，就没必要再去每一个xml布局去看了。</p><h3 id="WebVeiw优化"><a href="#WebVeiw优化" class="headerlink" title="WebVeiw优化"></a>WebVeiw优化</h3><p>WebView也是UI的一个部分，虽然html界面布局我们改变不了，但是我们可以通过WebView的用法去提高webview的性能。</p><h4 id="webview提前初始化"><a href="#webview提前初始化" class="headerlink" title="webview提前初始化"></a><strong>webview提前初始化</strong></h4><p>我们知道每个页面在打开时都会调用setContentView()方法 -&gt; inflate() -&gt; createViewFromTag()，也就是说都会调用view的构造函数，webview也不例外，但是不同的是webview的首次构造耗时比较长。我们可以测试一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        findViewById&lt;Button&gt;(R.id.button).setOnClickListener &#123;<br>            test()<br>            test()<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> start = System.currentTimeMillis()<br>        WebView(App.appContext)<br>        <span class="hljs-keyword">val</span> stop = System.currentTimeMillis()<br>        Log.d(<span class="hljs-string">&quot;RQ&quot;</span>, <span class="hljs-string">&quot;test: <span class="hljs-subst">$&#123;stop - start&#125;</span>&quot;</span>)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">07</span>-<span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">15</span>:<span class="hljs-number">07</span>.<span class="hljs-number">432</span> <span class="hljs-number">29656</span>-<span class="hljs-number">29656</span>/com.example.improvetest D/RQ: test: <span class="hljs-number">167</span><br><span class="hljs-attribute">2022</span>-<span class="hljs-number">07</span>-<span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">15</span>:<span class="hljs-number">07</span>.<span class="hljs-number">435</span> <span class="hljs-number">29656</span>-<span class="hljs-number">29656</span>/com.example.improvetest D/RQ: test: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>可以看到第二次初始化webview的时间远小于第一次，这是为什么捏？因为它要加载Webview内核，这是一个重量级的操作，内核是以apk的形式存在。而内核加载后在同一页面是共享的，因此后续的初始化时间就很少了。</p><p>那知道了这个我们可以提前初始化一个webview，减少后续webview初始化的时间。</p><h4 id="WebView硬件加速致使页面渲染闪烁"><a href="#WebView硬件加速致使页面渲染闪烁" class="headerlink" title="WebView硬件加速致使页面渲染闪烁"></a><strong>WebView硬件加速致使页面渲染闪烁</strong></h4><p>4.0以上的系统我们开启硬件加速后，WebView渲染页面更加快速，拖动也更加顺滑。但有个反作用就是，但有的时候可能会出现页面闪烁的情况，解决这个问题的方法是在闪烁前将WebView的硬件加速临时关闭，之后再开启，代码以下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;<br><span class="hljs-comment">//关闭硬件加速</span><br><span class="hljs-comment">//webview.setLayerType(View.LAYER_TYPE_SOFTWARE, null)</span><br><span class="hljs-comment">//开启硬件加速</span><br>    <span class="hljs-comment">//webview.setLayerType(View.LAYER_TYPE_HARDWARE, null)</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="增加进度条"><a href="#增加进度条" class="headerlink" title="增加进度条"></a><strong>增加进度条</strong></h4><p>在网络不是很好的情况下，加载页面会出现白屏的情况，虽然我们不能改变，但是我们可以增加一个进度条来让用户知道加载进度，这也算是提升了性能了吧。具体代码如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">webView.webChromeClient = <span class="hljs-keyword">object</span> :WebChromeClient()&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onProgressChanged</span><span class="hljs-params">(view: <span class="hljs-type">WebView</span>?, newProgress: <span class="hljs-type">Int</span>)</span></span> &#123;<br>                <span class="hljs-keyword">if</span>(newProgress==<span class="hljs-number">100</span>)&#123;<br>                    pg1.setVisibility(View.GONE);<span class="hljs-comment">//加载完网页进度条消失</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    pg1.setVisibility(View.VISIBLE);<span class="hljs-comment">//开始加载网页时显示进度条</span><br>                    pg1.setProgress(newProgress);<span class="hljs-comment">//设置进度值</span><br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>如果webveiw在你的应用中占比很高，很重要，还可以将webview做成一个独立进程（如果有能力），然后用aidl，messager，content provider，广播等来跨进程通信，这样webview就不会影响原app的性能。比如QQ，微信，微信的第一次重构就将webview做成了独立的进程。</p><p>webview我用的也不是很多，把一些我们可能用得上一些问题的做法给大家分享了一些，如果还觉得不够细致，具体可看看<a href="https://juejin.cn/post/6857701249295810568">Android WebView 优化梳理 - 掘金 (juejin.cn)</a></p><h2 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h2><p>卡顿优化其实前面也分析过了，UI绘制卡顿呐，启动慢导致的卡顿呐等等，具体见启动优化和渲染优化。这里说说卡顿到极致—-ANR之后如何解决。</p><h4 id="ANR问题分析"><a href="#ANR问题分析" class="headerlink" title="ANR问题分析"></a>ANR问题分析</h4><p>ANR(Application Not responding)问题一般出现在Activtiy5秒之内无法响应屏幕触摸事件或者键盘输入事件，而BroadcastReceiver如果10秒之内还未执行完操作也会ANR。在实际开发中，ANR是很难从代码上发现的，那么我们应该怎么定位问题呢？其实，当一个进程发生ANR以后，系统会在&#x2F;data&#x2F;anr目录下创建记录ANR问题的文件，通过分析这些文件就能定位ANR的位置。</p><p>这里我们模拟一下ANR，主界面就一个按钮，然后给按钮注册监听：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        <span class="hljs-keyword">val</span> button = findViewById&lt;Button&gt;(R.id.button)<br>        button.setOnClickListener &#123;<br>            testANR()<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testANR</span><span class="hljs-params">()</span></span> &#123;<br>        Thread.sleep(<span class="hljs-number">30</span>*<span class="hljs-number">1000</span>)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>之后点击按钮两次你就会看到ANR或者直接崩溃。之后我们就假装不知道ANR的位置，开始分析问题。</p><p>在老版本系统（<code>Android8.1</code>以下）的手机上，可以直接利用<code>adb pull /data/anr/traces.txt</code> 命令进行日志导出。</p><p>在新系统中用这个命令是无法导出的，它会提示你权限不够。那么怎么办呢，我们可以通过<code>adb bugreport [导出目录]</code>进行导出，这个会导出一大堆东西（我们只挑选有用的）。比如在控制台执行<code>adb bugreport E:\test</code> ，他会从手机中导出一个<code>zip</code>包到电脑的<code>E:\test</code>目录，会有导出进度显示：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708215247.png" alt="D"></p><p>导出完成：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708215035.png" alt="D"></p><p>随后找到导出的文件，解压缩，在<code>/FS/data/anr</code>目录下可以找到程序中的ANR日志。</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708215416.png" alt="A"></p><p>打开日志文件大致浏览一下：</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708220207.png"></p><p>可以很明显看到是MainActivtiy里面的onCreate里面的按钮的点击事件的testANR方法里面的Thread.sleep造成的ANR，于是我们就可以痛快地解决问题啦。</p><p>当然，实际问题可能比这个更复杂，这里只是告诉大家这么一个方法，到时候就具体问题具体分析。 这里列出一些常见的ANR原因</p><ul><li>主线程阻塞或主线程数据读取</li></ul><blockquote><p>解决办法：避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。尽量避免在主线程query provider、<a href="https://link.jianshu.com/?t=http://weishu.me/2016/10/13/sharedpreference-advices/">不要滥用SharePreferenceS</a></p></blockquote><ul><li>CPU满负荷，I&#x2F;O阻塞</li></ul><blockquote><p>解决办法：文件读写或数据库操作放在子线程异步操作。</p></blockquote><ul><li>内存不足</li></ul><blockquote><p>解决办法：<code>AndroidManifest.xml</code>文件<applicatiion>中可以设置 <code>android:largeHeap=&quot;true&quot;</code>，以此增大App使用内存。不过<strong>不建议使用此法</strong>，从根本上防止内存泄漏，优化内存使用才是正道。</p></blockquote><ul><li>各大组件ANR</li></ul><blockquote><p>各大组件生命周期中也应避免耗时操作，注意BroadcastReciever的onRecieve()、后台Service和ContentProvider也不要执行太长时间的任务。</p></blockquote><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><p>App的网络连接对于用户来说, 影响很多, 且多数情况下都很直观, 直接影响用户对这个App的使用体验. 其中较为重要的两点：</p><ul><li><strong>流量</strong> ：App的流量消耗对用户来说是比较敏感的，毕竟流量是花钱的嘛.。现在大部分人的手机上都有安装流量监控的工具App，用来监控App的流量使用。如果我们的App这方面没有控制好，会给用户不好的使用体验。</li><li><strong>用户等待</strong> ：也就是用户体验，良好的用户体验，才是我们留住用户的第一步。如果App请求等待时间长，会给用户网络卡，应用反应慢的感觉，如果有对比，有替代品，我们的App很可能就会被用户无情抛弃。</li></ul><h4 id="如何监测app的网络情况"><a href="#如何监测app的网络情况" class="headerlink" title="如何监测app的网络情况"></a>如何监测app的网络情况</h4><p>监测app网络的工具有很多，比如AS自带的，Fiddler代理工具等等。代理工具就不说了，有很多。这里介绍AS自带的工具如何使用。</p><p>启动地方 AS -&gt; App Inspection</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/AAA.png" alt="A"></p><p>然后就是这样的</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220712233902.png"></p><p>中间的是网络监听状况，左边的是数据库监听状况，最右边的是后台服务的监听状况，看英文应该也好理解。数据库监听是这样的</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220712234246.jpg" alt="A"></p><p>什么表名啊，列都有，存的内容也有。网络监听是这样的</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220712234418.jpg" alt="A"></p><p>蓝色的是下载文件的速度，橙色的是上传文件的速度。后台服务的就不展示了，大家可以试试看。</p><h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><h5 id="合理使用网络缓存"><a href="#合理使用网络缓存" class="headerlink" title="合理使用网络缓存"></a>合理使用网络缓存</h5><p>适当的使用缓存，不仅可以让我们的应用看起来更快，也能避免一些不必要的流量消耗，带来更好的用户体验，我们可以对设备的使用状态进行监听，在wifi下可以缓存一部分图片。比方说Splash闪屏广告图片，我们可以在连接到Wifi时下载缓存到本地；新闻类的App可以在Wifi状态下做离线缓存</p><h5 id="限制访问次数"><a href="#限制访问次数" class="headerlink" title="限制访问次数"></a>限制访问次数</h5><p>我们在开发app过程中有的时候会设置一个按钮，然后点击按钮发送请求，这样其实不是最优做法，如果我点击很多次按钮，就会在短时间内发送多次请求，那么就会浪费流量，也很消耗app的性能。所以我们需要限制访问次数，两种方案</p><ol><li>限制按钮的点击次数</li><li>封装网络请求框架，在框架里限制同一时间访问的次数</li></ol><h5 id="不同状态展现不同页面"><a href="#不同状态展现不同页面" class="headerlink" title="不同状态展现不同页面"></a>不同状态展现不同页面</h5><p>加载时显示好康的动画，留住用户，加载失败也要展现好康的动画给用户看（别直接崩溃了）。</p><p>其实说了这么多，一个好的网络请求框架就可以解决这些网络优化的问题，把这些解决方案封装在自己的网络请求框架里是最好的选择。</p><h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><p>现今，我们可能对流量都不是很缺，而且基本每家都有wifi，相较与流量我觉得一个app的耗电对用户更加敏感，现在市面上的手机基本上都有监控每个app的耗电功能，比如我的</p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220713_140120.jpg" style="zoom:25%;" /><p>可以看到QQ后台耗电多，抖音前台耗电多，但是这是QQ，没办法都得用，如果我们自己的app可能就被卸载了。那么我们先来分析一下为什么会耗电，盗用网上一张图就是</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d23d65e12d34ad396b8826de6bf2d35~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>事实上就是软件调用硬件而产生了耗电，那有哪些硬件是可以控制的捏？</p><img src="https://img-blog.csdnimg.cn/img_convert/451499b3b9f8131b8396c7870d76670a.png" alt="img" style="zoom: 50%;" /><p>有这么这么多，我们就看几个常用的，CPU、GPU、Video、Audio、GPS、Network</p><h5 id="Video、Audio"><a href="#Video、Audio" class="headerlink" title="Video、Audio"></a>Video、Audio</h5><p>在使用这些功能的使用时候，他牵涉的不单单一个元器件的问题，而是更多，所以我们在使用这些功能的时候要做到离开即刻关闭释放。这两个组件用的最多的可能就是短视频和直播app了，如果出现这部分耗电严重，可以看看这些解决方案：</p><ol><li>线程数是否暴增。</li><li>弹幕是否做到复用了，是否存在内存泄露问题。</li><li>动画特效是否及时释放，执行效率是否很快。</li><li>承载功能的实例是否存在多份。</li><li>检查内存、cpu使用情况。</li></ol><h5 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h5><p>无线网络包括移动网络和wifi两种情况。移动网络是比wifi更加耗电的。</p><p><strong>移动网络</strong></p><p>移动网络数据传输有3种状态：</p><p>高功率状态：网络激活，允许设备以最大传输速率进行传输。</p><p>低功率状态：传输速率低于15kbps，耗电是高功率状态的一半，一般不能直接从程序中进入该状态，而是由高功率状态降级进入。</p><p>空闲状态：没有数据连接需要传输，耗电最少。可以看出，三种状态耗电不同，要使耗电最低应该尽量保持状态在空闲或低功率下。从空闲状态转换到高功率状态大概需要2s，从低功率状态转换到高功率状态需要1.5s。</p><p>应用中每创建一个网络连接，网络射频都会转到高功率状态，数据传输完毕降回低功率状态，降回过程需要5s，这5s耗电量保持在高功率状态，低功率降回到空闲状态需要12s，期间一直保持低功率状态。所以每次的数据传输都将导致将近20s电量的消耗。</p><p><strong>WIFI网络</strong></p><p>WIFI在active状态下有4种模式：低功率、高功率、低传输、高传输。</p><p>当从低(高)功率状态传输数据时，WIFI会暂时进入相应的低(高)传输状态，一旦数据传输完毕就回到初始状态。WIFI耗电是受包率(每秒接收和发送的数据包)和网速因素影响的。如果因素良好，即网络良好时，数据传输的很快，所以WIFI的高功率状态维持时间很短。这也就是为什么说移动网络耗电高于WIFI耗电，因为同样的数据大小传输时，移动网络固定状态转换就需要近20s的电量消耗。通过上面了解了网络连接过程，应该心里有了大概的优化建议。</p><p><strong>网络耗电优化方案：</strong></p><ol><li>文本和文件压缩传输。 不管发送还是请求数据，在数据传输过程中使用gzip（Gzip是传输时将文件压缩传输的一种技术，okhttp默认是使用了gzip的）将数据进行压缩。经过压缩的数据需要更短的时间传输即可完成，这样使得无线所处的高功率状态时间更短，从而减少了耗电。</li><li>精简文本文件，去掉文本中空行、空格、注释等无意义内容。</li><li>请求一个图片时，客户端提供一个分辨率大小，服务器根据分辨率把裁剪缩放后的图片给客户端返回，采用使用webp图片。（节省传输时间）</li></ol><h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><strong>CPU</strong></h5><p>cpu作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。通过上面的两个概念我们大概知道，一个我们负责设备运算和控制的元器件，一个是程序运算调度的最小单位。</p><p>CPU被高频次使用大概有以下几个原因：</p><ol><li><p>程序运算复杂(高运算量)，例如高精度等，导致CPU满负荷运载，这里优化可能就设计数据结构、算法啥的。</p></li><li><p>程序线程短时间内无规则抢占CPU资源。</p></li><li><p>wakelock唤醒。wakelock是什么？</p><blockquote><p>为了延长电池的使用寿命，Android设备会在一段时间后使屏幕变暗，然后关闭屏幕显示，最后停止CPU。WakeLock是一个电源管理系统服务功能，应用程序可以使用它来控制设备的电源状态。</p><p>WakeLock可以用来保持CPU运行，避免屏幕变暗和关闭，以及避免键盘背光灯熄灭。</p></blockquote></li><li><p>定时器（AlarmManager）。</p></li></ol><h5 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a><strong>其他</strong></h5><p>我们用的多是GPS定位、Sensor遥感，只有当我们需要的时候才去打开这些硬件资源，并且及时释放，就能做到电量使用最优了。</p><p>接下来介绍一下AS对手机电量监控的工具，具体打开方式：AS -&gt; Profiler -&gt; Energy</p><p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220713002246.png"></p><p>其实跟之前看CPU和内存差不多，鼠标放上去能看到CPU、Network、Location的耗电程度，大致分为None、Light（轻）、Medium（中）、Heavy（严重）</p><p>当然，还有个更好的检测软件，叫Battery Historian，这里就不演示了，可自行上网查询。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对性能优化的学习，我发现他涉及的知识是方方面面的，像AMS、PMS、WMS、hook、启动流程等等等等，所以我觉得要真正做到性能优化，对这些一定要很了解的，不然完全不知道从哪下手。同时，这篇文章肯定还存在不足，可能也有错误，如果大家发现了都可以提出来。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/19/Gilde%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2022/10/19/Gilde%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要用Glide"><a href="#为什么要用Glide" class="headerlink" title="为什么要用Glide"></a>为什么要用Glide</h2><ul><li>多种图片格式的缓存，适用于更多的内容表现形式（如Gif、WebP、缩略图、Video），并且内部自动处理，所有格式都不需要增加额外的代码</li><li>生命周期集成（根据Activity或者Fragment的生命周期管理图片加载请求)Glide可以感知调用页面的生命周期，根据生命周期自动选择要不要加载图片并显示出来</li><li>高效的缓存策略，灵活（Picasso只会缓存原始尺寸的图片，Glide缓存的是多种规格），加载速度快且内存开销小（默认Bitmap格式的不同，使得内存开销是Picasso的一半）</li></ul><p>总结就是：支持图片格式多；Bitmap复用和主动回收；生命周期感应；优秀的缓存策略；加载速度快（Bitmap默认格式RGB565）</p><blockquote><p>注：本文所分析的是Glide 4.13.2</p></blockquote><h2 id="Glide的一些基本用法"><a href="#Glide的一些基本用法" class="headerlink" title="Glide的一些基本用法"></a>Glide的一些基本用法</h2><p>在说源码之间，我们先说一些基本的用法：</p><p>使用之间，要先在项目中引入依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;com.github.bumptech.glide:glide:4.4.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>并且要获取网络权限，因为大部分情况下我们都会去网上加载一张图片，当然如果加载的是本地图片，就不需要申请这个玩意儿：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>Glide加载一张图片只需要简单的一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Glide.with(activity).load(<span class="hljs-string">&quot;url&quot;</span>).into(imageView)<br></code></pre></td></tr></table></figure><p>这样Glide会自动下载指定<code>url</code>下的图片，并将其显示到指定的<code>ImageView</code>上面</p><h4 id="占位图"><a href="#占位图" class="headerlink" title="占位图"></a>占位图</h4><p>但在网络情况不是很理想的条件下，比如网速很慢的时候，我们需要等待很长一段时间图片才会加载出来，这时我们可能就需要一张占位图，在 图片还没有加载出来之前，先显示出来，图片加载之后再替换掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> options: RequestOptions = RequestOptions()<br>    .placeholder(<span class="hljs-comment">/*占位图*/</span>)<br><br>Glide.with(<span class="hljs-keyword">this</span>)<br>    .load(<span class="hljs-string">&quot;https://www.wanandroid.com/blogimgs/42da12d8-de56-4439-b40c-eab66c227a4b.png&quot;</span>)<br>    .apply(options)<br>    .into(i)<br></code></pre></td></tr></table></figure><p>当然，由于Glide有缓存，所以第一次加载之后，加载同一张图片基本看不到占位图的显示（直接从本地取出，不用去网络请求了）</p><img src="http://m.qpic.cn/psc?/V50iJoIj0J8AgR2w6xgp2P2iGW1NJP6L/ruAMsa53pVQWN7FLK88i5kaj55GPNb0FBxZPu2ag8zT9hWRErCAnvgqKHlOn2*5ym1TDBzC0fOAHYDukrw9m8nzmDWTX9V2Acm*WTfghYN4!/b&bo=QAIABQAAAAACZwQ!&rf=viewer_4" style="zoom: 25%;" /><h4 id="异常占位图"><a href="#异常占位图" class="headerlink" title="异常占位图"></a>异常占位图</h4><p>当网络断开连接了，或者404等异常情况了，如果本地没有缓存，就需要一张异常占位图，添加很简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> options: RequestOptions = RequestOptions()<br>    .placeholder(<span class="hljs-comment">/*占位图*/</span>)<br>    .error(<span class="hljs-comment">/*异常占位图*/</span>)<br><br>Glide.with(<span class="hljs-keyword">this</span>)<br>    .load(<span class="hljs-string">&quot;https://www.wanandroid.com/blogimgs/42da12d8-de56-4439-b40c-eab66c227a4b.png&quot;</span>)<br>    .apply(options)<br>    .into(i)<br></code></pre></td></tr></table></figure><img src="http://m.qpic.cn/psc?/V50iJoIj0J8AgR2w6xgp2P2iGW1NJP6L/ruAMsa53pVQWN7FLK88i5ucunBYMhDIbrL7EgYi907zT83*7izghZpDOeeQIlTSag2AKmIGrRH7P8Bb2H3EKGNzu0oZ.w.9FtA*2df.tqjQ!/b&bo=QAIABQAAAAACl*Q!&rf=viewer_4" style="zoom:25%;" /><h4 id="将图片加载为圆形"><a href="#将图片加载为圆形" class="headerlink" title="将图片加载为圆形"></a>将图片加载为圆形</h4><p>这个我们平常应该用得很多，事实上Glide是可以直接把图片加载为圆形的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Glide.with(<span class="hljs-keyword">this</span>)<br>    .load(<span class="hljs-string">&quot;https://www.wanandroid.com/blogimgs/42da12d8-de56-4439-b40c-eab66c227a4b.png&quot;</span>)<br>    .apply(RequestOptions.bitmapTransform(CircleCrop()))<br>    .into(i)<br></code></pre></td></tr></table></figure><img src="http://m.qpic.cn/psc?/V50iJoIj0J8AgR2w6xgp2P2iGW1NJP6L/ruAMsa53pVQWN7FLK88i5j8iKqk3oKOYSjLJ.qgjC*zIVf3eIe2DWXyzzUWTl.BfOSmw*izv99k2dbwAim97xkaNXZMdMESplO*h8WBdBSg!/b&bo=OARgCQAAAAABB3U!&rf=viewer_4" style="zoom:25%;" /><p>其实不止可以加载成圆形，还可以添加圆角：</p><img src="http://m.qpic.cn/psc?/V50iJoIj0J8AgR2w6xgp2P2iGW1NJP6L/ruAMsa53pVQWN7FLK88i5kFIfb3PHf4PmmI.YXbst8yYpz.cxshhL*Gn1qECyGsinZ6XAQERVvaSPeYo7qbk6wV6ienRGEZ2H0sUsG*WCAc!/b&bo=OARgCQAAAAABB3U!&rf=viewer_4" style="zoom:25%;" /><p>下面分享一些Glide高级用法的文章：</p><p><a href="https://blog.csdn.net/guolin_blog/article/details/78582548?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165911895216782248534976%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165911895216782248534976&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-5-78582548-null-null.article_score_rank_blog&utm_term=glide&spm=1018.2226.3001.4450">带你全面了解Glide 4的用法</a></p><p><a href="https://blog.csdn.net/yulyu/article/details/55215718">Glide图片压缩</a></p><p><a href="https://blog.csdn.net/qiantanlong/article/details/108535809">Glide加载OkHttp框架https协议的图片</a></p><h2 id="Glide创建流程"><a href="#Glide创建流程" class="headerlink" title="Glide创建流程"></a>Glide创建流程</h2><p>重新来看一看<strong>glide</strong>的基本用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Glide.with(activity).load(<span class="hljs-string">&quot;url&quot;</span>).into(imageView)<br></code></pre></td></tr></table></figure><p>非常的简洁，一行代码就能自动把图片加载进入图片控件里面，并且还能自动检测activity的生命周期，自动选择是否加载图片</p><blockquote><p>这样做的目的是，当有大量图片请求的时候，就会造成网络堵塞，不在展示的图片还在请求，这样很不合理，所以 Glide 需要监听生命周期来维护 Request，比如当glide将网络图片下载下来之后，检测到activity已经销毁，这时就不会加载图片</p></blockquote><h3 id="with方法调用过程"><a href="#with方法调用过程" class="headerlink" title="with方法调用过程"></a>with方法调用过程</h3><h4 id="Glide-with"><a href="#Glide-with" class="headerlink" title="Glide#with"></a>Glide#with</h4><p>直接进入<strong>with</strong>方法内部看一看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title function_">with</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> FragmentActivity activity)</span> &#123;<br>    <span class="hljs-keyword">return</span> getRetriever(activity).get(activity);<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里先调用了**getRetriever(activity)**方法，所以我们先进入这个方法：</p><h4 id="Glide-getRetriever"><a href="#Glide-getRetriever" class="headerlink" title="Glide#getRetriever"></a>Glide#getRetriever</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> RequestManagerRetriever <span class="hljs-title function_">getRetriever</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Context context)</span> &#123;<br>    <span class="hljs-comment">//省略代码 </span><br>    <span class="hljs-keyword">return</span> Glide.get(context).getRequestManagerRetriever();<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>return</strong>上面的省略的语句是一句判空，这里根据调用的先后顺序查看代码，<strong>return</strong>先调用的<strong>Glide#get</strong>方法，进入这个方法：</p><h4 id="Glide-get"><a href="#Glide-get" class="headerlink" title="Glide#get"></a>Glide#get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Glide <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context)</span> &#123;<br>  <span class="hljs-keyword">if</span> (glide == <span class="hljs-literal">null</span>) &#123;<br>      <br>    <span class="hljs-type">GeneratedAppGlideModule</span> <span class="hljs-variable">annotationGeneratedModule</span> <span class="hljs-operator">=</span><br>        getAnnotationGeneratedGlideModules(context.getApplicationContext());<br>      <br>    <span class="hljs-keyword">synchronized</span> (Glide.class) &#123;<br>        <br>      <span class="hljs-keyword">if</span> (glide == <span class="hljs-literal">null</span>) &#123;<br>        checkAndInitializeGlide(context, annotationGeneratedModule);<br>      &#125;<br>        <br>    &#125;<br>      <br>  &#125;<br><br>  <span class="hljs-keyword">return</span> glide;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用了一个双重检查模式的单例模式去创建了一个Glide单例，并且最后返回；注释<strong>1</strong>处通过反射找到<strong>GeneratedAppGlideModuleImpl</strong> 类，如果能找到，就说明自定义了<strong>GlideModule</strong>，那么就需要实现自己的自定义功能，这里属于Glide的高级用法，我们平常使用一般用不到，使用可以暂且忽略这个参数，看下面的调用流程：</p><h4 id="checkAndInitializeGlide方法调用流程"><a href="#checkAndInitializeGlide方法调用流程" class="headerlink" title="checkAndInitializeGlide方法调用流程"></a>checkAndInitializeGlide方法调用流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndInitializeGlide</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> GeneratedAppGlideModule generatedAppGlideModule)</span> &#123;<br><br>  isInitializing = <span class="hljs-literal">true</span>;<br>  initializeGlide(context, generatedAppGlideModule);<br>  isInitializing = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeGlide</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> GeneratedAppGlideModule generatedAppGlideModule)</span> &#123;<br>    initializeGlide(context, <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlideBuilder</span>()<span class="hljs-comment">/*注意这里直接new了一个BUilder*/</span>, generatedAppGlideModule);<br>  &#125;<br><br><span class="hljs-comment">// 1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeGlide</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-meta">@NonNull</span> Context context,</span><br><span class="hljs-params">      <span class="hljs-meta">@NonNull</span> GlideBuilder builder,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> GeneratedAppGlideModule annotationGeneratedModule)</span> &#123;<br>    <span class="hljs-type">Context</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> context.getApplicationContext();<br>    List&lt;com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule&gt; manifestModules = Collections.emptyList();<span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">if</span> (annotationGeneratedModule == <span class="hljs-literal">null</span> || annotationGeneratedModule.isManifestParsingEnabled()) &#123;<br>        <span class="hljs-comment">// 从AndroidManifest.xml 获取自定义的GlideModule（这是另外一种自定义GlideModule的方式）</span><br>      manifestModules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ManifestParser</span>(applicationContext).parse();<br>    &#125;<br><span class="hljs-comment">// 根据Impl的黑名单，剔除manifest中的GlideModule类</span><br>    <span class="hljs-keyword">if</span> (annotationGeneratedModule != <span class="hljs-literal">null</span><br>        &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123;<br>      Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses();<br>      Iterator&lt;com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule&gt; iterator = manifestModules.iterator();<br>      <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        com.bumptech.glide.<span class="hljs-keyword">module</span>.<span class="hljs-type">GlideModule</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> iterator.next();<br>        <span class="hljs-keyword">if</span> (!excludedModuleClasses.contains(current.getClass())) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br>      <br>        iterator.remove();<br>      &#125;<br>    &#125;<br><br><span class="hljs-comment">// 获取工厂，用于创建RequestManager</span><br>    RequestManagerRetriever.<span class="hljs-type">RequestManagerFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span><br>        annotationGeneratedModule != <span class="hljs-literal">null</span><br>            ? annotationGeneratedModule.getRequestManagerFactory()<br>            : <span class="hljs-literal">null</span>;<br>    <br>    builder.setRequestManagerFactory(factory);<br>    <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule <span class="hljs-keyword">module</span> : manifestModules) &#123;<br>      <span class="hljs-keyword">module</span>.applyOptions(applicationContext, builder);<br>    &#125;<br>    <span class="hljs-comment">//执行使用注解配置的GlideModule 接口中的方法</span><br>    <span class="hljs-keyword">if</span> (annotationGeneratedModule != <span class="hljs-literal">null</span>) &#123;<br>      annotationGeneratedModule.applyOptions(applicationContext, builder);<br>    &#125;<br>    <span class="hljs-type">Glide</span> <span class="hljs-variable">glide</span> <span class="hljs-operator">=</span> builder.build(applicationContext);<br>     <span class="hljs-comment">//下面registerComponents 方法的执行，需要传递Registry对象，而该对象是在创建Glide 的时候，在Glide的构造方法中被赋值，并设置一系列的参数</span><br>     <span class="hljs-comment">//执行用户在 manifest 中配置的 GlideModule 接口中的registerComponents 方法</span><br>    <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule <span class="hljs-keyword">module</span> : manifestModules) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">module</span>.registerComponents(applicationContext, glide, glide.registry);<br>      &#125; <span class="hljs-keyword">catch</span> (AbstractMethodError e) &#123;<br>       <span class="hljs-comment">//省略代码</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (annotationGeneratedModule != <span class="hljs-literal">null</span>) &#123;<br>      annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);<br>    &#125;<br>    applicationContext.registerComponentCallbacks(glide);<br>    Glide.glide = glide;<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>上面注释<strong>1</strong>下面的<strong>initializeGlide</strong>方法体是真的很长，但是参数<strong>annotationGeneratedModule</strong>我们并没有用到，所以他是<strong>null</strong>，注释<strong>2</strong>处的<strong>list</strong> <strong>manifestModules</strong>看名字就知道，这是储存在<strong>AndroidManifest.xml</strong>文件中配置的一些配置信息用的，所以也用不到，我们这里专注的是<strong>glide</strong>的创建流程，于是我们可以把这个方法简化成这样：</p><h4 id="Glide-initializeGlide简化"><a href="#Glide-initializeGlide简化" class="headerlink" title="Glide#initializeGlide简化"></a>Glide#initializeGlide简化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeGlide</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-meta">@NonNull</span> Context context,</span><br><span class="hljs-params">      <span class="hljs-meta">@NonNull</span> GlideBuilder builder,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> GeneratedAppGlideModule annotationGeneratedModule)</span> &#123;<br>    <span class="hljs-type">Context</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> context.getApplicationContext();<br>   <br><span class="hljs-comment">// 获取工厂，用于创建RequestManager，因为annotationGeneratedModule是null的，所以这里factory会初始化为null</span><br>    RequestManagerRetriever.<span class="hljs-type">RequestManagerFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span><br>        annotationGeneratedModule != <span class="hljs-literal">null</span><br>            ? annotationGeneratedModule.getRequestManagerFactory()<br>            : <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//这里将factory设置进了builder里面</span><br>    builder.setRequestManagerFactory(factory);<br>  <br>    <span class="hljs-type">Glide</span> <span class="hljs-variable">glide</span> <span class="hljs-operator">=</span> builder.build(applicationContext);<br>     <br>    Glide.glide = glide;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这段代码用建造者模式new出来了一个<strong>glide</strong>，我们继续进入<strong>build</strong>方法查看：</p><h4 id="GlideBuilder-build"><a href="#GlideBuilder-build" class="headerlink" title="GlideBuilder#build"></a>GlideBuilder#build</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java">Glide <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context)</span> &#123;<br>     <span class="hljs-comment">//源执行器允许在其线程上进行网络操作,也就是用于网络操作获取资源的</span><br>    <span class="hljs-keyword">if</span> (sourceExecutor == <span class="hljs-literal">null</span>) &#123;<br>      sourceExecutor = GlideExecutor.newSourceExecutor();<br>    &#125;<br><span class="hljs-comment">//磁盘缓存执行器,不允许对其线程进行网络操作</span><br>    <span class="hljs-keyword">if</span> (diskCacheExecutor == <span class="hljs-literal">null</span>) &#123;<br>      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();<br>    &#125;<br><span class="hljs-comment">//动画执行器,不允许在其线程上进行网络操作</span><br>    <span class="hljs-keyword">if</span> (animationExecutor == <span class="hljs-literal">null</span>) &#123;<br>      animationExecutor = GlideExecutor.newAnimationExecutor();<br>    &#125;<br><span class="hljs-comment">//根据当前机器参数计算需要设置的缓存大小</span><br>    <span class="hljs-keyword">if</span> (memorySizeCalculator == <span class="hljs-literal">null</span>) &#123;<br>      memorySizeCalculator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemorySizeCalculator</span>.Builder(context).build();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (connectivityMonitorFactory == <span class="hljs-literal">null</span>) &#123;<br>      connectivityMonitorFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConnectivityMonitorFactory</span>();<br>    &#125;<br>    <span class="hljs-comment">//创建 Bitmap 池，用于回收LruCache缓存的图片，把图片回收到bitmapPool中，这样下次再创建图片时，可复用该内存，避免连续创建回收内存，造成的内存抖动</span><br>    <span class="hljs-keyword">if</span> (bitmapPool == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> memorySizeCalculator.getBitmapPoolSize();<br>      <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>        bitmapPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LruBitmapPool</span>(size);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        bitmapPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitmapPoolAdapter</span>();<br>      &#125;<br>    &#125;<br><span class="hljs-comment">//一个固定大小的数组池，它使用 LRU 策略驱逐数组，以使池保持在最大字节大小以下。</span><br>    <span class="hljs-keyword">if</span> (arrayPool == <span class="hljs-literal">null</span>) &#123;<br>      arrayPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LruArrayPool</span>(memorySizeCalculator.getArrayPoolSizeInBytes());<br>    &#125;<br><span class="hljs-comment">//创建内存缓存</span><br>    <span class="hljs-keyword">if</span> (memoryCache == <span class="hljs-literal">null</span>) &#123;<br>      memoryCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LruResourceCache</span>(memorySizeCalculator.getMemoryCacheSize());<br>    &#125;<br><span class="hljs-comment">//创建磁盘缓存</span><br>    <span class="hljs-keyword">if</span> (diskCacheFactory == <span class="hljs-literal">null</span>) &#123;<br>      diskCacheFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalCacheDiskCacheFactory</span>(context);<br>    &#125;<br><span class="hljs-comment">//创建Engine，真正处理request的类，例如发起网络请求图片，从磁盘读取图片等。</span><br>    <span class="hljs-keyword">if</span> (engine == <span class="hljs-literal">null</span>) &#123;<br>      engine =<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Engine</span>(<br>              memoryCache,<br>              diskCacheFactory,<br>              diskCacheExecutor,<br>              sourceExecutor,<br>              GlideExecutor.newUnlimitedSourceExecutor(),<br>              animationExecutor,<br>              isActiveResourceRetentionAllowed);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (defaultRequestListeners == <span class="hljs-literal">null</span>) &#123;<br>      defaultRequestListeners = Collections.emptyList();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);<br>    &#125;<br>    <br> <span class="hljs-comment">//创建RequestManagerRetriever，记住这个参数，与生命周期的检测有关，构造方法里面的requestManagerFactory就是前面initializeGlide方法中初始化为null的factory变量</span><br>    <span class="hljs-type">RequestManagerRetriever</span> <span class="hljs-variable">requestManagerRetriever</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestManagerRetriever</span>(requestManagerFactory);<br><span class="hljs-comment">//创建Glide</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Glide</span>(<br>        context,<br>        engine,<br>        memoryCache,<br>        bitmapPool,<br>        arrayPool,<br>        requestManagerRetriever,<br>        connectivityMonitorFactory,<br>        logLevel,<br>        defaultRequestOptionsFactory,<br>        defaultTransitionOptions,<br>        defaultRequestListeners,<br>        isLoggingRequestOriginsEnabled,<br>        isImageDecoderEnabledForBitmaps);<br>  &#125;<br></code></pre></td></tr></table></figure><p>方法前面是对图片请求，解码，缓存的一些配置，我们这里先只关注创建流程和生命周期检测。到这里<strong>glide</strong>就创建完成了，并且直接return了回去，我们回到<strong>getRetriever</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> RequestManagerRetriever <span class="hljs-title function_">getRetriever</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Context context)</span> &#123;<br>    <br>    <span class="hljs-keyword">return</span> Glide.get(context).getRequestManagerRetriever();<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里用<strong>Glide.get(context)<strong>得到了一个</strong>glide</strong>实例之后，调用了<strong>getRequestManagerRetriever()<strong>得到了上面</strong>build</strong>方法里面创建的<strong>requestManagerRetriever</strong>，回到<strong>with</strong>方法：</p><h4 id="Glide-with-1"><a href="#Glide-with-1" class="headerlink" title="Glide#with"></a>Glide#with</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title function_">with</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> FragmentActivity activity)</span> &#123;<br>    <span class="hljs-keyword">return</span> getRetriever(activity).get(activity);<br>  &#125;<br></code></pre></td></tr></table></figure><p>经过了前面的分析，我们知道<strong>getRetriever(activity)<strong>得到的是一个</strong>RequestManagerRetriever的</strong>对象，并且这个对象就是在<strong>build</strong>里面创建的<strong>requestManagerRetriever</strong>，所以这里调用<strong>get(activity)<strong>也就是调用的</strong>requestManagerRetriever</strong>的<strong>get</strong>方法，直接点进去看看：</p><h4 id="RequestManagerRetriever-get"><a href="#RequestManagerRetriever-get" class="headerlink" title="RequestManagerRetriever#get"></a>RequestManagerRetriever#get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> FragmentActivity activity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;<span class="hljs-comment">//判断线程</span><br>      <span class="hljs-keyword">return</span> get(activity.getApplicationContext());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      assertNotDestroyed(activity);<br>      frameWaiter.registerSelf(activity);<br>      <span class="hljs-type">FragmentManager</span> <span class="hljs-variable">fm</span> <span class="hljs-operator">=</span> activity.getSupportFragmentManager();<span class="hljs-comment">//这里获取了一个FragmentManager</span><br>      <span class="hljs-keyword">return</span> supportFragmentGet(activity, fm, <span class="hljs-comment">/*parentHint=*/</span> <span class="hljs-literal">null</span>, isActivityVisible(activity));<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里判断了一下执行这段代码所在的线程，如果是后台线程，就调用<strong>get</strong>的重载方法，并把<strong>activity.getApplicationContext()<strong>传了进去，这里不主要分析，进行这一步之后，glide的生命周期和整个应用绑定了，我们主要看下面的</strong>supportFragmentGet</strong>方法：</p><h4 id="RequestManagerRetriever-supportFragmentGet"><a href="#RequestManagerRetriever-supportFragmentGet" class="headerlink" title="RequestManagerRetriever#supportFragmentGet"></a>RequestManagerRetriever#supportFragmentGet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> RequestManager <span class="hljs-title function_">supportFragmentGet</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-meta">@NonNull</span> Context context,</span><br><span class="hljs-params">      <span class="hljs-meta">@NonNull</span> FragmentManager fm,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> Fragment parentHint,</span><br><span class="hljs-params">      <span class="hljs-type">boolean</span> isParentVisible)</span> &#123;<br>    <br>    <span class="hljs-type">SupportRequestManagerFragment</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getSupportRequestManagerFragment(fm, parentHint);<span class="hljs-comment">// 1</span><br>    <br>    <span class="hljs-type">RequestManager</span> <span class="hljs-variable">requestManager</span> <span class="hljs-operator">=</span> current.getRequestManager();<span class="hljs-comment">//2</span><br>    <br>    <span class="hljs-keyword">if</span> (requestManager == <span class="hljs-literal">null</span>) &#123;<br>     <br>      <span class="hljs-type">Glide</span> <span class="hljs-variable">glide</span> <span class="hljs-operator">=</span> Glide.get(context);<br>      requestManager =<br>          factory.build(<br>              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);<br>      <br>      <span class="hljs-keyword">if</span> (isParentVisible) &#123;<br>        requestManager.onStart();<br>      &#125;<br>      current.setRequestManager(requestManager);<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> requestManager;<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>SupportRequestManagerFragment</strong>继承自<strong>Fragment</strong>，说白了，他就是一个fragment，但是没有任何视图界面，可以理解为一个隐形的fragment，用来检测生命周期，注释<strong>1</strong>处通过<strong>getSupportRequestManagerFragment</strong>得到了一个<strong>SupportRequestManagerFragment</strong>，点进去看看：</p><h4 id="RequestManagerRetriever-getSupportRequestManagerFragment"><a href="#RequestManagerRetriever-getSupportRequestManagerFragment" class="headerlink" title="RequestManagerRetriever#getSupportRequestManagerFragment"></a>RequestManagerRetriever#getSupportRequestManagerFragment</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> Map&lt;FragmentManager, SupportRequestManagerFragment&gt; pendingSupportRequestManagerFragments =<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<span class="hljs-comment">//这是RequestManagerRetriever的成员变量，用来存储SupportRequestManagerFragment</span><br><br><span class="hljs-keyword">private</span> SupportRequestManagerFragment <span class="hljs-title function_">getSupportRequestManagerFragment</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> FragmentManager fm, <span class="hljs-meta">@Nullable</span> Fragment parentHint)</span> &#123;<br>    <br>    <span class="hljs-type">SupportRequestManagerFragment</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> pendingSupportRequestManagerFragments.get(fm);<br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//这两步检测有没有可以复用的SupportRequestManagerFragment</span><br>        <br>      current = (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);<br>      <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>) &#123;<br>          <br>        current = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SupportRequestManagerFragment</span>();<br>        current.setParentFragmentHint(parentHint);<br>        pendingSupportRequestManagerFragments.put(fm, current);<br>        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();<br>        handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();<br>          <br>      &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> current;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里就做了这么几件事情：得到一个<strong>SupportRequestManagerFragment</strong>，如果<strong>pendingSupportRequestManagerFragments</strong>里面有，则直接拿出来返回回去，如果没有，再用<strong>FragmentManager</strong>的<strong>findFragmentByTag</strong>方法找，如果也没找到，就new一个出来，绑定到<strong>FragmentManager</strong>，也就是绑定到相应的<strong>activity</strong>，最后再加入map里面存起来，下一次用。这样，这个<strong>Fragment</strong>就可以检测<strong>activity</strong>的生命周期。回到<strong>supportFragmentGet</strong>方法，注释<strong>2</strong>处从fragment拿<strong>RequestManager</strong>，进入<strong>getRequestManager</strong>看一看：</p><h4 id="SupportRequestManagerFragment-getRequestManager"><a href="#SupportRequestManagerFragment-getRequestManager" class="headerlink" title="SupportRequestManagerFragment#getRequestManager"></a>SupportRequestManagerFragment#getRequestManager</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title function_">getRequestManager</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> requestManager;<br> &#125;<br></code></pre></td></tr></table></figure><p>这里是直接new的一个<strong>SupportRequestManagerFragment</strong>，所以这里的<strong>requestManager</strong>是null，所以下面直接用<strong>factory.build</strong>方法创建了一个，这里用到了工厂模式，这里的<strong>factory</strong>对象是在构造方法里面初始化的：</p><h4 id="RequestManagerRetriever的构造方法"><a href="#RequestManagerRetriever的构造方法" class="headerlink" title="RequestManagerRetriever的构造方法"></a>RequestManagerRetriever的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">RequestManagerRetriever</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> RequestManagerFactory factory, GlideExperiments experiments)</span> &#123;<br>    <span class="hljs-built_in">this</span>.factory = factory != <span class="hljs-literal">null</span> ? factory : DEFAULT_FACTORY;<br>    handler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper(), <span class="hljs-built_in">this</span> <span class="hljs-comment">/* Callback */</span>);<br><br>    frameWaiter = buildFrameWaiter(experiments);<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里的<strong>factory</strong>是在前面<strong>build</strong>方法创建<strong>Glide</strong>实例的时候传进来的，为null，所以这里直接初始化为了<strong>DEFAULT_FACTORY</strong>，它是这样的一个匿名对象</p><h4 id="SupperRequestManagerFragment-DEFAULT-FACTORY"><a href="#SupperRequestManagerFragment-DEFAULT-FACTORY" class="headerlink" title="SupperRequestManagerFragment#DEFAULT_FACTORY"></a>SupperRequestManagerFragment#DEFAULT_FACTORY</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RequestManagerFactory</span> &#123;<br>    <span class="hljs-meta">@NonNull</span><br>    RequestManager <span class="hljs-title function_">build</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@NonNull</span> Glide glide,</span><br><span class="hljs-params">        <span class="hljs-meta">@NonNull</span> Lifecycle lifecycle,</span><br><span class="hljs-params">        <span class="hljs-meta">@NonNull</span> RequestManagerTreeNode requestManagerTreeNode,</span><br><span class="hljs-params">        <span class="hljs-meta">@NonNull</span> Context context)</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">RequestManagerFactory</span> <span class="hljs-variable">DEFAULT_FACTORY</span> <span class="hljs-operator">=</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestManagerFactory</span>() &#123;<br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> RequestManager <span class="hljs-title function_">build</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> Glide glide,</span><br><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> Lifecycle lifecycle,</span><br><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> RequestManagerTreeNode requestManagerTreeNode,</span><br><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> Context context)</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestManager</span>(glide, lifecycle, requestManagerTreeNode, context);<br>        &#125;<br>      &#125;;<br></code></pre></td></tr></table></figure><p><strong>build</strong>方法直接创建了一个<strong>RequestManager</strong>返回了回去，然后在<strong>supportFragmentGet</strong>方法中，把它给了<strong>SupportRequestManagerFragment</strong>，注意这里传入<strong>RequestManager</strong>构造函数的第二个参数<strong>lifecycle</strong>，查看<strong>supportFragmentGet</strong>方法，发现这个<strong>lifecycle</strong>参数是<strong>current.getGlideLifecycle()<strong>，也就是保存在</strong>Fragment</strong>里面的，这个<strong>lifecycle</strong>是在构造<strong>fragment</strong>时new的，看一看它的构造方法：</p><h4 id="RequestManagerRetriever"><a href="#RequestManagerRetriever" class="headerlink" title="RequestManagerRetriever"></a>RequestManagerRetriever</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">SupportRequestManagerFragment</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityFragmentLifecycle</span>());<br>  &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SupportRequestManagerFragment</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ActivityFragmentLifecycle lifecycle)</span> &#123;<br>    <span class="hljs-built_in">this</span>.lifecycle = lifecycle;<br>  &#125;<br><br><span class="hljs-comment">//下面是current.getGlideLifecycle()方法</span><br>ActivityFragmentLifecycle <span class="hljs-title function_">getGlideLifecycle</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> lifecycle;<br>  &#125;<br></code></pre></td></tr></table></figure><p>进入<strong>RequestManager</strong>看看它拿到<strong>lifecycle</strong>之后做了啥，进入<strong>RequestManager</strong>的构造方法：</p><h4 id="RequestManager的构造方法"><a href="#RequestManager的构造方法" class="headerlink" title="RequestManager的构造方法"></a>RequestManager的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">RequestManager(<br>      Glide glide,<br>      Lifecycle lifecycle,<br>      RequestManagerTreeNode treeNode,<br>      RequestTracker requestTracker,<br>      ConnectivityMonitorFactory factory,<br>      Context context) &#123;<br>    <span class="hljs-built_in">this</span>.glide = glide;<br>    <span class="hljs-built_in">this</span>.lifecycle = lifecycle;<br>    <span class="hljs-built_in">this</span>.treeNode = treeNode;<br>    <span class="hljs-built_in">this</span>.requestTracker = requestTracker;<br>    <span class="hljs-built_in">this</span>.context = context;<br><br>    connectivityMonitor =<br>        factory.build(<br>            context.getApplicationContext(),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestManagerConnectivityListener</span>(requestTracker));<br><br>    <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;<br>      Util.postOnUiThread(addSelfToLifecycle);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      lifecycle.addListener(<span class="hljs-built_in">this</span>);<span class="hljs-comment">//1</span><br>    &#125;<br>    lifecycle.addListener(connectivityMonitor);<br><br>    defaultRequestListeners =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;(glide.getGlideContext().getDefaultRequestListeners());<br>    setRequestOptions(glide.getGlideContext().getDefaultRequestOptions());<br><br>    glide.registerRequestManager(<span class="hljs-built_in">this</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>注意注释1处，将自己添加进了观察列表，当生命周期发生变化就会通知<strong>RequestManager</strong>；下面分析一下监听流程：</p><h4 id="生命周期监听流程简述"><a href="#生命周期监听流程简述" class="headerlink" title="生命周期监听流程简述"></a>生命周期监听流程简述</h4><p>首先<strong>activity</strong>的生命周期发生变化（比如变为了<strong>start</strong>），被添加进去的隐藏<strong>Fragment</strong>监听到<strong>Fragment</strong>的<strong>onStart</strong>调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.onStart();<br>    lifecycle.onStart();<br>  &#125;<br></code></pre></td></tr></table></figure><p>调用了<strong>lifecycle</strong>的<strong>onStart</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>    isStarted = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;<br>      lifecycleListener.onStart();<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>调用了观察者（也就是<strong>RequestManager</strong>）的<strong>onStart</strong>方法，这里用了一个观察者模式，到这里，生命周期监听就完了：</p><p><img src="https://upload-images.jianshu.io/upload_images/6337201-904ac2cfbe2f65d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp"></p><p>回到<strong>get</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> FragmentActivity activity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;<br>      <span class="hljs-keyword">return</span> get(activity.getApplicationContext());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      assertNotDestroyed(activity);<br>      frameWaiter.registerSelf(activity);<br>      <span class="hljs-type">FragmentManager</span> <span class="hljs-variable">fm</span> <span class="hljs-operator">=</span> activity.getSupportFragmentManager();<br>      <span class="hljs-keyword">return</span> supportFragmentGet(activity, fm, <span class="hljs-comment">/*parentHint=*/</span> <span class="hljs-literal">null</span>, isActivityVisible(activity));<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>到最后，这里把<strong>RequestManager</strong>的实例放回给了<strong>with</strong>方法，<strong>with</strong>返回给调用处。</p><p>这里在网上找到了一张with的流程图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/064307491e714285b6a77ae2f82baf63~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p><blockquote><p>总结起来就是创建了一个RequestManager对象返回给with的调用处，在这途中顺便给调用处的activity添加了一个隐藏的fragment来监听它的生命周期</p></blockquote><h3 id="RequestManager-load方法"><a href="#RequestManager-load方法" class="headerlink" title="RequestManager#load方法"></a>RequestManager#load方法</h3><p>上面我们分析到：with方法返回了一个<strong>RequestManager</strong>给调用处。所以紧接着链式调用的下一个 <strong>load</strong> 方法直接进入<strong>RequestManager</strong>类里查看，先回到调用处看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Glide.with(<span class="hljs-built_in">this</span>).load(<span class="hljs-string">&quot;url&quot;</span>).into(imageView)<br></code></pre></td></tr></table></figure><p>这里 <strong>load</strong> 接受的是一个字符串形式的图片的<code>url</code>，其实它还可以接受其他形式的<code>url</code>，先看看它的重载方法：</p><h4 id="RequestManager-load方法的重载方法"><a href="#RequestManager-load方法的重载方法" class="headerlink" title="RequestManager#load方法的重载方法"></a>RequestManager#load方法的重载方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bitmap bitmap)</span> &#123;<br>  <span class="hljs-keyword">return</span> asDrawable().load(bitmap);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Drawable drawable)</span> &#123;<br>  <span class="hljs-keyword">return</span> asDrawable().load(drawable);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String string)</span> &#123;<br>  <span class="hljs-keyword">return</span> asDrawable().load(string);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Uri uri)</span> &#123;<br>  <span class="hljs-keyword">return</span> asDrawable().load(uri);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> File file)</span> &#123;<br>  <span class="hljs-keyword">return</span> asDrawable().load(file);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@RawRes</span> <span class="hljs-meta">@DrawableRes</span> <span class="hljs-meta">@Nullable</span> Integer resourceId)</span> &#123;<br>  <span class="hljs-keyword">return</span> asDrawable().load(resourceId);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> URL url)</span> &#123;<br>  <span class="hljs-keyword">return</span> asDrawable().load(url);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> <span class="hljs-type">byte</span>[] model)</span> &#123;<br>  <span class="hljs-keyword">return</span> asDrawable().load(model);<br>&#125;<br><br><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object model)</span> &#123;<br>  <span class="hljs-keyword">return</span> asDrawable().load(model);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="RequestManager-load方法（String参数）"><a href="#RequestManager-load方法（String参数）" class="headerlink" title="RequestManager#load方法（String参数）"></a>RequestManager#load方法（String参数）</h4><p>好家伙，确实有点多，不过我们不分析其他的，主要看接受字符串形式的<code>url</code>的<strong>load</strong>方法，因为我们一般也只会用到这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String string)</span> &#123;<br>  <span class="hljs-keyword">return</span> asDrawable().load(string);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里首先调用了<strong>asDrawable</strong>方法，点进去看看：</p><h4 id="RequestManager-asDrawable"><a href="#RequestManager-asDrawable" class="headerlink" title="RequestManager#asDrawable"></a>RequestManager#asDrawable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title function_">asDrawable</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> as(Drawable.class);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; <span class="hljs-title function_">as</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-meta">@NonNull</span> Class&lt;ResourceType&gt; resourceClass)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestBuilder</span>&lt;&gt;(glide, <span class="hljs-built_in">this</span>, resourceClass, context);<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>扯了半天，这里new了一个<strong>RequestBuilder</strong>回去，注意它的泛型是<strong>Drawable</strong>的；所以这里简化下来看就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String string)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestBuilder</span>&lt;Drawable&gt;(glide, <span class="hljs-built_in">this</span>, resourceClass, context).load(string);<br>&#125;<br></code></pre></td></tr></table></figure><p>那就直接去看 <strong>RequestBuilder#load</strong> 方法：</p><h4 id="RequestBuilder-load"><a href="#RequestBuilder-load" class="headerlink" title="RequestBuilder#load"></a>RequestBuilder#load</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String string)</span> &#123;<br>  <span class="hljs-keyword">return</span> loadGeneric(string);<br>&#125;<br><br><span class="hljs-keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title function_">loadGeneric</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object model)</span> &#123;<br>    <span class="hljs-keyword">if</span> (isAutoCloneEnabled()) &#123;<br>      <span class="hljs-keyword">return</span> clone().loadGeneric(model);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.model = model;<br>    isModelSet = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> selfOrThrowIfLocked();<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里把<strong>isModelSet</strong>赋值成<strong>true</strong>，并且把<code>url</code>保存了下来，看看<strong>selfOrThrowIfLocked</strong>方法：</p><h4 id="RequestBuilder-selfOrThrowIfLocked"><a href="#RequestBuilder-selfOrThrowIfLocked" class="headerlink" title="RequestBuilder#selfOrThrowIfLocked"></a>RequestBuilder#selfOrThrowIfLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> T <span class="hljs-title function_">selfOrThrowIfLocked</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (isLocked) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;You cannot modify locked T, consider clone()&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> self();<br>&#125;<br><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">self</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (T) <span class="hljs-built_in">this</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>就是把自己返回了回去，所以<strong>load</strong>方法基本是屁事没干，就设置了一个<strong>isModelSet</strong>，保存了url。</p><h3 id="RequestBuilder-into"><a href="#RequestBuilder-into" class="headerlink" title="RequestBuilder#into"></a>RequestBuilder#into</h3><p>还是先回到调用的那一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Glide.with(<span class="hljs-built_in">this</span>).load(<span class="hljs-string">&quot;url&quot;</span>).into(imageView)<br></code></pre></td></tr></table></figure><p>上面说到：这里<strong>load</strong>方法返回的是一个带有<strong>Drawable泛型的RequestBuilder</strong> 直接进入到<strong>into</strong>方法看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="hljs-title function_">into</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ImageView view)</span> &#123;<br>  Util.assertMainThread();<br>  Preconditions.checkNotNull(view);<br><br>  BaseRequestOptions&lt;?&gt; requestOptions = <span class="hljs-built_in">this</span>;<br>    <br>    <span class="hljs-comment">//下面的if语句是根据ImageView的缩放比例来克隆对象，暂且不管，快进一波到下面调用重载方法</span><br>    <br>  <span class="hljs-keyword">if</span> (!requestOptions.isTransformationSet()<br>      &amp;&amp; requestOptions.isTransformationAllowed()<br>      &amp;&amp; view.getScaleType() != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (view.getScaleType()) &#123;<br>      <span class="hljs-keyword">case</span> CENTER_CROP:<br>        requestOptions = requestOptions.clone().optionalCenterCrop();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> CENTER_INSIDE:<br>        requestOptions = requestOptions.clone().optionalCenterInside();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> FIT_CENTER:<br>      <span class="hljs-keyword">case</span> FIT_START:<br>      <span class="hljs-keyword">case</span> FIT_END:<br>        requestOptions = requestOptions.clone().optionalFitCenter();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> FIT_XY:<br>        requestOptions = requestOptions.clone().optionalCenterInside();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> CENTER:<br>      <span class="hljs-keyword">case</span> MATRIX:<br>      <span class="hljs-keyword">default</span>:<br>    &#125;<br>  &#125;<br><br>    <span class="hljs-comment">//调用重载方法</span><br>  <span class="hljs-keyword">return</span> into(<br>      glideContext.buildImageViewTarget(view, transcodeClass),<br>      <span class="hljs-comment">/*targetListener=*/</span> <span class="hljs-literal">null</span>,<br>      requestOptions,<br>      Executors.mainThreadExecutor());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们继续看下面调用<strong>into</strong>方法，传参里面又调用了**glideContext.buildImageViewTarget(view, transcodeClass)**，我们先进这里面去看看：</p><h4 id="GlideContext-buildImageViewTarget"><a href="#GlideContext-buildImageViewTarget" class="headerlink" title="GlideContext#buildImageViewTarget"></a>GlideContext#buildImageViewTarget</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;X&gt; ViewTarget&lt;ImageView, X&gt; <span class="hljs-title function_">buildImageViewTarget</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> ImageView imageView, <span class="hljs-meta">@NonNull</span> Class&lt;X&gt; transcodeClass)</span> &#123;<br>  <span class="hljs-keyword">return</span> imageViewTargetFactory.buildTarget(imageView, transcodeClass);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageViewTargetFactory</span> &#123;<br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>  <span class="hljs-keyword">public</span> &lt;Z&gt; ViewTarget&lt;ImageView, Z&gt; <span class="hljs-title function_">buildTarget</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-meta">@NonNull</span> ImageView view, <span class="hljs-meta">@NonNull</span> Class&lt;Z&gt; clazz)</span> &#123;<br>    <span class="hljs-keyword">if</span> (Bitmap.class.equals(clazz)) &#123;<br>      <span class="hljs-keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitmapImageViewTarget</span>(view);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;<br>      <span class="hljs-keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="hljs-keyword">new</span> <span class="hljs-title class_">DrawableImageViewTarget</span>(view);<br>    &#125; <br>      <span class="hljs-comment">//省略代码</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<strong>ImageViewTargetFactory#buildTarget</strong>方法中根据传入<strong>clazz</strong>的类型返回不同的<strong>target</strong> 这里前面说过，传进来的参数<strong>clazz</strong>是<strong>Drawable</strong>的<strong>class</strong> ，所以返回<strong>DrawableImageViewTarget</strong> ，现在回到上面的<strong>into</strong> 参数**Executors.mainThreadExecutor())**点进去看看：</p><h4 id="Executors-mainThreadExecutor"><a href="#Executors-mainThreadExecutor" class="headerlink" title="Executors#mainThreadExecutor"></a>Executors#mainThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Posts executions to the main thread. */</span><span class="hljs-comment">/*将执行发布到主线程*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Executor <span class="hljs-title function_">mainThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> MAIN_THREAD_EXECUTOR;<br>&#125;<br></code></pre></td></tr></table></figure><p>那下一步进入重载的<strong>into</strong>里面：</p><h4 id="RequestBuilder-into的重载方法"><a href="#RequestBuilder-into的重载方法" class="headerlink" title="RequestBuilder#into的重载方法"></a>RequestBuilder#into的重载方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="hljs-title function_">into</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> Y target,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="hljs-params">    BaseRequestOptions&lt;?&gt; options,</span><br><span class="hljs-params">    Executor callbackExecutor)</span> &#123;<br>  Preconditions.checkNotNull(target);<br>  <span class="hljs-keyword">if</span> (!isModelSet) &#123;<span class="hljs-comment">//这里前面load说了，isModelSet设置为了true</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;You must call #load() before calling #into()&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//这里创建一个请求，选择是去缓存里拿还是网络请求</span><br>  <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> buildRequest(target, targetListener, options, callbackExecutor);<br><br>  <span class="hljs-type">Request</span> <span class="hljs-variable">previous</span> <span class="hljs-operator">=</span> target.getRequest();<br>    <br>     <span class="hljs-comment">// 这里会判断需不需要重新开始任务</span><br>      <span class="hljs-comment">// 如果当前request和target上之前的request previous相等</span><br>      <span class="hljs-comment">// 且设置了忽略内存缓存或previous还没有完成</span><br>      <span class="hljs-comment">// 那么会进入if分支</span><br>  <span class="hljs-keyword">if</span> (request.isEquivalentTo(previous)&amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;<br>      <br>      <span class="hljs-comment">// 如果正在运行，就不管它；如果已经失败了，就重新开始</span><br>    <span class="hljs-keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;<br>      previous.begin();<br>    &#125;<br>      <br>    <span class="hljs-keyword">return</span> target;<br>  &#125;<br><span class="hljs-comment">// 如果不能复用previous</span><br>  <span class="hljs-comment">// 清除target上之前的Request</span><br>  requestManager.clear(target);<br>    <span class="hljs-comment">//将request设置进入了 target，这里的target前面有提到过，是DrawableImageViewTarget类型的</span><br>  target.setRequest(request);<br>  requestManager.track(target, request);<br><br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法里面尝试获取以往保存的<strong>Request</strong>来进行获取数据，现在先不管缓存，所以直接用新的请求，既然用新的请求，那就要看看前面<strong>buildRequest</strong>做了什么：</p><h4 id="RequestBuilder-buildRequest"><a href="#RequestBuilder-buildRequest" class="headerlink" title="RequestBuilder#buildRequest"></a>RequestBuilder#buildRequest</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Request <span class="hljs-title function_">buildRequest</span><span class="hljs-params">(</span><br><span class="hljs-params">    Target&lt;TranscodeType&gt; target,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="hljs-params">    BaseRequestOptions&lt;?&gt; requestOptions,</span><br><span class="hljs-params">    Executor callbackExecutor)</span> &#123;<br>    <span class="hljs-comment">//这里直接返回</span><br>  <span class="hljs-keyword">return</span> buildRequestRecursive(<br>      <span class="hljs-comment">/*requestLock=*/</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(),<br>      target,<br>      targetListener,<br>      <span class="hljs-comment">/*parentCoordinator=*/</span> <span class="hljs-literal">null</span>,<br>      transitionOptions,<br>      requestOptions.getPriority(),<br>      requestOptions.getOverrideWidth(),<br>      requestOptions.getOverrideHeight(),<br>      requestOptions,<br>      callbackExecutor);<br>&#125;<br><br><br><br>  <span class="hljs-keyword">private</span> Request <span class="hljs-title function_">buildRequestRecursive</span><span class="hljs-params">(</span><br><span class="hljs-params">      Object requestLock,</span><br><span class="hljs-params">      Target&lt;TranscodeType&gt; target,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> RequestCoordinator parentCoordinator,</span><br><span class="hljs-params">      TransitionOptions&lt;?, ? <span class="hljs-built_in">super</span> TranscodeType&gt; transitionOptions,</span><br><span class="hljs-params">      Priority priority,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> overrideWidth,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> overrideHeight,</span><br><span class="hljs-params">      BaseRequestOptions&lt;?&gt; requestOptions,</span><br><span class="hljs-params">      Executor callbackExecutor)</span> &#123;<br><br>    <span class="hljs-comment">// Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.</span><br>    <span class="hljs-type">ErrorRequestCoordinator</span> <span class="hljs-variable">errorRequestCoordinator</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-comment">//判断是否设置了，发生错误时，显示的图片</span><br>    <span class="hljs-keyword">if</span> (errorBuilder != <span class="hljs-literal">null</span>) &#123;<br>      errorRequestCoordinator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ErrorRequestCoordinator</span>(requestLock, parentCoordinator);<br>      parentCoordinator = errorRequestCoordinator;<br>    &#125;<br><br>     <span class="hljs-comment">//这段代码下面的代码都是在做一些出错时的处理，所以我们可以战且不管，进入这个方法看</span><br>    <span class="hljs-type">Request</span> <span class="hljs-variable">mainRequest</span> <span class="hljs-operator">=</span><br>        buildThumbnailRequestRecursive(<br>            requestLock,<br>            target,<br>            targetListener,<br>            parentCoordinator,<br>            transitionOptions,<br>            priority,<br>            overrideWidth,<br>            overrideHeight,<br>            requestOptions,<br>            callbackExecutor);<br>      <span class="hljs-comment">//这里直接把mainRequest返回回去</span><br>      <span class="hljs-keyword">if</span> (errorRequestCoordinator == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> mainRequest;<br>    &#125;<br><br>   <span class="hljs-comment">//省略出错时的处理代码</span><br>  &#125;<br><br><br><br><br>  <span class="hljs-keyword">private</span> Request <span class="hljs-title function_">buildThumbnailRequestRecursive</span><span class="hljs-params">(</span><br><span class="hljs-params">      Object requestLock,</span><br><span class="hljs-params">      Target&lt;TranscodeType&gt; target,</span><br><span class="hljs-params">      RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> RequestCoordinator parentCoordinator,</span><br><span class="hljs-params">      TransitionOptions&lt;?, ? <span class="hljs-built_in">super</span> TranscodeType&gt; transitionOptions,</span><br><span class="hljs-params">      Priority priority,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> overrideWidth,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> overrideHeight,</span><br><span class="hljs-params">      BaseRequestOptions&lt;?&gt; requestOptions,</span><br><span class="hljs-params">      Executor callbackExecutor)</span> &#123;<br>    <span class="hljs-keyword">if</span> (thumbnailBuilder != <span class="hljs-literal">null</span>) &#123;<br><br><br>      TransitionOptions&lt;?, ? <span class="hljs-built_in">super</span> TranscodeType&gt; thumbTransitionOptions =<br>          thumbnailBuilder.transitionOptions;<br><br>     <br>      <span class="hljs-keyword">if</span> (thumbnailBuilder.isDefaultTransitionOptionsSet) &#123;<br>        thumbTransitionOptions = transitionOptions;<br>      &#125;<br><br>      <span class="hljs-type">Priority</span> <span class="hljs-variable">thumbPriority</span> <span class="hljs-operator">=</span><br>          thumbnailBuilder.isPrioritySet()<br>              ? thumbnailBuilder.getPriority()<br>              : getThumbnailPriority(priority);<br><br>      <span class="hljs-type">int</span> <span class="hljs-variable">thumbOverrideWidth</span> <span class="hljs-operator">=</span> thumbnailBuilder.getOverrideWidth();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">thumbOverrideHeight</span> <span class="hljs-operator">=</span> thumbnailBuilder.getOverrideHeight();<br>      <span class="hljs-keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)<br>          &amp;&amp; !thumbnailBuilder.isValidOverride()) &#123;<br>        thumbOverrideWidth = requestOptions.getOverrideWidth();<br>        thumbOverrideHeight = requestOptions.getOverrideHeight();<br>      &#125;<br><br>      <span class="hljs-type">ThumbnailRequestCoordinator</span> <span class="hljs-variable">coordinator</span> <span class="hljs-operator">=</span><br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThumbnailRequestCoordinator</span>(requestLock, parentCoordinator);<br>      <span class="hljs-type">Request</span> <span class="hljs-variable">fullRequest</span> <span class="hljs-operator">=</span><br>          obtainRequest(<br>              requestLock,<br>              target,<br>              targetListener,<br>              requestOptions,<br>              coordinator,<br>              transitionOptions,<br>              priority,<br>              overrideWidth,<br>              overrideHeight,<br>              callbackExecutor);<br>      isThumbnailBuilt = <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// Recursively generate thumbnail requests.</span><br>      <span class="hljs-type">Request</span> <span class="hljs-variable">thumbRequest</span> <span class="hljs-operator">=</span><br>          thumbnailBuilder.buildRequestRecursive(<br>              requestLock,<br>              target,<br>              targetListener,<br>              coordinator,<br>              thumbTransitionOptions,<br>              thumbPriority,<br>              thumbOverrideWidth,<br>              thumbOverrideHeight,<br>              thumbnailBuilder,<br>              callbackExecutor);<br>      isThumbnailBuilt = <span class="hljs-literal">false</span>;<br>      coordinator.setRequests(fullRequest, thumbRequest);<br>      <span class="hljs-keyword">return</span> coordinator;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thumbSizeMultiplier != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.</span><br>      <span class="hljs-type">ThumbnailRequestCoordinator</span> <span class="hljs-variable">coordinator</span> <span class="hljs-operator">=</span><br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThumbnailRequestCoordinator</span>(requestLock, parentCoordinator);<br>      <span class="hljs-type">Request</span> <span class="hljs-variable">fullRequest</span> <span class="hljs-operator">=</span><br>          obtainRequest(<br>              requestLock,<br>              target,<br>              targetListener,<br>              requestOptions,<br>              coordinator,<br>              transitionOptions,<br>              priority,<br>              overrideWidth,<br>              overrideHeight,<br>              callbackExecutor);<br>      BaseRequestOptions&lt;?&gt; thumbnailOptions =<br>          requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);<br><br>      <span class="hljs-type">Request</span> <span class="hljs-variable">thumbnailRequest</span> <span class="hljs-operator">=</span><br>          obtainRequest(<br>              requestLock,<br>              target,<br>              targetListener,<br>              thumbnailOptions,<br>              coordinator,<br>              transitionOptions,<br>              getThumbnailPriority(priority),<br>              overrideWidth,<br>              overrideHeight,<br>              callbackExecutor);<br><br>      coordinator.setRequests(fullRequest, thumbnailRequest);<br>      <span class="hljs-keyword">return</span> coordinator;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Base case: no thumbnail.</span><br>      <span class="hljs-keyword">return</span> obtainRequest(<br>          requestLock,<br>          target,<br>          targetListener,<br>          requestOptions,<br>          parentCoordinator,<br>          transitionOptions,<br>          priority,<br>          overrideWidth,<br>          overrideHeight,<br>          callbackExecutor);<br>    <br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>buildThumbnailRequestRecursive</strong>方法用于创建原图和缩略图，我们只关注原图的请求，就可以简化成这样：</p><h4 id="RequestBuilder-buildThumbnailRequestRecursive的省略"><a href="#RequestBuilder-buildThumbnailRequestRecursive的省略" class="headerlink" title="RequestBuilder#buildThumbnailRequestRecursive的省略"></a>RequestBuilder#buildThumbnailRequestRecursive的省略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Request <span class="hljs-title function_">buildThumbnailRequestRecursive</span><span class="hljs-params">(</span><br><span class="hljs-params">     Object requestLock,</span><br><span class="hljs-params">     Target&lt;TranscodeType&gt; target,</span><br><span class="hljs-params">     RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="hljs-params">     <span class="hljs-meta">@Nullable</span> RequestCoordinator parentCoordinator,</span><br><span class="hljs-params">     TransitionOptions&lt;?, ? <span class="hljs-built_in">super</span> TranscodeType&gt; transitionOptions,</span><br><span class="hljs-params">     Priority priority,</span><br><span class="hljs-params">     <span class="hljs-type">int</span> overrideWidth,</span><br><span class="hljs-params">     <span class="hljs-type">int</span> overrideHeight,</span><br><span class="hljs-params">     BaseRequestOptions&lt;?&gt; requestOptions,</span><br><span class="hljs-params">     Executor callbackExecutor)</span> &#123;<br>   <span class="hljs-keyword">if</span> (thumbnailBuilder != <span class="hljs-literal">null</span>) &#123;<br>     <span class="hljs-comment">//省略代码</span><br>     <br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thumbSizeMultiplier != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//省略代码</span><br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-comment">// Base case: no thumbnail.</span><br>     <span class="hljs-keyword">return</span> obtainRequest(<br>         requestLock,<br>         target,<br>         targetListener,<br>         requestOptions,<br>         parentCoordinator,<br>         transitionOptions,<br>         priority,<br>         overrideWidth,<br>         overrideHeight,<br>         callbackExecutor);<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>两个if里面时有关缩略图的设置，我们不需要关注，直接进入<strong>obtainRequest</strong>：</p><h4 id="RequestBuilder-obtainRequest"><a href="#RequestBuilder-obtainRequest" class="headerlink" title="RequestBuilder#obtainRequest"></a>RequestBuilder#obtainRequest</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Request <span class="hljs-title function_">obtainRequest</span><span class="hljs-params">(</span><br><span class="hljs-params">    Object requestLock,</span><br><span class="hljs-params">    Target&lt;TranscodeType&gt; target,</span><br><span class="hljs-params">    RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="hljs-params">    BaseRequestOptions&lt;?&gt; requestOptions,</span><br><span class="hljs-params">    RequestCoordinator requestCoordinator,</span><br><span class="hljs-params">    TransitionOptions&lt;?, ? <span class="hljs-built_in">super</span> TranscodeType&gt; transitionOptions,</span><br><span class="hljs-params">    Priority priority,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> overrideWidth,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> overrideHeight,</span><br><span class="hljs-params">    Executor callbackExecutor)</span> &#123;<br>  <span class="hljs-keyword">return</span> SingleRequest.obtain(<br>      context,<br>      glideContext,<br>      requestLock,<br>      model,<br>      transcodeClass,<br>      requestOptions,<br>      overrideWidth,<br>      overrideHeight,<br>      priority,<br>      target,<br>      targetListener,<br>      requestListeners,<br>      requestCoordinator,<br>      glideContext.getEngine(),<br>      transitionOptions.getTransitionFactory(),<br>      callbackExecutor);<br>&#125;<br><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;R&gt; SingleRequest&lt;R&gt; <span class="hljs-title function_">obtain</span><span class="hljs-params">(</span><br><span class="hljs-params">      Context context,</span><br><span class="hljs-params">      GlideContext glideContext,</span><br><span class="hljs-params">      Object requestLock,</span><br><span class="hljs-params">      Object model,</span><br><span class="hljs-params">      Class&lt;R&gt; transcodeClass,</span><br><span class="hljs-params">      BaseRequestOptions&lt;?&gt; requestOptions,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> overrideWidth,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> overrideHeight,</span><br><span class="hljs-params">      Priority priority,</span><br><span class="hljs-params">      Target&lt;R&gt; target,</span><br><span class="hljs-params">      RequestListener&lt;R&gt; targetListener,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> List&lt;RequestListener&lt;R&gt;&gt; requestListeners,</span><br><span class="hljs-params">      RequestCoordinator requestCoordinator,</span><br><span class="hljs-params">      Engine engine,</span><br><span class="hljs-params">      TransitionFactory&lt;? <span class="hljs-built_in">super</span> R&gt; animationFactory,</span><br><span class="hljs-params">      Executor callbackExecutor)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleRequest</span>&lt;&gt;(<br>        context,<br>        glideContext,<br>        requestLock,<br>        model,<br>        transcodeClass,<br>        requestOptions,<br>        overrideWidth,<br>        overrideHeight,<br>        priority,<br>        target,<br>        targetListener,<br>        requestListeners,<br>        requestCoordinator,<br>        engine,<br>        animationFactory,<br>        callbackExecutor);<br>  &#125;<br></code></pre></td></tr></table></figure><p>扯了半天，这里直接new了一个<strong>SingleRequest</strong>对象回去，回到重载的<strong>into</strong>：</p><h4 id="RequestBuilder-into-1"><a href="#RequestBuilder-into-1" class="headerlink" title="RequestBuilder#into"></a>RequestBuilder#into</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="hljs-title function_">into</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> Y target,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="hljs-params">    BaseRequestOptions&lt;?&gt; options,</span><br><span class="hljs-params">    Executor callbackExecutor)</span> &#123;<br>  Preconditions.checkNotNull(target);<br> <br>    <br>  <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> buildRequest(target, targetListener, options, callbackExecutor);<br><br>  <span class="hljs-type">Request</span> <span class="hljs-variable">previous</span> <span class="hljs-operator">=</span> target.getRequest();<br>  <span class="hljs-keyword">if</span> (request.isEquivalentTo(previous)<br>      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;<br><br>    <span class="hljs-keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;<br><br>      previous.begin();<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>  &#125;<br><br>  requestManager.clear(target);<br>  target.setRequest(request);<br>  requestManager.track(target, request);<br><br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面调用了**requestManager.track(target, request);**，进入看看：</p><h4 id="RequestManager-track"><a href="#RequestManager-track" class="headerlink" title="RequestManager#track"></a>RequestManager#track</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">track</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Target&lt;?&gt; target, <span class="hljs-meta">@NonNull</span> Request request)</span> &#123;<br>  targetTracker.track(target);<br>  requestTracker.runRequest(request);<br>&#125;<br></code></pre></td></tr></table></figure><p>先看<strong>track</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">track</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Target&lt;?&gt; target)</span> &#123;<br>  targets.add(target);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>targets</strong>是一个<strong>set</strong>集合，将传进来的<strong>target</strong>放进去</p><p>再看看**runRequest(request)**：</p><h4 id="RequestTracker-runRequest"><a href="#RequestTracker-runRequest" class="headerlink" title="RequestTracker#runRequest"></a>RequestTracker#runRequest</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runRequest</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Request request)</span> &#123;<br>  requests.add(request);<br><span class="hljs-comment">//填充目标（ImageView）所在的activity Fragment stop后，isPaused就是true,这里默认是false，所以会先执行request.begin()</span><br>  <span class="hljs-keyword">if</span> (!isPaused) &#123;<br>    request.begin();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    request.clear();<br>    <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;<br>      Log.v(TAG, <span class="hljs-string">&quot;Paused, delaying request&quot;</span>);<br>    &#125;<br>    pendingRequests.add(request);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<strong>request</strong>前面说了，是<strong>SingleRequest</strong> 所以进入查看：</p><h4 id="SingleRequest-begin"><a href="#SingleRequest-begin" class="headerlink" title="SingleRequest#begin"></a>SingleRequest#begin</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">begin</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span> (requestLock) &#123;<br>    assertNotCallingCallbacks();<br>    stateVerifier.throwIfRecycled();<br>    startTime = LogTime.getLogTime();<br>    <br>      <span class="hljs-comment">//......省略</span><br><br>    <span class="hljs-keyword">if</span> (status == Status.COMPLETE) &#123;<br>      onResourceReady(resource, DataSource.MEMORY_CACHE, <span class="hljs-comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="hljs-literal">false</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br> <br>    status = Status.WAITING_FOR_SIZE;<br>    <span class="hljs-keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;<br>      onSizeReady(overrideWidth, overrideHeight);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      target.getSize(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)<br>        &amp;&amp; canNotifyStatusChanged()) &#123;<br>      target.onLoadStarted(getPlaceholderDrawable());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;<br>      logV(<span class="hljs-string">&quot;finished run method in &quot;</span> + LogTime.getElapsedMillis(startTime));<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<strong>status</strong>在构造方法里面初始化为了<strong>Status.PENDING</strong> ，在上面又赋值为<strong>Status.WAITING_FOR_SIZE</strong>，这里的<strong>overrideWidth, overrideHeight</strong>都被为-1，所以第一次加载到这里会直接进入**target.getSize(this)**，进入看看：</p><h4 id="Target-getSize"><a href="#Target-getSize" class="headerlink" title="Target#getSize"></a>Target#getSize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Target</span>&lt;R&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LifecycleListener</span> &#123;<br><span class="hljs-comment">//...... </span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> SizeReadyCallback cb)</span>;<br><span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<strong>target</strong>本来是<strong>DrawableImageViewTarget</strong>，但是在里面并没有找到这个方法，最后在<strong>ViewTarget</strong>找到：</p><h4 id="ViewTarget-getSize"><a href="#ViewTarget-getSize" class="headerlink" title="ViewTarget#getSize"></a>ViewTarget#getSize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> SizeReadyCallback cb)</span> &#123;<br>  sizeDeterminer.getSize(cb);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> SizeReadyCallback cb)</span> &#123;<span class="hljs-comment">//注意这里的cb，是SingleRequest</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">currentWidth</span> <span class="hljs-operator">=</span> getTargetWidth();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">currentHeight</span> <span class="hljs-operator">=</span> getTargetHeight();<br>    <br><span class="hljs-comment">//第一次执行到这里是获取不到宽高的，会继续往下执行</span><br>  <span class="hljs-keyword">if</span> (isViewStateAndSizeValid(currentWidth, currentHeight)) &#123;<br>    cb.onSizeReady(currentWidth, currentHeight);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//将cb添加到cbs集合内</span><br>  <span class="hljs-keyword">if</span> (!cbs.contains(cb)) &#123;<br>    cbs.add(cb);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (layoutListener == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">ViewTreeObserver</span> <span class="hljs-variable">observer</span> <span class="hljs-operator">=</span> view.getViewTreeObserver();<span class="hljs-comment">//这里的view是ImageView，构建DrawableImageViewTarget时传入的</span><br>    layoutListener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SizeDeterminerLayoutListener</span>(<span class="hljs-built_in">this</span>);<br>    observer.addOnPreDrawListener(layoutListener);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里直接看到最后，<strong>layoutListener</strong>没有初始化，所以这里为null，这里构建了一个<strong>ViewTreeObserver</strong>，将view的绘制情况订阅，一旦view绘制完成，就会回调<strong>SizeDeterminerLayoutListener</strong>的**onPreDraw()**方法，我们进入一看：</p><h4 id="SizeDeterminerLayoutListener-onPreDraw"><a href="#SizeDeterminerLayoutListener-onPreDraw" class="headerlink" title="SizeDeterminerLayoutListener#onPreDraw"></a>SizeDeterminerLayoutListener#onPreDraw</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SizeDeterminerLayoutListener</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ViewTreeObserver</span>.OnPreDrawListener &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WeakReference&lt;SizeDeterminer&gt; sizeDeterminerRef;<br><br>  SizeDeterminerLayoutListener(<span class="hljs-meta">@NonNull</span> SizeDeterminer sizeDeterminer) &#123;<br>    sizeDeterminerRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(sizeDeterminer);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onPreDraw</span><span class="hljs-params">()</span> &#123;<br>   <br>    <span class="hljs-type">SizeDeterminer</span> <span class="hljs-variable">sizeDeterminer</span> <span class="hljs-operator">=</span> sizeDeterminerRef.get();<br>    <span class="hljs-keyword">if</span> (sizeDeterminer != <span class="hljs-literal">null</span>) &#123;<br>      sizeDeterminer.checkCurrentDimens();<br>    &#125;<br>      <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入**checkCurrentDimens()**看看：</p><h4 id="ViewTarget-checkCurrentDimens"><a href="#ViewTarget-checkCurrentDimens" class="headerlink" title="ViewTarget#checkCurrentDimens"></a>ViewTarget#checkCurrentDimens</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">checkCurrentDimens</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (cbs.isEmpty()) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-type">int</span> <span class="hljs-variable">currentWidth</span> <span class="hljs-operator">=</span> getTargetWidth();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">currentHeight</span> <span class="hljs-operator">=</span> getTargetHeight();<br>    <br>  <span class="hljs-keyword">if</span> (!isViewStateAndSizeValid(currentWidth, currentHeight)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  notifyCbs(currentWidth, currentHeight);<br>  clearCallbacksAndListener();<br>&#125;<br></code></pre></td></tr></table></figure><p>前面说过，传进来的<strong>cb</strong>会被添加进<strong>cbs</strong>集合，这里ImageView已经绘制完成了，所以可以获取到其宽高，进入**notifyCbs(currentWidth, currentHeight)**查看：</p><h4 id="ViewTarget-notifyCbs"><a href="#ViewTarget-notifyCbs" class="headerlink" title="ViewTarget#notifyCbs"></a>ViewTarget#notifyCbs</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyCbs</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;<br>  <br>  <span class="hljs-keyword">for</span> (SizeReadyCallback cb : <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(cbs)) &#123;<br>    cb.onSizeReady(width, height);<br>  &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>直接回调了<code>cb</code>的<strong>onSizeReady(width, height)<strong>方法，前面提到过，这里的<code>cb</code>是</strong>SingleRequest</strong>，我们回去查看它的<strong>onSizeReady</strong>方法：</p><h4 id="SingleRequest-onSizeReady"><a href="#SingleRequest-onSizeReady" class="headerlink" title="SingleRequest#onSizeReady"></a>SingleRequest#onSizeReady</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSizeReady</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;<br>  stateVerifier.throwIfRecycled();<br>  <span class="hljs-keyword">synchronized</span> (requestLock) &#123;<br>   <br>    <span class="hljs-keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;<span class="hljs-comment">//status在前面的begin方法中就被赋值为了Status.WAITING_FOR_SIZE;所以这里不会执行</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    status = Status.RUNNING;<br><br>    <span class="hljs-type">float</span> <span class="hljs-variable">sizeMultiplier</span> <span class="hljs-operator">=</span> requestOptions.getSizeMultiplier();<br>    <span class="hljs-built_in">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);<br>    <span class="hljs-built_in">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);<br><br>   <br>      <span class="hljs-comment">//这里的engine在前面的with方法调用流程中的GlideBuilder#build创建的</span><br>    loadStatus =<br>        engine.load(<br>            glideContext,<br>            model,<br>            requestOptions.getSignature(),<br>            <span class="hljs-built_in">this</span>.width,<br>            <span class="hljs-built_in">this</span>.height,<br>            requestOptions.getResourceClass(),<br>            transcodeClass,<br>            priority,<br>            requestOptions.getDiskCacheStrategy(),<br>            requestOptions.getTransformations(),<br>            requestOptions.isTransformationRequired(),<br>            requestOptions.isScaleOnlyOrNoTransform(),<br>            requestOptions.getOptions(),<br>            requestOptions.isMemoryCacheable(),<br>            requestOptions.getUseUnlimitedSourceGeneratorsPool(),<br>            requestOptions.getUseAnimationPool(),<br>            requestOptions.getOnlyRetrieveFromCache(),<br>            <span class="hljs-built_in">this</span>,<br>            callbackExecutor);<br><br>   <br>    <span class="hljs-keyword">if</span> (status != Status.RUNNING) &#123;<br>      loadStatus = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;<br>      logV(<span class="hljs-string">&quot;finished onSizeReady in &quot;</span> + LogTime.getElapsedMillis(startTime));<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入<strong>engine.load</strong>：</p><h4 id="Engine-load"><a href="#Engine-load" class="headerlink" title="Engine#load"></a>Engine#load</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;R&gt; LoadStatus <span class="hljs-title function_">load</span><span class="hljs-params">(</span><br><span class="hljs-params">    GlideContext glideContext,</span><br><span class="hljs-params">    Object model,</span><br><span class="hljs-params">    Key signature,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> width,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">    Class&lt;?&gt; resourceClass,</span><br><span class="hljs-params">    Class&lt;R&gt; transcodeClass,</span><br><span class="hljs-params">    Priority priority,</span><br><span class="hljs-params">    DiskCacheStrategy diskCacheStrategy,</span><br><span class="hljs-params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> isTransformationRequired,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> isScaleOnlyOrNoTransform,</span><br><span class="hljs-params">    Options options,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> isMemoryCacheable,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> useUnlimitedSourceExecutorPool,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> useAnimationPool,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> onlyRetrieveFromCache,</span><br><span class="hljs-params">    ResourceCallback cb,</span><br><span class="hljs-params">    Executor callbackExecutor)</span> &#123;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="hljs-number">0</span>;<br><br>  <span class="hljs-type">EngineKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span><br>      keyFactory.buildKey(<br>          model,<br>          signature,<br>          width,<br>          height,<br>          transformations,<br>          resourceClass,<br>          transcodeClass,<br>          options);<span class="hljs-comment">//这里构建了一个 EngineKey</span><br><br>  EngineResource&lt;?&gt; memoryResource;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);<span class="hljs-comment">//这里试图从内存里面拿出资源，我们目前探究的是第一次请求，所以这里肯定是拿不到数据的，那下面的代码肯定会执行</span><br><br>    <span class="hljs-keyword">if</span> (memoryResource == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> waitForExistingOrStartNewJob(<br>          glideContext,<br>          model,<br>          signature,<br>          width,<br>          height,<br>          resourceClass,<br>          transcodeClass,<br>          priority,<br>          diskCacheStrategy,<br>          transformations,<br>          isTransformationRequired,<br>          isScaleOnlyOrNoTransform,<br>          options,<br>          isMemoryCacheable,<br>          useUnlimitedSourceExecutorPool,<br>          useAnimationPool,<br>          onlyRetrieveFromCache,<br>          cb,<br>          callbackExecutor,<br>          key,<br>          startTime);<br>    &#125;<br>  &#125;<br><br> <br>  cb.onResourceReady(<br>      memoryResource, DataSource.MEMORY_CACHE, <span class="hljs-comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;R&gt; LoadStatus <span class="hljs-title function_">waitForExistingOrStartNewJob</span><span class="hljs-params">(</span><br><span class="hljs-params">    GlideContext glideContext,</span><br><span class="hljs-params">    Object model,</span><br><span class="hljs-params">    Key signature,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> width,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">    Class&lt;?&gt; resourceClass,</span><br><span class="hljs-params">    Class&lt;R&gt; transcodeClass,</span><br><span class="hljs-params">    Priority priority,</span><br><span class="hljs-params">    DiskCacheStrategy diskCacheStrategy,</span><br><span class="hljs-params">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> isTransformationRequired,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> isScaleOnlyOrNoTransform,</span><br><span class="hljs-params">    Options options,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> isMemoryCacheable,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> useUnlimitedSourceExecutorPool,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> useAnimationPool,</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> onlyRetrieveFromCache,</span><br><span class="hljs-params">    ResourceCallback cb,</span><br><span class="hljs-params">    Executor callbackExecutor,</span><br><span class="hljs-params">    EngineKey key,</span><br><span class="hljs-params">    <span class="hljs-type">long</span> startTime)</span> &#123;<br><br>    <span class="hljs-comment">//下面准备从磁盘里面拿到资源，当然是拿不到的</span><br>  EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);<br>  <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">null</span>) &#123;<br>    current.addCallback(cb, callbackExecutor);<br>    <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;<br>      logWithTimeAndKey(<span class="hljs-string">&quot;Added to existing load&quot;</span>, startTime, key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadStatus</span>(cb, current);<br>  &#125;<br><br>    <span class="hljs-comment">//下面两个对象的创建主要是为了解码获取到的图片资源</span><br>  EngineJob&lt;R&gt; engineJob =<br>      engineJobFactory.build(<br>          key,<br>          isMemoryCacheable,<br>          useUnlimitedSourceExecutorPool,<br>          useAnimationPool,<br>          onlyRetrieveFromCache);<br><br>  DecodeJob&lt;R&gt; decodeJob =<br>      decodeJobFactory.build(<br>          glideContext,<br>          model,<br>          key,<br>          signature,<br>          width,<br>          height,<br>          resourceClass,<br>          transcodeClass,<br>          priority,<br>          diskCacheStrategy,<br>          transformations,<br>          isTransformationRequired,<br>          isScaleOnlyOrNoTransform,<br>          onlyRetrieveFromCache,<br>          options,<br>          engineJob);<br><br>    <br>  jobs.put(key, engineJob);<br>    <br><span class="hljs-comment">// 注册ResourceCallback接口，就是在成功获取图片后，需要显示到ImageView 上的回调，这个接口回调到SingleRequest中</span><br>  engineJob.addCallback(cb, callbackExecutor);<br>  engineJob.start(decodeJob);<br><br>  <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;<br>    logWithTimeAndKey(<span class="hljs-string">&quot;Started new load&quot;</span>, startTime, key);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadStatus</span>(cb, engineJob);<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，请求会在<strong>start</strong>里面调用了：</p><h4 id="EngineJob-start"><a href="#EngineJob-start" class="headerlink" title="EngineJob#start"></a>EngineJob#start</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(DecodeJob&lt;R&gt; decodeJob)</span> &#123;<br>  <span class="hljs-built_in">this</span>.decodeJob = decodeJob;<br>  <span class="hljs-type">GlideExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span><br>      decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();<br>  executor.execute(decodeJob);<br>&#125;<br></code></pre></td></tr></table></figure><p>进入<strong>willDecodeFromCache</strong>方法：</p><h4 id="EngineJob-willDecodeFromCache"><a href="#EngineJob-willDecodeFromCache" class="headerlink" title="EngineJob#willDecodeFromCache"></a>EngineJob#willDecodeFromCache</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Returns true if this job will attempt to decode a resource from the disk cache, and false if it</span><br><span class="hljs-comment">   * will always decode from source.</span><br><span class="hljs-comment">   */</span><br><span class="hljs-comment">//如果此作业将尝试从磁盘缓存解码资源，则返回 true，如果始终从源解码，则返回 false。</span><br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">willDecodeFromCache</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">Stage</span> <span class="hljs-variable">firstStage</span> <span class="hljs-operator">=</span> getNextStage(Stage.INITIALIZE);<br>  <span class="hljs-keyword">return</span> firstStage == Stage.RESOURCE_CACHE || firstStage == Stage.DATA_CACHE;<br>&#125;<br><br><br><br>  <span class="hljs-keyword">private</span> Stage <span class="hljs-title function_">getNextStage</span><span class="hljs-params">(Stage current)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (current) &#123;<br>      <span class="hljs-keyword">case</span> INITIALIZE:<br>            <span class="hljs-comment">//当前是初始阶段，则看磁盘缓存策略，是否可以在磁盘中获取资源缓存（也就是解析后的缓存）</span><br>        <span class="hljs-keyword">return</span> diskCacheStrategy.decodeCachedResource()<br>            ? Stage.RESOURCE_CACHE<br>            : getNextStage(Stage.RESOURCE_CACHE);<br>      <span class="hljs-keyword">case</span> RESOURCE_CACHE:<br>            <span class="hljs-comment">//当前是资源缓存，看下一步能不能从磁盘缓存中获取源数据缓存</span><br>        <span class="hljs-keyword">return</span> diskCacheStrategy.decodeCachedData()<br>            ? Stage.DATA_CACHE<br>            : getNextStage(Stage.DATA_CACHE);<br>      <span class="hljs-keyword">case</span> DATA_CACHE:<br>        <span class="hljs-comment">// Skip loading from source if the user opted to only retrieve the resource from cache.</span><br>        <span class="hljs-comment">//如果用户选择仅从缓存中检索资源，则跳过从源加载。 </span><br>        <span class="hljs-keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;<br>      <span class="hljs-keyword">case</span> SOURCE:<br>      <span class="hljs-keyword">case</span> FINISHED:<br>        <span class="hljs-keyword">return</span> Stage.FINISHED;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unrecognized stage: &quot;</span> + current);<br>    &#125;<br>  &#125;<br><br><br></code></pre></td></tr></table></figure><p>这里的<strong>diskCacheStrategy</strong>是通过**BaseRequestOptions#getDiskCacheStrategy()**方法得到：</p><h4 id="BaseRequestOptions-getDiskCacheStrategy"><a href="#BaseRequestOptions-getDiskCacheStrategy" class="headerlink" title="BaseRequestOptions#getDiskCacheStrategy()"></a>BaseRequestOptions#getDiskCacheStrategy()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseRequestOptions</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseRequestOptions</span>&lt;T&gt;&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br><br><span class="hljs-comment">//......</span><br>  <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">private</span> <span class="hljs-type">DiskCacheStrategy</span> <span class="hljs-variable">diskCacheStrategy</span> <span class="hljs-operator">=</span> DiskCacheStrategy.AUTOMATIC;<br><span class="hljs-comment">//......</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> DiskCacheStrategy <span class="hljs-title function_">getDiskCacheStrategy</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> diskCacheStrategy;<br>&#125;<br> <span class="hljs-comment">//......   </span><br>&#125;<br><br><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DiskCacheStrategy</span> <span class="hljs-variable">AUTOMATIC</span> <span class="hljs-operator">=</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiskCacheStrategy</span>() &#123;<br>        <span class="hljs-comment">//省略代码</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">decodeCachedResource</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><span class="hljs-comment">//省略代码</span><br>      &#125;;<br><br></code></pre></td></tr></table></figure><p>所以<strong>decodeCachedResource()<strong>始终会返回</strong>true</strong>，所以返回<strong>Stage.RESOURCE_CACHE</strong>，所以<strong>willDecodeFromCache()<strong>返回</strong>true</strong>，<strong>getActiveSourceExecutor()<strong>会根据情况返回合适的</strong>Executor</strong>，接下来执行**executor.execute(decodeJob)**：</p><h4 id="GlideExecutor-execute"><a href="#GlideExecutor-execute" class="headerlink" title="GlideExecutor#execute"></a>GlideExecutor#execute</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable command)</span> &#123;<br>  delegate.execute(command);<br>&#125;<br></code></pre></td></tr></table></figure><p>从这里看出来<strong>DecodeJob</strong>是实现了<strong>Runnable</strong>的，那我们直接去看它的<strong>run</strong>方法：</p><h4 id="DecodeJob-run"><a href="#DecodeJob-run" class="headerlink" title="DecodeJob#run"></a>DecodeJob#run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>  <br>  DataFetcher&lt;?&gt; localFetcher = currentFetcher;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (isCancelled) &#123;<br>      notifyFailed();<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    runWrapped();<br>  &#125; <span class="hljs-keyword">catch</span> (CallbackException e) &#123;<br>   <br>    <span class="hljs-keyword">throw</span> e;<br>  &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br><br>    <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;<br>      Log.d(<br>          TAG,<br>          <span class="hljs-string">&quot;DecodeJob threw unexpectedly&quot;</span> + <span class="hljs-string">&quot;, isCancelled: &quot;</span> + isCancelled + <span class="hljs-string">&quot;, stage: &quot;</span> + stage,<br>          t);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (stage != Stage.ENCODE) &#123;<br>      throwables.add(t);<br>      notifyFailed();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isCancelled) &#123;<br>      <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> t;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <br>    <span class="hljs-keyword">if</span> (localFetcher != <span class="hljs-literal">null</span>) &#123;<br>      localFetcher.cleanup();<br>    &#125;<br>    GlideTrace.endSection();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里一堆<strong>try catch</strong>，<strong>isCancelled</strong>看名字就知道是false的，的确也是false的，所以直接运行**runWrapped()**：</p><h4 id="DecodeJob-runWrapped"><a href="#DecodeJob-runWrapped" class="headerlink" title="DecodeJob#runWrapped"></a>DecodeJob#runWrapped</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWrapped</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">switch</span> (runReason) &#123;<br>    <span class="hljs-keyword">case</span> INITIALIZE:<br>      stage = getNextStage(Stage.INITIALIZE);<br>      currentGenerator = getNextGenerator();<br>      runGenerators();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> SWITCH_TO_SOURCE_SERVICE:<br>      runGenerators();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DECODE_DATA:<br>      decodeFromRetrievedData();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Unrecognized run reason: &quot;</span> + runReason);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>runReason</strong>在构造函数中初始化为了<strong>RunReason.INITIALIZE</strong>，这里<strong>getNextStage</strong>跟上面的情况一样，返回<strong>Stage.RESOURCE_CACHE</strong>，看看<strong>getNextGenerator</strong>：</p><h4 id="DecodeJob-getNextGenerator"><a href="#DecodeJob-getNextGenerator" class="headerlink" title="DecodeJob#getNextGenerator"></a>DecodeJob#getNextGenerator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> DataFetcherGenerator <span class="hljs-title function_">getNextGenerator</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">switch</span> (stage) &#123;<br>    <span class="hljs-keyword">case</span> RESOURCE_CACHE:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceCacheGenerator</span>(decodeHelper, <span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">case</span> DATA_CACHE:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataCacheGenerator</span>(decodeHelper, <span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">case</span> SOURCE:<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SourceGenerator</span>(decodeHelper, <span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">case</span> FINISHED:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Unrecognized stage: &quot;</span> + stage);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里直接new了一个**ResourceCacheGenerator()<strong>返回了回去，那就回去看</strong>runGenerators()**方法：</p><h4 id="DecodeJob-runGenerators"><a href="#DecodeJob-runGenerators" class="headerlink" title="DecodeJob#runGenerators"></a>DecodeJob#runGenerators</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runGenerators</span><span class="hljs-params">()</span> &#123;<br>  currentThread = Thread.currentThread();<br>  startFetchTime = LogTime.getLogTime();<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">while</span> (!isCancelled<br>      &amp;&amp; currentGenerator != <span class="hljs-literal">null</span><br>      &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;<br>    stage = getNextStage(stage);<br>    currentGenerator = getNextGenerator();<br><br>    <span class="hljs-keyword">if</span> (stage == Stage.SOURCE) &#123;<br>      reschedule();<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;<br>    notifyFailed();<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里能不能进入循环就看最后一个条件<strong>currentGenerator.startNext()<strong>，上面说了，这里的</strong>currentGenerator</strong>是<strong>ResourceCacheGenerator</strong>，进入它的**startNext()**查看：</p><h4 id="ResourceCacheGenerator-startNext"><a href="#ResourceCacheGenerator-startNext" class="headerlink" title="ResourceCacheGenerator#startNext"></a>ResourceCacheGenerator#startNext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startNext</span><span class="hljs-params">()</span> &#123;<br>  GlideTrace.beginSection(<span class="hljs-string">&quot;ResourceCacheGenerator.startNext&quot;</span>);<br>  <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//这里会返回一个key列表</span><br>    List&lt;Key&gt; sourceIds = helper.getCacheKeys();<br>    <span class="hljs-keyword">if</span> (sourceIds.isEmpty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>      <span class="hljs-comment">//这里获得了三个可以到达的registeredResourceClasses GifDrawable、Bitmap、BitmapDrawable（ps：断点打出来的）</span><br>    List&lt;Class&lt;?&gt;&gt; resourceClasses = helper.getRegisteredResourceClasses();<br>    <span class="hljs-keyword">if</span> (resourceClasses.isEmpty()) &#123;<br>      <span class="hljs-keyword">if</span> (File.class.equals(helper.getTranscodeClass())) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>          <span class="hljs-string">&quot;Failed to find any load path from &quot;</span><br>              + helper.getModelClass()<br>              + <span class="hljs-string">&quot; to &quot;</span><br>              + helper.getTranscodeClass());<br>    &#125;<br>      <span class="hljs-comment">//这里modelLoaders第一次运行到这里肯定为null</span><br>    <span class="hljs-keyword">while</span> (modelLoaders == <span class="hljs-literal">null</span> || !hasNextModelLoader()) &#123;<br>      resourceClassIndex++;<br>      <span class="hljs-keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) &#123;<br>        sourceIdIndex++;<br>        <span class="hljs-keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        resourceClassIndex = <span class="hljs-number">0</span>;<br>      &#125;<br><br>      <span class="hljs-type">Key</span> <span class="hljs-variable">sourceId</span> <span class="hljs-operator">=</span> sourceIds.get(sourceIdIndex);<br>      Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);<br>      Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass);<br>      <br>      currentKey =<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceCacheKey</span>( <br>              helper.getArrayPool(),<br>              sourceId,<br>              helper.getSignature(),<br>              helper.getWidth(),<br>              helper.getHeight(),<br>              transformation,<br>              resourceClass,<br>              helper.getOptions());<br>      cacheFile = helper.getDiskCache().get(currentKey);<br>      <span class="hljs-keyword">if</span> (cacheFile != <span class="hljs-literal">null</span>) &#123;<br>        sourceKey = sourceId;<br>        modelLoaders = helper.getModelLoaders(cacheFile);<br>        modelLoaderIndex = <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;<br><br>    loadData = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;<br>      ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);<br>      loadData =<br>          modelLoader.buildLoadData(<br>              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());<br>      <span class="hljs-keyword">if</span> (loadData != <span class="hljs-literal">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;<br>        started = <span class="hljs-literal">true</span>;<br>        loadData.fetcher.loadData(helper.getPriority(), <span class="hljs-built_in">this</span>);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> started;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    GlideTrace.endSection();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>while的第一个参数已经通过，所以后面的参数不用判断，这里会循环三次，最后从：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>返回false；不要忘记我们的初心，回到调用它的方法**runGenerators()**：</p><h4 id="DecodeJob-runGenerators-1"><a href="#DecodeJob-runGenerators-1" class="headerlink" title="DecodeJob#runGenerators"></a>DecodeJob#runGenerators</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runGenerators</span><span class="hljs-params">()</span> &#123;<br>  currentThread = Thread.currentThread();<br>  startFetchTime = LogTime.getLogTime();<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">while</span> (!isCancelled<br>      &amp;&amp; currentGenerator != <span class="hljs-literal">null</span><br>      &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;<br>    stage = getNextStage(stage);<br>    currentGenerator = getNextGenerator();<br><br>    <span class="hljs-keyword">if</span> (stage == Stage.SOURCE) &#123;<br>      reschedule();<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;<br>    notifyFailed();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那就会继续循环，进入<strong>getNextStage</strong>拿到下一个状态：<strong>Stage.DATA_CACHE</strong>，再通过<strong>getNextGenerator()<strong>拿到下一个</strong>currentGenerator</strong>：**DataCacheGenerator(decodeHelper, this)<strong>，那进入它的</strong>startNext()**看看：</p><h4 id="DataCacheGenerator-startNext"><a href="#DataCacheGenerator-startNext" class="headerlink" title="DataCacheGenerator#startNext"></a>DataCacheGenerator#startNext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startNext</span><span class="hljs-params">()</span> &#123;<br>  GlideTrace.beginSection(<span class="hljs-string">&quot;DataCacheGenerator.startNext&quot;</span>);<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">while</span> (modelLoaders == <span class="hljs-literal">null</span> || !hasNextModelLoader()) &#123;<br>      sourceIdIndex++;<br>      <span class="hljs-keyword">if</span> (sourceIdIndex &gt;= cacheKeys.size()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br><br>      <span class="hljs-type">Key</span> <span class="hljs-variable">sourceId</span> <span class="hljs-operator">=</span> cacheKeys.get(sourceIdIndex);<br>      <br>      <span class="hljs-meta">@SuppressWarnings(&quot;PMD.AvoidInstantiatingObjectsInLoops&quot;)</span><br>      <span class="hljs-type">Key</span> <span class="hljs-variable">originalKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataCacheKey</span>(sourceId, helper.getSignature());<br>      cacheFile = helper.getDiskCache().get(originalKey);<br>      <span class="hljs-keyword">if</span> (cacheFile != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.sourceKey = sourceId;<br>        modelLoaders = helper.getModelLoaders(cacheFile);<br>        modelLoaderIndex = <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;<br><br>    loadData = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;<br>      ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);<br>      loadData =<br>          modelLoader.buildLoadData(<br>              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());<br>      <span class="hljs-keyword">if</span> (loadData != <span class="hljs-literal">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;<br>        started = <span class="hljs-literal">true</span>;<br>        loadData.fetcher.loadData(helper.getPriority(), <span class="hljs-built_in">this</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> started;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    GlideTrace.endSection();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是从缓存里面寻找文件，第一次运行肯定找不到，所以直接看最后一个<strong>SourceGenerator</strong>的<strong>startNext</strong>：</p><h4 id="SourceGenerator-startNext"><a href="#SourceGenerator-startNext" class="headerlink" title="SourceGenerator#startNext"></a>SourceGenerator#startNext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startNext</span><span class="hljs-params">()</span> &#123;<br>    <br>    <span class="hljs-comment">//运行到这里 dataToCache 还没有初始化，所以为null，所以直接跳过</span><br>  <span class="hljs-keyword">if</span> (dataToCache != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> dataToCache;<br>    dataToCache = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">isDataInCache</span> <span class="hljs-operator">=</span> cacheData(data);<br>     <br>      <span class="hljs-keyword">if</span> (!isDataInCache) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>      <br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>     <br>      <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;Failed to properly rewind or write data to cache&quot;</span>, e);<br>      &#125;<br>    &#125;<br>  &#125;<br><span class="hljs-comment">//这里一样，直接跳过</span><br>  <span class="hljs-keyword">if</span> (sourceCacheGenerator != <span class="hljs-literal">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  sourceCacheGenerator = <span class="hljs-literal">null</span>;<br><br>  loadData = <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//这里进入循环</span><br>  <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;<br>     <span class="hljs-comment">//helper.getLoadData() 获取所有符合条件的ModelLoader，这些ModelLoader 包括默认的和自定义的</span><br>     <span class="hljs-comment">// 这里的符合条件，也就是ModelLoader 中的handles函数是否返回true，再说直白点，就是判断在load()传入的对象类型，是否可以被ModelLoader所处理</span><br>    loadData = helper.getLoadData().get(loadDataListIndex++);<br>    <span class="hljs-keyword">if</span> (loadData != <span class="hljs-literal">null</span><br>        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())<br>            || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;<br>      started = <span class="hljs-literal">true</span>;<br>      startNextLoad(loadData);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> started;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里找到合适的<strong>ModelLoader</strong>后就进入if，<strong>started</strong>设置为true，进入<strong>startNextLoad</strong>看一看：</p><h4 id="SourceGenerator-startNextLoad"><a href="#SourceGenerator-startNextLoad" class="headerlink" title="SourceGenerator#startNextLoad"></a>SourceGenerator#startNextLoad</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startNextLoad</span><span class="hljs-params">(<span class="hljs-keyword">final</span> LoadData&lt;?&gt; toStart)</span> &#123;<br>    <br>    <br>  loadData.fetcher.loadData(<br>      helper.getPriority(),<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataCallback</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDataReady</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object data)</span> &#123;<br>          <span class="hljs-keyword">if</span> (isCurrentRequest(toStart)) &#123;<br>            onDataReadyInternal(toStart, data);<br>          &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLoadFailed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Exception e)</span> &#123;<br>          <span class="hljs-keyword">if</span> (isCurrentRequest(toStart)) &#123;<br>            onLoadFailedInternal(toStart, e);<br>          &#125;<br>        &#125;<br>      &#125;);<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这里打断点，<strong>loadData.fetcher</strong>是<strong>HttpUrlFetcher</strong>类型，这是在<strong>Glide</strong>构建的时候创建的，我们传入的url是String类型，进入<strong>loadData</strong>看：</p><h4 id="HttpUrlFetcher-loadData"><a href="#HttpUrlFetcher-loadData" class="headerlink" title="HttpUrlFetcher#loadData"></a>HttpUrlFetcher#loadData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadData</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> Priority priority, <span class="hljs-meta">@NonNull</span> DataCallback&lt;? <span class="hljs-built_in">super</span> InputStream&gt; callback)</span> &#123;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> LogTime.getLogTime();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> loadDataWithRedirects(glideUrl.toURL(), <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, glideUrl.getHeaders());<br>    callback.onDataReady(result);<br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;<br>      Log.d(TAG, <span class="hljs-string">&quot;Failed to load data for url&quot;</span>, e);<br>    &#125;<br>    callback.onLoadFailed(e);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;<br>      Log.v(TAG, <span class="hljs-string">&quot;Finished http url fetcher fetch in &quot;</span> + LogTime.getElapsedMillis(startTime));<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>扯了这么久，这里终于就要开始网络请求图片下来了，进入<strong>loadDataWithRedirects</strong>方法看看：</p><h4 id="HttpUrlFetcher-loadDataWithRedirects"><a href="#HttpUrlFetcher-loadDataWithRedirects" class="headerlink" title="HttpUrlFetcher#loadDataWithRedirects"></a>HttpUrlFetcher#loadDataWithRedirects</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> InputStream <span class="hljs-title function_">loadDataWithRedirects</span><span class="hljs-params">(</span><br><span class="hljs-params">    URL url, <span class="hljs-type">int</span> redirects, URL lastUrl, Map&lt;String, String&gt; headers)</span> <span class="hljs-keyword">throws</span> HttpException &#123;<br>  <span class="hljs-keyword">if</span> (redirects &gt;= MAXIMUM_REDIRECTS) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(<br>        <span class="hljs-string">&quot;Too many (&gt; &quot;</span> + MAXIMUM_REDIRECTS + <span class="hljs-string">&quot;) redirects!&quot;</span>, INVALID_STATUS_CODE);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>   <br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (lastUrl != <span class="hljs-literal">null</span> &amp;&amp; url.toURI().equals(lastUrl.toURI())) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(<span class="hljs-string">&quot;In re-direct loop&quot;</span>, INVALID_STATUS_CODE);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (URISyntaxException e) &#123;<br>      <span class="hljs-comment">// Do nothing, this is best effort.</span><br>    &#125;<br>  &#125;<br><br>  urlConnection = buildAndConfigureConnection(url, headers);<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <br>    urlConnection.connect();<br>    <br>    stream = urlConnection.getInputStream();<br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(<br>        <span class="hljs-string">&quot;Failed to connect or obtain data&quot;</span>, getHttpStatusCodeOrInvalid(urlConnection), e);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (isCancelled) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> getHttpStatusCodeOrInvalid(urlConnection);<br>  <span class="hljs-keyword">if</span> (isHttpOk(statusCode)) &#123;<br>    <span class="hljs-keyword">return</span> getStreamForSuccessfulRequest(urlConnection);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isHttpRedirect(statusCode)) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">redirectUrlString</span> <span class="hljs-operator">=</span> urlConnection.getHeaderField(REDIRECT_HEADER_FIELD);<br>    <span class="hljs-keyword">if</span> (TextUtils.isEmpty(redirectUrlString)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(<span class="hljs-string">&quot;Received empty or null redirect url&quot;</span>, statusCode);<br>    &#125;<br>    URL redirectUrl;<br>    <span class="hljs-keyword">try</span> &#123;<br>      redirectUrl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url, redirectUrlString);<br>    &#125; <span class="hljs-keyword">catch</span> (MalformedURLException e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(<span class="hljs-string">&quot;Bad redirect url: &quot;</span> + redirectUrlString, statusCode, e);<br>    &#125;<br>   <br>    cleanup();<br>    <span class="hljs-keyword">return</span> loadDataWithRedirects(redirectUrl, redirects + <span class="hljs-number">1</span>, url, headers);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (statusCode == INVALID_STATUS_CODE) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(statusCode);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(urlConnection.getResponseMessage(), statusCode);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(<span class="hljs-string">&quot;Failed to get a response message&quot;</span>, statusCode, e);<br>    &#125;<br>  &#125;<br>&#125;<br><br><br>  <span class="hljs-keyword">private</span> HttpURLConnection <span class="hljs-title function_">buildAndConfigureConnection</span><span class="hljs-params">(URL url, Map&lt;String, String&gt; headers)</span><br>      <span class="hljs-keyword">throws</span> HttpException &#123;<br>    HttpURLConnection urlConnection;<br>    <span class="hljs-keyword">try</span> &#123;<br>      urlConnection = connectionFactory.build(url);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(<span class="hljs-string">&quot;URL.openConnection threw&quot;</span>, <span class="hljs-comment">/*statusCode=*/</span> <span class="hljs-number">0</span>, e);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123;<br>      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());<br>    &#125;<br>    urlConnection.setConnectTimeout(timeout);<br>    urlConnection.setReadTimeout(timeout);<br>    urlConnection.setUseCaches(<span class="hljs-literal">false</span>);<br>    urlConnection.setDoInput(<span class="hljs-literal">true</span>);<br>    <br>    urlConnection.setInstanceFollowRedirects(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">return</span> urlConnection;<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>真相了，这么牛逼的glide框架，居然是用<strong>HttpURLConnection</strong>进行网络请求的，请求过程不是我们该关心的，总之就是这里通过<strong>HttpURLConnection</strong>请求到了数据，回到<strong>loadData</strong>方法：</p><h4 id="HttpUrlFetcher-loadData-1"><a href="#HttpUrlFetcher-loadData-1" class="headerlink" title="HttpUrlFetcher#loadData"></a>HttpUrlFetcher#loadData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadData</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> Priority priority, <span class="hljs-meta">@NonNull</span> DataCallback&lt;? <span class="hljs-built_in">super</span> InputStream&gt; callback)</span> &#123;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> LogTime.getLogTime();<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> loadDataWithRedirects(glideUrl.toURL(), <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, glideUrl.getHeaders());<br>      <br>    callback.onDataReady(result);<br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;<br>      Log.d(TAG, <span class="hljs-string">&quot;Failed to load data for url&quot;</span>, e);<br>    &#125;<br>    callback.onLoadFailed(e);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;<br>      Log.v(TAG, <span class="hljs-string">&quot;Finished http url fetcher fetch in &quot;</span> + LogTime.getElapsedMillis(startTime));<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<strong>callback.onDataReady(result)<strong>把结果通知回去，当然，如果请求失败了，就会调用</strong>callback.onLoadFailed(e)<strong>把错误通知回去，上面也看到了，这里传进来的</strong>callback</strong>是一个<strong>DataCallback</strong>的匿名内部类，回去看看它的**onDataReady(result)**：</p><h4 id="DataCallback-onDataReady"><a href="#DataCallback-onDataReady" class="headerlink" title="DataCallback#onDataReady"></a>DataCallback#onDataReady</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDataReady</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object data)</span> &#123;<br>  <span class="hljs-keyword">if</span> (isCurrentRequest(toStart)) &#123;<br>    onDataReadyInternal(toStart, data);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里继续调用**onDataReadyInternal(toStart, data)**：</p><h4 id="SourceGenerator-onDataReadyInternal"><a href="#SourceGenerator-onDataReadyInternal" class="headerlink" title="SourceGenerator#onDataReadyInternal"></a>SourceGenerator#onDataReadyInternal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">onDataReadyInternal</span><span class="hljs-params">(LoadData&lt;?&gt; loadData, Object data)</span> &#123;<br>  <span class="hljs-type">DiskCacheStrategy</span> <span class="hljs-variable">diskCacheStrategy</span> <span class="hljs-operator">=</span> helper.getDiskCacheStrategy();<br>    <br>    <span class="hljs-comment">//判断能不能被缓存，这个判断在SourceGenerator.startNext()出现过</span><br>  <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;<br>    dataToCache = data;<br>   <br>    cb.reschedule();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    cb.onDataFetcherReady(<br>        loadData.sourceKey,<br>        data,<br>        loadData.fetcher,<br>        loadData.fetcher.getDataSource(),<br>        originalKey);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先将<strong>data</strong>保存起来，再进入<strong>cb.reschedule()<strong>，这里的</strong>cb</strong>是<strong>DecodeJob</strong>类型，是new **SourceGenerator **的时候传进来的，那就回去看看：</p><h4 id="DecodeJob-reschedule"><a href="#DecodeJob-reschedule" class="headerlink" title="DecodeJob#reschedule"></a>DecodeJob#reschedule</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reschedule</span><span class="hljs-params">()</span> &#123;<br>  runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;<br>  callback.reschedule(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<strong>callback</strong>是<strong>EngineJob</strong>类型，进入它的<strong>reschedule</strong>方法：</p><h4 id="EngineJob-reschedule"><a href="#EngineJob-reschedule" class="headerlink" title="EngineJob#reschedule"></a>EngineJob#reschedule</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reschedule</span><span class="hljs-params">(DecodeJob&lt;?&gt; job)</span> &#123;<br> <br>  getActiveSourceExecutor().execute(job);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里将<strong>DecodeJob</strong>提交到Glide的source线程池中,那就会回到<strong>DecodeJob</strong>的<strong>run</strong>方法，再走一遍 <code>run</code>-&gt;<code>runWrapped()</code>-&gt;<code>SourceGenerator#startNext()</code>，我们看回到这里：</p><h4 id="SourceGenerator-startNext-1"><a href="#SourceGenerator-startNext-1" class="headerlink" title="SourceGenerator#startNext"></a>SourceGenerator#startNext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startNext</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (dataToCache != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> dataToCache;<br>    dataToCache = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">isDataInCache</span> <span class="hljs-operator">=</span> cacheData(data);<br>      <br>      <span class="hljs-keyword">if</span> (!isDataInCache) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>      <br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>     <br>     <br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (sourceCacheGenerator != <span class="hljs-literal">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  sourceCacheGenerator = <span class="hljs-literal">null</span>;<br><br>  loadData = <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;<br>    loadData = helper.getLoadData().get(loadDataListIndex++);<br>    <span class="hljs-keyword">if</span> (loadData != <span class="hljs-literal">null</span><br>        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())<br>            || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;<br>      started = <span class="hljs-literal">true</span>;<br>      startNextLoad(loadData);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> started;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是第二次执行到这里，这次<strong>dataToCache !&#x3D; null</strong>成立，会进入if语句的代码块，通过方法<strong>cacheData(data)<strong>，把</strong>data</strong>存入缓存</p><h4 id="SourceGenerator-cacheData"><a href="#SourceGenerator-cacheData" class="headerlink" title="SourceGenerator#cacheData"></a>SourceGenerator#cacheData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cacheData</span><span class="hljs-params">(Object dataToCache)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> LogTime.getLogTime();<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isLoadingFromSourceData</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    DataRewinder&lt;Object&gt; rewinder = helper.getRewinder(dataToCache);<br>      <br>    <span class="hljs-type">Object</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> rewinder.rewindAndGet();<br>      <br>    Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(data);<br>      <br>    DataCacheWriter&lt;Object&gt; writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataCacheWriter</span>&lt;&gt;(encoder, data, helper.getOptions());<br>      <br>    <span class="hljs-type">DataCacheKey</span> <span class="hljs-variable">newOriginalKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataCacheKey</span>(loadData.sourceKey, helper.getSignature());<br>    <span class="hljs-type">DiskCache</span> <span class="hljs-variable">diskCache</span> <span class="hljs-operator">=</span> helper.getDiskCache();<br>    diskCache.put(newOriginalKey, writer);<br><br>    <span class="hljs-keyword">if</span> (diskCache.get(newOriginalKey) != <span class="hljs-literal">null</span>) &#123;<br>      originalKey = newOriginalKey;<br>      <span class="hljs-comment">//这里给sourceCacheGenerator直接new了一个值</span><br>        sourceCacheGenerator =<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataCacheGenerator</span>(Collections.singletonList(loadData.sourceKey), helper, <span class="hljs-built_in">this</span>);<br> <br>        <span class="hljs-comment">//这里return了一个true回去</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <br>      <span class="hljs-comment">//......</span><br></code></pre></td></tr></table></figure><p>这里将data存入了缓存，并且new了一个<strong>DataCacheGenerator</strong>，现在回到**startNext()<strong>方法里面，这里调用了</strong>sourceCacheGenerator.startNext()**，这里离得有点远，重新贴一下源码：</p><h4 id="DataCacheGenerator-startNext-1"><a href="#DataCacheGenerator-startNext-1" class="headerlink" title="DataCacheGenerator#startNext"></a>DataCacheGenerator#startNext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startNext</span><span class="hljs-params">()</span> &#123;<br> <br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">while</span> (modelLoaders == <span class="hljs-literal">null</span> || !hasNextModelLoader()) &#123;<br>        <br>        <span class="hljs-comment">//sourceIdIndex的初始化值是-1，所以这里的if里面的条件是不满足的</span><br>      sourceIdIndex++;<br>      <span class="hljs-keyword">if</span> (sourceIdIndex &gt;= cacheKeys.size()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br><br>      <span class="hljs-type">Key</span> <span class="hljs-variable">sourceId</span> <span class="hljs-operator">=</span> cacheKeys.get(sourceIdIndex);<br>      <br>      <span class="hljs-type">Key</span> <span class="hljs-variable">originalKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataCacheKey</span>(sourceId, helper.getSignature());<br>      cacheFile = helper.getDiskCache().get(originalKey);<br>       <span class="hljs-comment">//cacheFile肯定是不为null的，因为前面刚缓存过</span><br>      <span class="hljs-keyword">if</span> (cacheFile != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.sourceKey = sourceId;<br>       <span class="hljs-comment">//进入之后就会给modelLoaders赋值，赋值以后不满住循环条件，跳出循环</span><br>        modelLoaders = helper.getModelLoaders(cacheFile);<br>        modelLoaderIndex = <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;<br>      <br><br>    loadData = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;<br>      ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);<br>      loadData =<br>          modelLoader.buildLoadData(<br>              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());<br>      <span class="hljs-keyword">if</span> (loadData != <span class="hljs-literal">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;<br>        started = <span class="hljs-literal">true</span>;<br>          <span class="hljs-comment">//这里又进入HttpUrlFetcher #loadData</span><br>        loadData.fetcher.loadData(helper.getPriority(), <span class="hljs-built_in">this</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> started;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    GlideTrace.endSection();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行到这个方法之后，又一次进入了<strong>HttpUrlFetcher #loadData</strong>，值得注意的是，这次将第二个参数：<strong>callback</strong>的值传为了自己；这里再次进入<strong>loadData</strong>方法，请求到数据之后，回调到自己的<strong>onDataReady</strong>方法：</p><h4 id="HttpUrlFetcher-loadData-2"><a href="#HttpUrlFetcher-loadData-2" class="headerlink" title="HttpUrlFetcher #loadData"></a>HttpUrlFetcher #loadData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDataReady</span><span class="hljs-params">(Object data)</span> &#123;<br>  cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.DATA_DISK_CACHE, sourceKey);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>cb</code>在上面<strong>cacheData</strong>方法创建<strong>DataCacheGenerator</strong>的时候指定成了<strong>SourceGenerator</strong>，回调到<strong>onDataFetcherReady</strong>（到处回调，我人傻了）：</p><h4 id="SourceGenerator-onDataFetcherReady"><a href="#SourceGenerator-onDataFetcherReady" class="headerlink" title="SourceGenerator#onDataFetcherReady"></a>SourceGenerator#onDataFetcherReady</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDataFetcherReady</span><span class="hljs-params">(</span><br><span class="hljs-params">    Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey)</span> &#123;<br>  <br>  cb.onDataFetcherReady(sourceKey, data, fetcher, loadData.fetcher.getDataSource(), sourceKey);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>cb</code>又是指的<strong>DecodeJob</strong> （。。。。。。）:</p><h4 id="DecodeJob-onDataFetcherReady"><a href="#DecodeJob-onDataFetcherReady" class="headerlink" title="DecodeJob#onDataFetcherReady"></a>DecodeJob#onDataFetcherReady</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDataFetcherReady</span><span class="hljs-params">(</span><br><span class="hljs-params">    Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey)</span> &#123;<br>  <span class="hljs-built_in">this</span>.currentSourceKey = sourceKey;<br>  <span class="hljs-built_in">this</span>.currentData = data;<br>  <span class="hljs-built_in">this</span>.currentFetcher = fetcher;<br>  <span class="hljs-built_in">this</span>.currentDataSource = dataSource;<br>  <span class="hljs-built_in">this</span>.currentAttemptingKey = attemptedKey;<br>  <span class="hljs-built_in">this</span>.isLoadingFromAlternateCacheKey = sourceKey != decodeHelper.getCacheKeys().get(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">//onDataFetcherReady方法会保存传入的参数，然后确认执行线程后调用`decodeFromRetrievedData()`方法进行解码。</span><br>  <span class="hljs-keyword">if</span> (Thread.currentThread() != currentThread) &#123;<br>    runReason = RunReason.DECODE_DATA;<br>    callback.reschedule(<span class="hljs-built_in">this</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    GlideTrace.beginSection(<span class="hljs-string">&quot;DecodeJob.decodeFromRetrievedData&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      decodeFromRetrievedData();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      GlideTrace.endSection();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是漫长的解码过程，看看就行，不重点关注这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decodeFromRetrievedData</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;<br>    logWithTimeAndKey(<br>        <span class="hljs-string">&quot;Retrieved data&quot;</span>,<br>        startFetchTime,<br>        <span class="hljs-string">&quot;data: &quot;</span><br>            + currentData<br>            + <span class="hljs-string">&quot;, cache key: &quot;</span><br>            + currentSourceKey<br>            + <span class="hljs-string">&quot;, fetcher: &quot;</span><br>            + currentFetcher);<br>  &#125;<br>  Resource&lt;R&gt; resource = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    resource = decodeFromData(currentFetcher, currentData, currentDataSource);<br>  &#125; <span class="hljs-keyword">catch</span> (GlideException e) &#123;<br>    e.setLoggingDetails(currentAttemptingKey, currentDataSource);<br>    throwables.add(e);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (resource != <span class="hljs-literal">null</span>) &#123;<br>    notifyEncodeAndRelease(resource, currentDataSource, isLoadingFromAlternateCacheKey);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    runGenerators();<br>  &#125;<br>&#125;<br><br><br>  <span class="hljs-keyword">private</span> &lt;Data&gt; Resource&lt;R&gt; <span class="hljs-title function_">decodeFromData</span><span class="hljs-params">(</span><br><span class="hljs-params">      DataFetcher&lt;?&gt; fetcher, Data data, DataSource dataSource)</span> <span class="hljs-keyword">throws</span> GlideException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> LogTime.getLogTime();<br>      Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);<br>      <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;<br>        logWithTimeAndKey(<span class="hljs-string">&quot;Decoded result &quot;</span> + result, startTime);<br>      &#125;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      fetcher.cleanup();<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>调用<strong>decodeFromData</strong>，经过一系列的处理之后，返回解码和处理之后（<strong>解码，旋转，压缩，圆角等</strong>）的图片，传入方法<strong>notifyEncodeAndRelease</strong>：</p><h4 id="DecodeJob-notifyEncodeAndRelease"><a href="#DecodeJob-notifyEncodeAndRelease" class="headerlink" title="DecodeJob#notifyEncodeAndRelease"></a>DecodeJob#notifyEncodeAndRelease</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyEncodeAndRelease</span><span class="hljs-params">(</span><br><span class="hljs-params">    Resource&lt;R&gt; resource, DataSource dataSource, <span class="hljs-type">boolean</span> isLoadedFromAlternateCacheKey)</span> &#123;<br>  GlideTrace.beginSection(<span class="hljs-string">&quot;DecodeJob.notifyEncodeAndRelease&quot;</span>);<br>  <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// resource是BitmapResource类型，实现了Initializable接口，调用了prepareToDraw()（ps.官方解释：重建与用于绘制位图的位图关联的所有缓存。）</span><br>    <span class="hljs-keyword">if</span> (resource <span class="hljs-keyword">instanceof</span> Initializable) &#123;<br>      ((Initializable) resource).initialize();<br>    &#125;<br><br>    Resource&lt;R&gt; result = resource;<br>    LockedResource&lt;R&gt; lockedResource = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (deferredEncodeManager.hasResourceToEncode()) &#123;<br>      lockedResource = LockedResource.obtain(resource);<br>      result = lockedResource;<br>    &#125;<br><br>    notifyComplete(result, dataSource, isLoadedFromAlternateCacheKey);<br><br>    stage = Stage.ENCODE;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (deferredEncodeManager.hasResourceToEncode()) &#123;<br>        deferredEncodeManager.encode(diskCacheProvider, options);<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (lockedResource != <span class="hljs-literal">null</span>) &#123;<br>        lockedResource.unlock();<br>      &#125;<br>    &#125;<br>    <br>    onEncodeComplete();<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    GlideTrace.endSection();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>扯了半天之后，会运行到<strong>notifyComplete</strong>：</p><h4 id="DecodeJob-notifyComplete"><a href="#DecodeJob-notifyComplete" class="headerlink" title="DecodeJob#notifyComplete"></a>DecodeJob#notifyComplete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyComplete</span><span class="hljs-params">(</span><br><span class="hljs-params">    Resource&lt;R&gt; resource, DataSource dataSource, <span class="hljs-type">boolean</span> isLoadedFromAlternateCacheKey)</span> &#123;<br>  setNotifiedOrThrow();<br>  callback.onResourceReady(resource, dataSource, isLoadedFromAlternateCacheKey);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<strong>callback</strong>是<strong>EngineJob</strong>，进入他的<strong>onResourceReady</strong>方法：</p><h4 id="EngineJob-onResourceReady"><a href="#EngineJob-onResourceReady" class="headerlink" title="EngineJob#onResourceReady"></a>EngineJob#onResourceReady</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResourceReady</span><span class="hljs-params">(</span><br><span class="hljs-params">    Resource&lt;R&gt; resource, DataSource dataSource, <span class="hljs-type">boolean</span> isLoadedFromAlternateCacheKey)</span> &#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-built_in">this</span>.resource = resource;<br>    <span class="hljs-built_in">this</span>.dataSource = dataSource;<br>    <span class="hljs-built_in">this</span>.isLoadedFromAlternateCacheKey = isLoadedFromAlternateCacheKey;<br>  &#125;<br>  notifyCallbacksOfResult();<br>&#125;<br><br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyCallbacksOfResult</span><span class="hljs-params">()</span> &#123;<br>    ResourceCallbacksAndExecutors copy;<br>    Key localKey;<br>    EngineResource&lt;?&gt; localResource;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>     <br>      engineResource = engineResourceFactory.build(resource, isCacheable, key, resourceListener);<br>      <br>      hasResource = <span class="hljs-literal">true</span>;<br>      copy = cbs.copy();<br>      incrementPendingCallbacks(copy.size() + <span class="hljs-number">1</span>);<br><br>      localKey = key;<br>      localResource = engineResource;<br>    &#125;<br><br>    engineJobListener.onEngineJobComplete(<span class="hljs-built_in">this</span>, localKey, localResource);<br><br>      <br>  <span class="hljs-comment">// 这里的ResourceCallbackAndExecutor就是前面创建EngineJob和DecodeJob并在执行DecodeJob之前添加的回调</span><br>  <span class="hljs-comment">// entry.executor就是Glide.with.load.into中出现的Executors.mainThreadExecutor()</span><br>  <span class="hljs-comment">// entry.cb就是SingleRequest</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ResourceCallbackAndExecutor entry : copy) &#123;<br>      entry.executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallResourceReady</span>(entry.cb));<br>    &#125;<br>    decrementPendingCallbacks();<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里用了<strong>Executors.mainThreadExecutor()<strong>，说明在这里开始回到了主线程，也就是说前面一直都在子线程里面，现在进入</strong>CallResourceReady</strong>查看<strong>run</strong>方法：</p><h4 id="CallResourceReady-run"><a href="#CallResourceReady-run" class="headerlink" title="CallResourceReady#run"></a>CallResourceReady#run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>  <br>  <span class="hljs-keyword">synchronized</span> (cb.getLock()) &#123;<br>    <span class="hljs-keyword">synchronized</span> (EngineJob.<span class="hljs-built_in">this</span>) &#123;<br>      <span class="hljs-keyword">if</span> (cbs.contains(cb)) &#123;<br>        <span class="hljs-comment">// Acquire for this particular callback.</span><br>        engineResource.acquire();<br>        callCallbackOnResourceReady(cb);<br>        removeCallback(cb);<br>      &#125;<br>      decrementPendingCallbacks();<br>    &#125;<br>  &#125;<br>&#125;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">callCallbackOnResourceReady</span><span class="hljs-params">(ResourceCallback cb)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <br>      cb.onResourceReady(engineResource, dataSource, isLoadedFromAlternateCacheKey);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallbackException</span>(t);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里的<code>cb</code>是<strong>SingleRequest</strong>，这个<code>onResourceReady</code>方法会调用他的重载方法：</p><h4 id="SingleRequest-onResourceReady"><a href="#SingleRequest-onResourceReady" class="headerlink" title="SingleRequest#onResourceReady"></a>SingleRequest#onResourceReady</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResourceReady</span><span class="hljs-params">(</span><br><span class="hljs-params">    Resource&lt;R&gt; resource, R result, DataSource dataSource, <span class="hljs-type">boolean</span> isAlternateCacheKey)</span> &#123;<br>  <span class="hljs-comment">// We must call isFirstReadyResource before setting status.</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isFirstResource</span> <span class="hljs-operator">=</span> isFirstReadyResource();<br>  status = Status.COMPLETE;<br>  <span class="hljs-built_in">this</span>.resource = resource;<br><br><br>  isCallingCallbacks = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">anyListenerHandledUpdatingTarget</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-comment">// 尝试调用各个listener的onResourceReady回调进行处理</span><br>    <span class="hljs-keyword">if</span> (requestListeners != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">for</span> (RequestListener&lt;R&gt; listener : requestListeners) &#123;<br>        anyListenerHandledUpdatingTarget |=<br>            listener.onResourceReady(result, model, target, dataSource, isFirstResource);<br>      &#125;<br>    &#125;<br>    anyListenerHandledUpdatingTarget |=<br>        targetListener != <span class="hljs-literal">null</span><br>            &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);<br><span class="hljs-comment">// 如果没有一个回调能够处理，那么自己处理</span><br>    <span class="hljs-keyword">if</span> (!anyListenerHandledUpdatingTarget) &#123;<br>      Transition&lt;? <span class="hljs-built_in">super</span> R&gt; animation = animationFactory.build(dataSource, isFirstResource);<br>      target.onResourceReady(result, animation);<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    isCallingCallbacks = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  notifyLoadSuccess();<br>  GlideTrace.endSectionAsync(TAG, cookie);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里最终会调用**target.onResourceReady(result, animation)**，这里的<code>target</code>是<code>ImageViewTarget</code></p><h4 id="ImageViewTarget-onResourceReady"><a href="#ImageViewTarget-onResourceReady" class="headerlink" title="ImageViewTarget#onResourceReady"></a>ImageViewTarget#onResourceReady</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResourceReady</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Z resource, <span class="hljs-meta">@Nullable</span> Transition&lt;? <span class="hljs-built_in">super</span> Z&gt; transition)</span> &#123;<br>  <span class="hljs-keyword">if</span> (transition == <span class="hljs-literal">null</span> || !transition.transition(resource, <span class="hljs-built_in">this</span>)) &#123;<br>    setResourceInternal(resource);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    maybeUpdateAnimatable(resource);<br>  &#125;<br>&#125;<br><br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setResourceInternal</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Z resource)</span> &#123;<br><br>    setResource(resource);<br>    maybeUpdateAnimatable(resource);<br>  &#125;<br><br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setResource</span><span class="hljs-params">(Bitmap resource)</span> &#123;<br>    view.setImageBitmap(resource);<br>  &#125;<br><br> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setResource</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Drawable resource)</span> &#123;<br>    view.setImageDrawable(resource);<br>  &#125;<br></code></pre></td></tr></table></figure><p>这是整个Glide的加载流程，下面是这期间涉及到的类的作用的一些简单的总结：</p><ul><li><p><code>RequestManagerRetriever</code>:该类用于创建<code>RequestManager</code>或在<code>Activity</code>、<code>Fragment</code>中找出已创建的<code>RequestManager</code>，<code>RequestManagerRetriever</code>是一个单例。</p></li><li><p><code>RequestManagerFragment</code>:继承Fragment,不可见，仅用于保存<code>RequestManager</code>，还有一个<code>SupportRequestManagerFragment</code>继承Fragment,隐藏的fragment，监听生命周期。</p></li><li><p><code>LifecycleListener</code>：用于监听<code>Activity</code>、<code>Fragment</code>的生命周期事件。</p></li><li><p><code>Lifecycle</code>：用于添加<code>LifecycleListener</code>。</p></li><li><p><code>ActivityFragmentLifecycle</code>：实现<code>Livecycle</code>接口，用于通知<code>Activity</code>、<code>Fragment</code>的生命周期事件。</p></li><li><p><code>RequestTracker</code>：该类用于跟踪、取消和重新启动执行中、已完成和失败的请求。</p><p>下面是一张流程图：</p><p><img src="https://upload-images.jianshu.io/upload_images/6337201-e1c429e8c0879274.png"></p></li></ul><h2 id="Glide缓存"><a href="#Glide缓存" class="headerlink" title="Glide缓存"></a>Glide缓存</h2><h3 id="Glide三级缓存"><a href="#Glide三级缓存" class="headerlink" title="Glide三级缓存"></a>Glide三级缓存</h3><p>我们或多或少的都知道Glide是由三级缓存的，那具体是哪三级呢？</p><p>第一个是<code>ActiveResources</code>，第二个是<code>MemoryCache</code>（内存缓存），第三个是<code>DiskCache</code>（磁盘缓存）。</p><p><code>ActiveResources</code>缓存是指的当前活跃的图片资源，也就是有其它对象持有（引用）它，比如<code>recycleView</code>每个item都引用同一张图片资源，这时候就会直接使用<code>ActiveResources</code>缓存；对于<code>MemoryCache</code>（内存缓存），Glide采用的是<code>LruCache</code>算法（Least Recently Used）：也叫近期最少使用算法，大概原理就是把最近使用的对象强引用存储在<code>LinkedHashMap</code>中，并且把最近最少使用的对象在缓存值达到阈值之前从内存中移除。这推荐一篇文章，有兴趣可以了解一下：<a href="https://www.jianshu.com/p/3021c9c5b47f">Android 缓存策略之LruCache</a></p><p>先浅看一下<code>ActiveResources</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActiveResources</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isActiveResourceRetentionAllowed;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor monitorClearedResourcesExecutor;<br>  <span class="hljs-meta">@VisibleForTesting</span> <span class="hljs-keyword">final</span> Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReferenceQueue&lt;EngineResource&lt;?&gt;&gt; resourceReferenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">private</span> ResourceListener listener;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> isShutdown;<br>  <span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> DequeuedResourceCallback cb;<br><br>  ActiveResources(<span class="hljs-type">boolean</span> isActiveResourceRetentionAllowed) &#123;<br>    <span class="hljs-built_in">this</span>(<br>        isActiveResourceRetentionAllowed,<br>        java.util.concurrent.Executors.newSingleThreadExecutor(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Runnable r)</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                      <span class="hljs-meta">@Override</span><br>                      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);<br>                        r.run();<br>                      &#125;<br>                    &#125;,<br>                    <span class="hljs-string">&quot;glide-active-resources&quot;</span>);<br>              &#125;<br>            &#125;));<br>  &#125;<br><br>  <span class="hljs-meta">@VisibleForTesting</span><br>  ActiveResources(<br>      <span class="hljs-type">boolean</span> isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) &#123;<br>    <span class="hljs-built_in">this</span>.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;<br>    <span class="hljs-built_in">this</span>.monitorClearedResourcesExecutor = monitorClearedResourcesExecutor;<br><br>      <span class="hljs-comment">//这里会开启一个后台线程去调用cleanReferenceQueue()</span><br>    monitorClearedResourcesExecutor.execute(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            cleanReferenceQueue();<br>          &#125;<br>        &#125;);<br>  &#125;<br>    <br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanReferenceQueue</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//while循环里面调用了resourceReferenceQueue的remove()，这个方法会一直阻塞当前线程，直到有返回值。当ResourceWeakReference里面的EngineResource被内存回收掉的时候才会有返回值。</span><br>    <span class="hljs-keyword">while</span> (!isShutdown) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ResourceWeakReference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> (ResourceWeakReference) resourceReferenceQueue.remove();<br>        cleanupActiveReference(ref);<br><br>        <br>        <span class="hljs-type">DequeuedResourceCallback</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> cb;<br>        <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">null</span>) &#123;<br>          current.onResourceDequeued();<br>        &#125;<br>        <br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt();<br>      &#125;<br>    &#125;<br>  &#125;<br>   <span class="hljs-comment">//下面是保存和删除的方法</span><br>    <br>    <span class="hljs-comment">//保存resource</span><br><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">activate</span><span class="hljs-params">(Key key, EngineResource&lt;?&gt; resource)</span> &#123;<br>    <span class="hljs-comment">//先将resource封装成ResourceWeakReference（弱引用持有，防止内存泄漏，同时保证了当进行内存回收时能及时回收掉，避免一直占用内存。如果被回收掉就会转移到memory cache中）</span><br>    <span class="hljs-type">ResourceWeakReference</span> <span class="hljs-variable">toPut</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceWeakReference</span>(<br>        key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);<br><span class="hljs-comment">//然后将ResourceWeakReference对象存入队列中</span><br>    <span class="hljs-type">ResourceWeakReference</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> activeEngineResources.put(key, toPut);<br>    <span class="hljs-comment">//如果之前的队列中有相同的key存在的对象，那么应该将之前的对应重置</span><br>    <span class="hljs-keyword">if</span> (removed != <span class="hljs-literal">null</span>) &#123;<br>        removed.reset();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//删除resource</span><br><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deactivate</span><span class="hljs-params">(Key key)</span> &#123;<br>    <span class="hljs-type">ResourceWeakReference</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> activeEngineResources.remove(key);<br>    <span class="hljs-keyword">if</span> (removed != <span class="hljs-literal">null</span>) &#123;<br>        removed.reset();<br>    &#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="EngineResource"><a href="#EngineResource" class="headerlink" title="EngineResource"></a>EngineResource</h3><p>这是一个对资源的包装类，我们看看他内部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EngineResource</span>&lt;Z&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Resource</span>&lt;Z&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isMemoryCacheable;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isRecyclable;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Resource&lt;Z&gt; resource;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ResourceListener listener;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Key key;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> acquired;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isRecycled;<br><br>  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ResourceListener</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResourceReleased</span><span class="hljs-params">(Key key, EngineResource&lt;?&gt; resource)</span>;<br>  &#125;<br><br>  EngineResource(<br>      Resource&lt;Z&gt; toWrap,<br>      <span class="hljs-type">boolean</span> isMemoryCacheable,<br>      <span class="hljs-type">boolean</span> isRecyclable,<br>      Key key,<br>      ResourceListener listener) &#123;<br>    resource = Preconditions.checkNotNull(toWrap);<br>    <span class="hljs-built_in">this</span>.isMemoryCacheable = isMemoryCacheable;<br>    <span class="hljs-built_in">this</span>.isRecyclable = isRecyclable;<br>    <span class="hljs-built_in">this</span>.key = key;<br>    <span class="hljs-built_in">this</span>.listener = Preconditions.checkNotNull(listener);<br>  &#125;<br><br>  Resource&lt;Z&gt; <span class="hljs-title function_">getResource</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> resource;<br>  &#125;<br><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMemoryCacheable</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> isMemoryCacheable;<br>  &#125;<br><br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Class&lt;Z&gt; <span class="hljs-title function_">getResourceClass</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> resource.getResourceClass();<br>  &#125;<br><br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Z <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> resource.get();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> resource.getSize();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recycle</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (acquired &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Cannot recycle a resource while it is still acquired&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isRecycled) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Cannot recycle a resource that has already been recycled&quot;</span>);<br>    &#125;<br>    isRecycled = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (isRecyclable) &#123;<br>      resource.recycle();<br>    &#125;<br>  &#125;<br><br> <br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> &#123;<br>  <br>    ++acquired;<br>  &#125;<br><br><br>  <span class="hljs-meta">@SuppressWarnings(&quot;SynchronizeOnNonFinalField&quot;)</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">release</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br><br>      <span class="hljs-keyword">if</span> (--acquired == <span class="hljs-number">0</span>) &#123;<br>        release = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (release) &#123;<br>      listener.onResourceReleased(key, <span class="hljs-built_in">this</span>);<br>    &#125;<br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们主要关注两个方法，一个<code>acquire</code>，一个<code>release</code>。<code>acquire</code>方法很简单，就是每调用一次这个方法，就给<code>acquired</code>成员变量加一。<code>release</code>也很简单，每次调用都给<code>acquired</code>成员变量减一，当<code>acquired</code>成员变量为0的时候，调用<code>listener.onResourceReleased</code>。这里采用的算法是<strong>引用计数法</strong>去管理<code>EngineResource</code>。(<a href="https://blog.csdn.net/qq_42185762/article/details/115667911">引用计数法的原理和优缺点</a>)</p><h3 id="EngineKey"><a href="#EngineKey" class="headerlink" title="EngineKey"></a>EngineKey</h3><p>看缓存流程之前，不得不看看这个东西，<code>EngineKey</code>是Glide图片缓存的读取和保存的标识，每个任务创建的时候都会创建一个key，后面通过这个key去缓存里找到缓存的资源，先看看<code>EngineKey</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EngineKey</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Key</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object model;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> width;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> height;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; resourceClass;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; transcodeClass;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Key signature;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Options options;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hashCode;<br><br>  EngineKey(<br>      Object model,<br>      Key signature,<br>      <span class="hljs-type">int</span> width,<br>      <span class="hljs-type">int</span> height,<br>      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,<br>      Class&lt;?&gt; resourceClass,<br>      Class&lt;?&gt; transcodeClass,<br>      Options options) &#123;<br>    <span class="hljs-built_in">this</span>.model = Preconditions.checkNotNull(model);<br>    <span class="hljs-built_in">this</span>.signature = Preconditions.checkNotNull(signature, <span class="hljs-string">&quot;Signature must not be null&quot;</span>);<br>    <span class="hljs-built_in">this</span>.width = width;<br>    <span class="hljs-built_in">this</span>.height = height;<br>    <span class="hljs-built_in">this</span>.transformations = Preconditions.checkNotNull(transformations);<br>    <span class="hljs-built_in">this</span>.resourceClass =<br>        Preconditions.checkNotNull(resourceClass, <span class="hljs-string">&quot;Resource class must not be null&quot;</span>);<br>    <span class="hljs-built_in">this</span>.transcodeClass =<br>        Preconditions.checkNotNull(transcodeClass, <span class="hljs-string">&quot;Transcode class must not be null&quot;</span>);<br>    <span class="hljs-built_in">this</span>.options = Preconditions.checkNotNull(options);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> EngineKey) &#123;<br>      <span class="hljs-type">EngineKey</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (EngineKey) o;<br>      <span class="hljs-keyword">return</span> model.equals(other.model)<br>          &amp;&amp; signature.equals(other.signature)<br>          &amp;&amp; height == other.height<br>          &amp;&amp; width == other.width<br>          &amp;&amp; transformations.equals(other.transformations)<br>          &amp;&amp; resourceClass.equals(other.resourceClass)<br>          &amp;&amp; transcodeClass.equals(other.transcodeClass)<br>          &amp;&amp; options.equals(other.options);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (hashCode == <span class="hljs-number">0</span>) &#123;<br>      hashCode = model.hashCode();<br>      hashCode = <span class="hljs-number">31</span> * hashCode + signature.hashCode();<br>      hashCode = <span class="hljs-number">31</span> * hashCode + width;<br>      hashCode = <span class="hljs-number">31</span> * hashCode + height;<br>      hashCode = <span class="hljs-number">31</span> * hashCode + transformations.hashCode();<br>      hashCode = <span class="hljs-number">31</span> * hashCode + resourceClass.hashCode();<br>      hashCode = <span class="hljs-number">31</span> * hashCode + transcodeClass.hashCode();<br>      hashCode = <span class="hljs-number">31</span> * hashCode + options.hashCode();<br>    &#125;<br>    <span class="hljs-keyword">return</span> hashCode;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;EngineKey&#123;&quot;</span><br>        + <span class="hljs-string">&quot;model=&quot;</span><br>        + model<br>        + <span class="hljs-string">&quot;, width=&quot;</span><br>        + width<br>        + <span class="hljs-string">&quot;, height=&quot;</span><br>        + height<br>        + <span class="hljs-string">&quot;, resourceClass=&quot;</span><br>        + resourceClass<br>        + <span class="hljs-string">&quot;, transcodeClass=&quot;</span><br>        + transcodeClass<br>        + <span class="hljs-string">&quot;, signature=&quot;</span><br>        + signature<br>        + <span class="hljs-string">&quot;, hashCode=&quot;</span><br>        + hashCode<br>        + <span class="hljs-string">&quot;, transformations=&quot;</span><br>        + transformations<br>        + <span class="hljs-string">&quot;, options=&quot;</span><br>        + options<br>        + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateDiskCacheKey</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageDigest messageDigest)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从这里我们可以看到，一个图片的key，由<code>model</code>、<code>signature</code>、<code>width</code>、<code>height</code>等多个参数共同决定，这几个值改变一个就会重新创建一个key，key不一样了，对于Glide来说就是两个不同的资源。</p><h3 id="key的创建"><a href="#key的创建" class="headerlink" title="key的创建"></a>key的创建</h3><p>key的创建我们前面也介绍过，在<strong>Engine#load</strong>方法里，通过工厂模式创建一个key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;R&gt; LoadStatus <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-comment">/*省略参数*/</span>)</span> &#123;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="hljs-number">0</span>;<br><br>  <span class="hljs-type">EngineKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span><br>      keyFactory.buildKey(<br>          model,<br>          signature,<br>          width,<br>          height,<br>          transformations,<br>          resourceClass,<br>          transcodeClass,<br>          options);<br><br>  EngineResource&lt;?&gt; memoryResource;<br>  <br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>      <br>    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);<br><br>      <span class="hljs-comment">//省略代码</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，我们看到这里通过<strong>loadFromMemory</strong>，传入key来得到一个<strong>memoryResource</strong>对象，又到了分析源码的时候，点进去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> EngineResource&lt;?&gt; loadFromMemory(<br>    EngineKey key, <span class="hljs-type">boolean</span> isMemoryCacheable, <span class="hljs-type">long</span> startTime) &#123;<br>  <span class="hljs-keyword">if</span> (!isMemoryCacheable) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>    <span class="hljs-comment">//这里在ActiveResources里面找</span><br>  EngineResource&lt;?&gt; active = loadFromActiveResources(key);<br>  <span class="hljs-keyword">if</span> (active != <span class="hljs-literal">null</span>) &#123;<br>    <br>    <span class="hljs-keyword">return</span> active;<br>  &#125;<br><br>    <span class="hljs-comment">//从内存缓存找</span><br>  EngineResource&lt;?&gt; cached = loadFromCache(key);<br>  <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span>) &#123;<br>    <br>    <span class="hljs-keyword">return</span> cached;<br>  &#125;<br><br>    <span class="hljs-comment">//实在没找到只能返回null，从网络上下载</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br>  <span class="hljs-keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key) &#123;<br>    EngineResource&lt;?&gt; active = activeResources.get(key);<br>    <span class="hljs-keyword">if</span> (active != <span class="hljs-literal">null</span>) &#123;<br>      active.acquire();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> active;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;<br>    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);<br>    <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span>) &#123;<br>      cached.acquire();<br>      activeResources.activate(key, cached);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cached;<br>  &#125;<br></code></pre></td></tr></table></figure><p>先来看看这里的<strong>get</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> EngineResource&lt;?&gt; get(Key key) &#123;<br>  <span class="hljs-type">ResourceWeakReference</span> <span class="hljs-variable">activeRef</span> <span class="hljs-operator">=</span> activeEngineResources.get(key);<br>  <span class="hljs-keyword">if</span> (activeRef == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  EngineResource&lt;?&gt; active = activeRef.get();<br>  <span class="hljs-keyword">if</span> (active == <span class="hljs-literal">null</span>) &#123;<br>    cleanupActiveReference(activeRef);<br>  &#125;<br>  <span class="hljs-keyword">return</span> active;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里从维护的<strong>HashMap</strong>中找出来一个<strong>EngineResource</strong>的弱引用，通过弱引用把<strong>EngineResource</strong>拿了出来返回回去，这是<strong>ActiveResources</strong>查找的流程，如果这里没找到，就需要看下面的方法<strong>loadFromCache</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;<br>  EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);<br>  <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span>) &#123;<br>      <br>    cached.acquire();<br>    activeResources.activate(key, cached);<br>      <br>  &#125;<br>  <span class="hljs-keyword">return</span> cached;<br>&#125;<br><br><br>  <span class="hljs-keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;<br><span class="hljs-comment">//首先将找到key对应的cache，并移除，因为在上一个函数中，return回去的cached不为null，就将cached加入activeResources，所以要先在这里将其移除</span><br>    Resource&lt;?&gt; cached = cache.remove(key);<br><br>    <span class="hljs-keyword">final</span> EngineResource&lt;?&gt; result;<br>    <span class="hljs-keyword">if</span> (cached == <span class="hljs-literal">null</span>) &#123;<br>      result = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cached <span class="hljs-keyword">instanceof</span> EngineResource) &#123;<br>      result = (EngineResource&lt;?&gt;) cached;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result =<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">EngineResource</span>&lt;&gt;(<br>              cached, <span class="hljs-comment">/*isMemoryCacheable=*/</span> <span class="hljs-literal">true</span>, <span class="hljs-comment">/*isRecyclable=*/</span> <span class="hljs-literal">true</span>, key, <span class="hljs-comment">/*listener=*/</span> <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br></code></pre></td></tr></table></figure><p>到这里，从内存缓存中取出资源就结束了，取出来知道了，那这个缓存是怎么存进去的呢？其实在我们前面的流程里面已经出现过，先看到<code>EngineJob</code>的**notifyCallbacksOfResult()**方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyCallbacksOfResult</span><span class="hljs-params">()</span> &#123;<br>  ResourceCallbacksAndExecutors copy;<br>  Key localKey;<br>  EngineResource&lt;?&gt; localResource;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    stateVerifier.throwIfRecycled();<br>    <span class="hljs-keyword">if</span> (isCancelled) &#123;<br>     <br>      resource.recycle();<br>      release();<br>      <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cbs.isEmpty()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Received a resource without any callbacks to notify&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasResource) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Already have resource&quot;</span>);<br>    &#125;<br>      <span class="hljs-comment">//注意看这里，通过传入的data，生成了一个engineResource</span><br>    engineResource = engineResourceFactory.build(resource, isCacheable, key, resourceListener);<br>  <br>    hasResource = <span class="hljs-literal">true</span>;<br>    copy = cbs.copy();<br>    incrementPendingCallbacks(copy.size() + <span class="hljs-number">1</span>);<br><br>    localKey = key;<br>    localResource = engineResource;<br>  &#125;<br><span class="hljs-comment">//上面的engineResource通过这里传出去</span><br>  engineJobListener.onEngineJobComplete(<span class="hljs-built_in">this</span>, localKey, localResource);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ResourceCallbackAndExecutor entry : copy) &#123;<br>    entry.executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallResourceReady</span>(entry.cb));<br>  &#125;<br>  decrementPendingCallbacks();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>engineJobListener</code>是<strong>Engine</strong>类型，去看看他的<code>onEngineJobComplete</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEngineJobComplete</span><span class="hljs-params">(</span><br><span class="hljs-params">    EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource)</span> &#123;<br>  <span class="hljs-comment">// A null resource indicates that the load failed, usually due to an exception.</span><br>  <span class="hljs-keyword">if</span> (resource != <span class="hljs-literal">null</span> &amp;&amp; resource.isMemoryCacheable()) &#123;<br>    activeResources.activate(key, resource);<br>  &#125;<br><br>  jobs.removeIfCurrent(key, engineJob);<br>&#125;<br></code></pre></td></tr></table></figure><p>真相大白了，在这里通过<code>activate</code>把资源存入了<strong>activeResources</strong>，当然这里只是存入了<strong>ActiveResource</strong>，也就是一级缓存内，我们前面介绍了<strong>EngineResource</strong>的<strong>release</strong>方法，当<strong>acquired</strong>为零时，就调用<strong>listener.onResourceReleased</strong>，这里的<strong>listener</strong>其实是<strong>Engine</strong>，进入它的<strong>onResourceReleased</strong>一看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResourceReleased</span><span class="hljs-params">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> &#123;<br>  activeResources.deactivate(cacheKey);<br>  <span class="hljs-keyword">if</span> (resource.isMemoryCacheable()) &#123;<br>      <span class="hljs-comment">//这里的cache其实一个LruResourceCache对象，前面说过，内存缓存用的是`LruCache`算法</span><br>    cache.put(cacheKey, resource);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    resourceRecycler.recycle(resource, <span class="hljs-comment">/*forceNextFrame=*/</span> <span class="hljs-literal">false</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里直接将其放入了内存里面，所以如何将资源放入内存到这里也结束了；下面我们来看缓存的最后一级：</p><h3 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h3><blockquote><p>磁盘缓存是将图片存储到设备本地存储空间，下次使用图片可以直接从本地读取缓存文件，这样可以防止应用从网络上重复下载和读取图片。</p></blockquote><p>磁盘读写也是用的LRU算法。但是这个和内存的LRU算法有一点小区别。为什么呢？因为内存缓存是我们运行的时候，程序加载内存里面的资源，可以直接通过一个<code>LinkedHashMap</code>去实现。但是磁盘不同，我总不可能吧所有磁盘的资源读出来然后加载在内存里面吧，这样的话，肯定会引发oom了。那么Glide是怎么做磁盘的LRU的呢？</p><p>Glide 是使用一个<strong>日志清单文件</strong>来保存这种顺序，<code>DiskLruCache</code> 在 APP 第一次安装时会在缓存文件夹下创建一个 <strong>journal</strong> 日志文件来记录图片的添加、删除、读取等等操作，后面每次打开 APP 都会读取这个文件，把其中记录下来的缓存文件名读取到 <code>LinkedHashMap</code> 中，后面每次对图片的操作不仅是操作这个 <code>LinkedHashMap</code> 还要记录在 journal 文件中. journal 文件内容如下图：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33ce62abbade4f8a814839f9b330280d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"  /><p>开头的 <code>libcore.io.DiskLruCache</code> 是魔数，用来标识文件，后面的三个 1 是版本号 <code>valueCount</code> 等等，再往下就是图片的操作日志了。</p><p>DIRTY、CLEAN 代表操作类型，除了这两个还有 REMOVE 以及READ，紧接着的一长串字符串是文件的 Key，由 <code>SafeKeyGenerator</code> 类生成，是由图片的宽、高、加密解码器等等生成的 SHA-256 散列码后面的数字是图片大小。</p><p>根据这个字符串就可以在同目录下找到对应的图片缓存文件，那么打开缓存文件夹即可看到上面日志中记录的文件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f517dcc87b2d43eda25089298b37f429~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>我们再回到<strong>Engine</strong>的<strong>laod</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> &lt;R&gt; LoadStatus <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-comment">/*省略参数*/</span>)</span> &#123;<br> <br><span class="hljs-comment">//省略代码</span><br>    EngineResource&lt;?&gt; memoryResource;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>      memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);<br><br>      <span class="hljs-keyword">if</span> (memoryResource == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> waitForExistingOrStartNewJob(<br>            glideContext,<br>            model,<br>            signature,<br>            width,<br>            height,<br>            resourceClass,<br>            transcodeClass,<br>            priority,<br>            diskCacheStrategy,<br>            transformations,<br>            isTransformationRequired,<br>            isScaleOnlyOrNoTransform,<br>            options,<br>            isMemoryCacheable,<br>            useUnlimitedSourceExecutorPool,<br>            useAnimationPool,<br>            onlyRetrieveFromCache,<br>            cb,<br>            callbackExecutor,<br>            key,<br>            startTime);<br>      &#125;<br>    &#125;<br><span class="hljs-comment">//省略代码</span><br><br>  &#125;<br></code></pre></td></tr></table></figure><p>这里先从内存中查找资源，要是没有找到，就调用<strong>waitForExistingOrStartNewJob</strong>方法，<strong>waitForExistingOrStartNewJob</strong>方法会调用<strong>engineJob.start()<strong>，这里调用</strong>EngineJob#run</strong>-&gt;<strong>EngineJob#runWrapped</strong>-&gt;<strong>EngineJob#runGenerators</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runGenerators</span><span class="hljs-params">()</span> &#123;<br>  currentThread = Thread.currentThread();<br>  startFetchTime = LogTime.getLogTime();<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">while</span> (!isCancelled<br>      &amp;&amp; currentGenerator != <span class="hljs-literal">null</span><br>      &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;<br>    stage = getNextStage(stage);<br>    currentGenerator = getNextGenerator();<br><br>    <span class="hljs-keyword">if</span> (stage == Stage.SOURCE) &#123;<br>      reschedule();<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里循环调用<strong>startNext</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startNext</span><span class="hljs-params">()</span> &#123;<br><br>  <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//省略代码</span><br>    <span class="hljs-keyword">while</span> (modelLoaders == <span class="hljs-literal">null</span> || !hasNextModelLoader()) &#123;<br>      resourceClassIndex++;<br>      <span class="hljs-keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) &#123;<br>        sourceIdIndex++;<br>        <span class="hljs-keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        resourceClassIndex = <span class="hljs-number">0</span>;<br>      &#125;<br><br>      <span class="hljs-type">Key</span> <span class="hljs-variable">sourceId</span> <span class="hljs-operator">=</span> sourceIds.get(sourceIdIndex);<br>      Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);<br>      Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass);<br>      <span class="hljs-comment">//假设有缓存，那么就需要构建一个ResourceCacheKey</span><br>      currentKey =<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceCacheKey</span>( <br>              helper.getArrayPool(),<br>              sourceId,<br>              helper.getSignature(),<br>              helper.getWidth(),<br>              helper.getHeight(),<br>              transformation,<br>              resourceClass,<br>              helper.getOptions());<br>         <span class="hljs-comment">//从磁盘中找到key对应的文件</span><br>      cacheFile = helper.getDiskCache().get(currentKey);<br>        <span class="hljs-comment">//如果找到对应的文件，那么跳出循环</span><br>      <span class="hljs-keyword">if</span> (cacheFile != <span class="hljs-literal">null</span>) &#123;<br>        sourceKey = sourceId;<br>        modelLoaders = helper.getModelLoaders(cacheFile);<br>        modelLoaderIndex = <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;<br><br>      <span class="hljs-comment">//跳出循环之后就执行到这里来</span><br>    loadData = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;<br>        <br>      ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);<br>      loadData =<br>          modelLoader.buildLoadData(<br>              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());<br>        <br>      <span class="hljs-keyword">if</span> (loadData != <span class="hljs-literal">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;<br>        started = <span class="hljs-literal">true</span>;<br>          <span class="hljs-comment">//这里的loadData.fetcher是DiskLruCacheWrapper，所以get方法最终调用的是DiskLruCacheWrapper的get方法来获取到缓存在磁盘上的资源，这里获取资源的调用和前面讲的方法差不多</span><br>        loadData.fetcher.loadData(helper.getPriority(), <span class="hljs-built_in">this</span>);<br>      &#125;   <br>    &#125;     <br>    <span class="hljs-keyword">return</span> started;      <br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    GlideTrace.endSection();<br>  &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们再来看看</p><h3 id="磁盘写入"><a href="#磁盘写入" class="headerlink" title="磁盘写入"></a>磁盘写入</h3><p>能写入数据到磁盘的时候，当然是在获取到数据之后，获取到数据之后，会第二次调用到<strong>SourceGenerator#startNext</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startNext</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (dataToCache != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> dataToCache;<br>    dataToCache = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//这里调用cacheData，开始存入磁盘</span><br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">isDataInCache</span> <span class="hljs-operator">=</span> cacheData(data);<br>     <br>      <span class="hljs-keyword">if</span> (!isDataInCache) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>      <br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      <br>      <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;Failed to properly rewind or write data to cache&quot;</span>, e);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (sourceCacheGenerator != <span class="hljs-literal">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  sourceCacheGenerator = <span class="hljs-literal">null</span>;<br><br>  loadData = <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;<br>    loadData = helper.getLoadData().get(loadDataListIndex++);<br>    <span class="hljs-keyword">if</span> (loadData != <span class="hljs-literal">null</span><br>        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())<br>            || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;<br>      started = <span class="hljs-literal">true</span>;<br>      startNextLoad(loadData);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> started;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>看看<strong>SourceGenerator#cacheData</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cacheData</span><span class="hljs-params">(Object dataToCache)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> LogTime.getLogTime();<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isLoadingFromSourceData</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//从这里开始存入磁盘</span><br>    DataRewinder&lt;Object&gt; rewinder = helper.getRewinder(dataToCache);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> rewinder.rewindAndGet();<br>    Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(data);<br>    DataCacheWriter&lt;Object&gt; writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataCacheWriter</span>&lt;&gt;(encoder, data, helper.getOptions());<br>    <span class="hljs-type">DataCacheKey</span> <span class="hljs-variable">newOriginalKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataCacheKey</span>(loadData.sourceKey, helper.getSignature());<br>    <span class="hljs-type">DiskCache</span> <span class="hljs-variable">diskCache</span> <span class="hljs-operator">=</span> helper.getDiskCache();<br>    diskCache.put(newOriginalKey, writer);<br>   <br>    <span class="hljs-keyword">if</span> (diskCache.get(newOriginalKey) != <span class="hljs-literal">null</span>) &#123;<br>      originalKey = newOriginalKey;<br>      sourceCacheGenerator =<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataCacheGenerator</span>(Collections.singletonList(loadData.sourceKey), helper, <span class="hljs-built_in">this</span>);<br>      <br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <br><br>      isLoadingFromSourceData = <span class="hljs-literal">true</span>;<br>      cb.onDataFetcherReady(<br>          loadData.sourceKey,<br>          rewinder.rewindAndGet(),<br>          loadData.fetcher,<br>          loadData.fetcher.getDataSource(),<br>          loadData.sourceKey);<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isLoadingFromSourceData) &#123;<br>      loadData.fetcher.cleanup();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一张流程图：</p><p><img src="https://upload-images.jianshu.io/upload_images/6337201-ad1dd311c05f3d4f.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/19/Handler/"/>
    <url>/2022/10/19/Handler/</url>
    
    <content type="html"><![CDATA[<h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><p>我们是基于SDK 31的Handler机制去分析的，可能与以前的博客有略微细节变动，但是大体框架不会变。</p><h2 id="Handler有什么用？"><a href="#Handler有什么用？" class="headerlink" title="Handler有什么用？"></a>Handler有什么用？</h2><p>提到消息机制大家应该都不陌生，在日常开发中不可避免地要涉及这方面的内容。</p><p>当我们在子线程去更新UI的时候，会报错，此时我们需要使用Handler去切换线程到主线程更新UI</p><p>👇如果我们写出这样的代码，会报错</p><p>(tips：为什么我这里先让子线程休息了2秒再去在子线程中更新UI呢？</p><p>这个和安卓系统View的绘制流程有关，具体原理不细说，总之在onResume之前直接在子线程中立刻更新UI不会报错)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br><br>        thread &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>)<br>            textview.text = <span class="hljs-string">&quot;text&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">E/AndroidRuntime: FATAL EXCEPTION: Thread-<span class="hljs-number">2</span><br>    Process: com<span class="hljs-selector-class">.redrock</span><span class="hljs-selector-class">.handler</span>, PID: <span class="hljs-number">4124</span><br>    android<span class="hljs-selector-class">.view</span>.ViewRootImpl<span class="hljs-variable">$CalledFromWrongThreadException</span>: Only the original thread that created <span class="hljs-selector-tag">a</span> view hierarchy can touch its views.<br>        at android<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.ViewRootImpl</span><span class="hljs-selector-class">.checkThread</span>(ViewRootImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">8798</span>)<br>        at android<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.ViewRootImpl</span><span class="hljs-selector-class">.requestLayout</span>(ViewRootImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1606</span>)<br>        at android<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.View</span><span class="hljs-selector-class">.requestLayout</span>(View<span class="hljs-selector-class">.java</span>:<span class="hljs-number">25390</span>)<br>        at android<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.View</span><span class="hljs-selector-class">.requestLayout</span>(View<span class="hljs-selector-class">.java</span>:<span class="hljs-number">25390</span>)<br>        at android<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.View</span><span class="hljs-selector-class">.requestLayout</span>(View<span class="hljs-selector-class">.java</span>:<span class="hljs-number">25390</span>)<br>        at android<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.View</span><span class="hljs-selector-class">.requestLayout</span>(View<span class="hljs-selector-class">.java</span>:<span class="hljs-number">25390</span>)<br>        at android<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.View</span><span class="hljs-selector-class">.requestLayout</span>(View<span class="hljs-selector-class">.java</span>:<span class="hljs-number">25390</span>)<br>        at android<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.View</span><span class="hljs-selector-class">.requestLayout</span>(View<span class="hljs-selector-class">.java</span>:<span class="hljs-number">25390</span>)<br>        at androidx<span class="hljs-selector-class">.constraintlayout</span><span class="hljs-selector-class">.widget</span><span class="hljs-selector-class">.ConstraintLayout</span><span class="hljs-selector-class">.requestLayout</span>(ConstraintLayout<span class="hljs-selector-class">.java</span>:<span class="hljs-number">3593</span>)<br>        at android<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.View</span><span class="hljs-selector-class">.requestLayout</span>(View<span class="hljs-selector-class">.java</span>:<span class="hljs-number">25390</span>)<br>        at android<span class="hljs-selector-class">.widget</span><span class="hljs-selector-class">.TextView</span><span class="hljs-selector-class">.checkForRelayout</span>(TextView<span class="hljs-selector-class">.java</span>:<span class="hljs-number">9719</span>)<br>        at android<span class="hljs-selector-class">.widget</span><span class="hljs-selector-class">.TextView</span><span class="hljs-selector-class">.setText</span>(TextView<span class="hljs-selector-class">.java</span>:<span class="hljs-number">6311</span>)<br>        at android<span class="hljs-selector-class">.widget</span><span class="hljs-selector-class">.TextView</span><span class="hljs-selector-class">.setText</span>(TextView<span class="hljs-selector-class">.java</span>:<span class="hljs-number">6139</span>)<br>        at android<span class="hljs-selector-class">.widget</span><span class="hljs-selector-class">.TextView</span><span class="hljs-selector-class">.setText</span>(TextView<span class="hljs-selector-class">.java</span>:<span class="hljs-number">6091</span>)<br>        at com<span class="hljs-selector-class">.redrock</span><span class="hljs-selector-class">.handler</span>.MainActivity<span class="hljs-variable">$onResume</span>$<span class="hljs-number">1</span><span class="hljs-selector-class">.invoke</span>(MainActivity<span class="hljs-selector-class">.kt</span>:<span class="hljs-number">19</span>)<br>        at com<span class="hljs-selector-class">.redrock</span><span class="hljs-selector-class">.handler</span>.MainActivity<span class="hljs-variable">$onResume</span>$<span class="hljs-number">1</span><span class="hljs-selector-class">.invoke</span>(MainActivity<span class="hljs-selector-class">.kt</span>:<span class="hljs-number">17</span>)<br>        at kotlin<span class="hljs-selector-class">.concurrent</span>.ThreadsKt<span class="hljs-variable">$thread</span><span class="hljs-variable">$thread</span>$<span class="hljs-number">1</span><span class="hljs-selector-class">.run</span>(Thread<span class="hljs-selector-class">.kt</span>:<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p><img src="http://pic.zhongtai521.wang/20220424163240.png" alt="image-20220424163237053"></p><p>所以Handler设计的初衷其实就是为了<strong>跨线程通信</strong>，更具体的说，</p><p>是为了解决<strong>子线程中无法访问UI</strong>的问题</p><p>上面那段在子线程更新UI的代码用Handler改造后的代码长这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler = <span class="hljs-keyword">object</span> : Handler(Looper.getMainLooper()) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>)</span></span> &#123;<br>        <span class="hljs-keyword">when</span> (msg.what) &#123;<br>            <span class="hljs-number">1</span> -&gt; textview.text = msg.obj <span class="hljs-keyword">as</span> String<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setContentView(R.layout.activity_main)<br>&#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onResume()<br><br>    thread &#123;<br>        Thread.sleep(<span class="hljs-number">2000</span>)<br>        <span class="hljs-keyword">val</span> msg = Message.obtain()<br>        msg.what = <span class="hljs-number">1</span>;<br>        msg.obj = <span class="hljs-string">&quot;test&quot;</span><br>        handler.sendMessage(msg)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>👆我这里的代码有内存泄漏的风险，后面在细说</p><h2 id="主流程原理"><a href="#主流程原理" class="headerlink" title="主流程原理"></a>主流程原理</h2><p>带大家回顾了以下相关的基础知识后，我们就来讲Handler的原理</p><p>我们主要是想要搞明白，Handler是怎么做到跨线程通信的，<strong>怎么我在这个子线程用Handler发了条消息，却在主线程去更新了UI呢</strong>？</p><p>这个是我们想要去搞清楚的主要问题，接下来我们就来探索</p><p>Handler发送消息有很多种重载，我们常用的就是sendMessage这个方法，但其实它还有这些用来发送消息的方法</p><p><img src="http://pic.zhongtai521.wang/20220424172846.png" alt="image-20220424172844495"></p><p>sendMessageDelayed是用来发送延时消息的</p><p>通过查看源码，发现不管你调用哪个发送消息的方法，其实最后都会走到<strong>enqueueMessage</strong>这个方法</p><p>以sendMessage为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>    <span class="hljs-comment">//在这里调用了发送延时消息的函数，延时的时间为0</span><br>        <span class="hljs-keyword">return</span> sendMessageDelayed(msg, <span class="hljs-number">0</span>);<br>    &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageDelayed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> delayMillis)</span> &#123;<br>        <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) &#123;<br>            delayMillis = <span class="hljs-number">0</span>;<br>        &#125;<br>     <span class="hljs-comment">//这个函数的时间参数指明执行消息的时间，所以是当前时间+延时的时间</span><br>        <span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);<br>    &#125;<br><br><span class="hljs-comment">//在这里拿到了一个消息队列MessageQueue，然后调用了enqueueMessage方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageAtTime</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>        <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> mQueue;<br>        <span class="hljs-keyword">if</span> (queue == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                    <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);<br>            Log.w(<span class="hljs-string">&quot;Looper&quot;</span>, e.getMessage(), e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,</span><br><span class="hljs-params">            <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>        msg.target = <span class="hljs-built_in">this</span>;<br>        msg.workSourceUid = ThreadLocalWorkSource.getUid();<br><br>        <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>            msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>    &#125;<br></code></pre></td></tr></table></figure><p>因此，接下来我们重点来看这个enqueueMessage做了什么</p><p>注意，我们看源码时一定要避免只见树木不见森林，对于一个迭代了很久的框架来说，里面会有很多的细节，我们在第一次读源码时注意只弄懂关键流程，那些细分分支可以在弄懂主流程之后再来弄懂，那么问题来了，我自己看源码怎么去知道哪些是主流程的代码，哪些是细分的代码呢？我的看法要么你是个Android老手，靠着经验可以知道，要么就是去参考别人，所以接下来我会先带着大家走一遍主流程再来看那些细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,</span><br><span class="hljs-params">        <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>    <span class="hljs-comment">//msg里面有一个target字段，类型是Handler</span><br>    <span class="hljs-comment">//因此这里把发送消息的那个Handler给保存在了msg里</span><br>    msg.target = <span class="hljs-built_in">this</span>;<br>    msg.workSourceUid = ThreadLocalWorkSource.getUid();<br><br>   <span class="hljs-comment">//这里是细节 后面再来看</span><br>    <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>        msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此接下来分析</p><p>queue.enqueueMessage(msg, uptimeMillis);</p><p>这里的代码很多，我们慢慢来分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>    <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-type">IllegalStateException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>            Log.w(TAG, e.getMessage(), e);<br>            msg.recycle();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        msg.markInUse();<br>        msg.when = when;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>        <span class="hljs-type">boolean</span> needWake;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            <span class="hljs-comment">// New head, wake up the event queue if blocked.</span><br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span><br>            <span class="hljs-comment">// up the event queue unless there is a barrier at the head of the queue</span><br>            <span class="hljs-comment">// and the message is the earliest asynchronous message in the queue.</span><br>            needWake = mBlocked &amp;&amp; p.target == <span class="hljs-literal">null</span> &amp;&amp; msg.isAsynchronous();<br>            Message prev;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                    needWake = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>            prev.next = msg;<br>        &#125;<br><br>        <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我把一些为了保证系统稳健性判空的代码以及不是主流程的代码删掉后只保留主流程的代码，可能更好看懂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//这些是主流程的代码</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>    <span class="hljs-comment">//首先将消息应该去执行的时间保存在了消息中</span><br>            msg.when = when;<br>    <span class="hljs-comment">//然后拿到了mMessages并赋值给p</span><br>    <span class="hljs-comment">//那么什么是mMessages呢？</span><br>    <span class="hljs-comment">//MessageQueue会把所有的消息通过链表的形式按照时间顺序存储起来</span><br>    <span class="hljs-comment">//mMessages是这个链表的头节点，执行时间越早的msg在这条链表上会被放在越前面的位置</span><br>    <span class="hljs-comment">//所以下面的这些逻辑就是找到链表的头节点，然后按照时间顺序把消息插入到这个链表里面去</span><br>            <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>    <span class="hljs-comment">//如果链表里面还没有节点 || 这个消息需要立即执行 || 消息需要执行的之间比链表第一个节点的时间还要小</span><br>    <span class="hljs-comment">//如果满足以上三个条件就直接让这条消息当头节点</span><br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>                msg.next = p;<br>                mMessages = msg;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果不满足的话，就到链表里去找到执行时间比这条消息还要靠后的节点，然后插入在它的前面</span><br>                Message prev;<br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    prev = p;<br>                    p = p.next;<br>                    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                msg.next = p; <br>                prev.next = msg;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="http://pic.zhongtai521.wang/20220424175028.png" alt="image-20220424175027080"></p><p>👆链表示意图</p><p>👇插入消息的流程图</p><img src="http://pic.zhongtai521.wang/20220424180440.png" alt="image-20220424180438396" style="zoom:50%;" /><p>现在我们已经知道了我们发送的消息最终会被存放到MessageQueue这样一个<strong>以时间顺序存储消息</strong>的数据结构里面，那么有存就有取嘛</p><p>是谁负责从MessageQueue里面取消息然后去执行的呢？是<strong>Looper</strong></p><p>Looper是个啥玩意？理论上来说如果需要使用Handler传递某个消息到某个线程的话，这个线程是必须要有一个Looper的</p><p>假如我们直接在子线程中使用在子线程构造的handler发送消息的话，就会报错</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">thread &#123;<br>    <span class="hljs-keyword">val</span> handler = Handler();<br>    handler.sendEmptyMessage(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E</span>/AndroidRuntime: FATAL EXCEPTION: Thread-<span class="hljs-number">3</span><br>    <span class="hljs-attribute">Process</span>: com.redrock.handler, PID: <span class="hljs-number">4685</span><br>    <span class="hljs-attribute">java</span>.lang.RuntimeException: Can&#x27;t create handler inside thread Thread[Thread-<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,main] that has not called Looper.prepare()<br>        <span class="hljs-attribute">at</span> android.os.Handler.&lt;init&gt;(Handler.java:<span class="hljs-number">227</span>)<br>        <span class="hljs-attribute">at</span> android.os.Handler.&lt;init&gt;(Handler.java:<span class="hljs-number">129</span>)<br>        <span class="hljs-attribute">at</span> com.redrock.handler.MainActivity$onResume$<span class="hljs-number">2</span>.invoke(MainActivity.kt:<span class="hljs-number">40</span>)<br>        <span class="hljs-attribute">at</span> com.redrock.handler.MainActivity$onResume$<span class="hljs-number">2</span>.invoke(MainActivity.kt:<span class="hljs-number">39</span>)<br>        <span class="hljs-attribute">at</span> kotlin.concurrent.ThreadsKt$thread$thread$<span class="hljs-number">1</span>.run(Thread.kt:<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>要去修改为这样才不会报错</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">thread &#123;<br>    Looper.prepare()<br>    <span class="hljs-keyword">val</span> handler = Handler(Looper.myLooper()!!);<br>    Looper.loop()<br>    handler.sendEmptyMessage(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那在这里我需要传递一个消息到主线程并且没有在主线程里去调用Looper.prepare() Looper.loop()</p><p>为什么没有报错呢？其实在app启动的时候Android已经帮我们在主线程中调用了这俩个函数</p><p>👇安卓主线程 ActivityThread的main函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;ActivityThreadMain&quot;</span>);<br><br>    <span class="hljs-comment">// Install selective syscall interception</span><br>    AndroidOs.install();<br><br>    <span class="hljs-comment">// CloseGuard defaults to true and can be quite spammy.  We</span><br>    <span class="hljs-comment">// disable it here, but selectively enable it later (via</span><br>    <span class="hljs-comment">// StrictMode) on debug builds, but using DropBox, not logs.</span><br>    CloseGuard.setEnabled(<span class="hljs-literal">false</span>);<br><br>    Environment.initForCurrentUser();<br><br>    <span class="hljs-comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">configDir</span> <span class="hljs-operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());<br>    TrustedCertificateStore.setDefaultUserDirectory(configDir);<br><br>    <span class="hljs-comment">// Call per-process mainline module initialization.</span><br>    initializeMainlineModules();<br><br>    Process.setArgV0(<span class="hljs-string">&quot;&lt;pre-initialized&gt;&quot;</span>);<br><br>    Looper.prepareMainLooper();<br><br>    <span class="hljs-comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span><br>    <span class="hljs-comment">// It will be in the format &quot;seq=114&quot;</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">startSeq</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> args.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (args[i] != <span class="hljs-literal">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;<br>                startSeq = Long.parseLong(<br>                        args[i].substring(PROC_START_SEQ_IDENT.length()));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>    thread.attach(<span class="hljs-literal">false</span>, startSeq);<br><br>    <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>        sMainThreadHandler = thread.getHandler();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        Looper.myLooper().setMessageLogging(<span class="hljs-keyword">new</span><br>                <span class="hljs-title class_">LogPrinter</span>(Log.DEBUG, <span class="hljs-string">&quot;ActivityThread&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// End of event ActivityThreadMain.</span><br>    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>    Looper.loop();<br><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>说了这么多Looper的注意事项，那Looper到底是干嘛的呢？</p><p>Looper会不停的从MessageQueue中查看是否有需要执行的消息，如果有就拿出来分发给对应的Handler处理</p><p>在Looper里面，有一个next函数，这个函数中有一个死循环会不断的尝试从MessageQueue中取消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();<br>    <span class="hljs-keyword">if</span> (me == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (me.mInLoop) &#123;<br>        Slog.w(TAG, <span class="hljs-string">&quot;Loop again would have the queued messages be executed&quot;</span><br>                + <span class="hljs-string">&quot; before this one completed.&quot;</span>);<br>    &#125;<br><br>    me.mInLoop = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// Make sure the identity of this thread is that of the local process,</span><br>    <span class="hljs-comment">// and keep track of what that identity token actually is.</span><br>    Binder.clearCallingIdentity();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ident</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br><br>    <span class="hljs-comment">// Allow overriding a threshold with a system prop. e.g.</span><br>    <span class="hljs-comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">thresholdOverride</span> <span class="hljs-operator">=</span><br>            SystemProperties.getInt(<span class="hljs-string">&quot;log.looper.&quot;</span><br>                    + Process.myUid() + <span class="hljs-string">&quot;.&quot;</span><br>                    + Thread.currentThread().getName()<br>                    + <span class="hljs-string">&quot;.slow&quot;</span>, <span class="hljs-number">0</span>);<br><br>    me.mSlowDeliveryDetected = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">loopOnce</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Looper me,</span><br><span class="hljs-params">        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> thresholdOverride)</span> &#123;<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> me.mQueue.next(); <span class="hljs-comment">// might block</span><br>    <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// No message indicates that the message queue is quitting.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// This must be in a local variable, in case a UI event sets the logger</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Printer</span> <span class="hljs-variable">logging</span> <span class="hljs-operator">=</span> me.mLogging;<br>    <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;<br>        logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span><br>                + msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>    &#125;<br>    <span class="hljs-comment">// Make sure the observer won&#x27;t change while processing a transaction.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Observer</span> <span class="hljs-variable">observer</span> <span class="hljs-operator">=</span> sObserver;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">traceTag</span> <span class="hljs-operator">=</span> me.mTraceTag;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">slowDispatchThresholdMs</span> <span class="hljs-operator">=</span> me.mSlowDispatchThresholdMs;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">slowDeliveryThresholdMs</span> <span class="hljs-operator">=</span> me.mSlowDeliveryThresholdMs;<br>    <span class="hljs-keyword">if</span> (thresholdOverride &gt; <span class="hljs-number">0</span>) &#123;<br>        slowDispatchThresholdMs = thresholdOverride;<br>        slowDeliveryThresholdMs = thresholdOverride;<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">logSlowDelivery</span> <span class="hljs-operator">=</span> (slowDeliveryThresholdMs &gt; <span class="hljs-number">0</span>) &amp;&amp; (msg.when &gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">logSlowDispatch</span> <span class="hljs-operator">=</span> (slowDispatchThresholdMs &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">needStartTime</span> <span class="hljs-operator">=</span> logSlowDelivery || logSlowDispatch;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">needEndTime</span> <span class="hljs-operator">=</span> logSlowDispatch;<br><br>    <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;<br>        Trace.traceBegin(traceTag, msg.target.getTraceName(msg));<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">dispatchStart</span> <span class="hljs-operator">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> dispatchEnd;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>        token = observer.messageDispatchStarting();<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">origWorkSource</span> <span class="hljs-operator">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);<br>    <span class="hljs-keyword">try</span> &#123;<br>        msg.target.dispatchMessage(msg);<br>        <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>            observer.messageDispatched(token, msg);<br>        &#125;<br>        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception exception) &#123;<br>        <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>            observer.dispatchingThrewException(token, msg, exception);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> exception;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ThreadLocalWorkSource.restore(origWorkSource);<br>        <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;<br>            Trace.traceEnd(traceTag);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (logSlowDelivery) &#123;<br>        <span class="hljs-keyword">if</span> (me.mSlowDeliveryDetected) &#123;<br>            <span class="hljs-keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="hljs-number">10</span>) &#123;<br>                Slog.w(TAG, <span class="hljs-string">&quot;Drained&quot;</span>);<br>                me.mSlowDeliveryDetected = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="hljs-string">&quot;delivery&quot;</span>,<br>                    msg)) &#123;<br>                <span class="hljs-comment">// Once we write a slow delivery log, suppress until the queue drains.</span><br>                me.mSlowDeliveryDetected = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (logSlowDispatch) &#123;<br>        showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="hljs-string">&quot;dispatch&quot;</span>, msg);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;<br>        logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);<br>    &#125;<br><br>    <span class="hljs-comment">// Make sure that during the course of dispatching the</span><br>    <span class="hljs-comment">// identity of the thread wasn&#x27;t corrupted.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">newIdent</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>    <span class="hljs-keyword">if</span> (ident != newIdent) &#123;<br>        Log.wtf(TAG, <span class="hljs-string">&quot;Thread identity changed from 0x&quot;</span><br>                + Long.toHexString(ident) + <span class="hljs-string">&quot; to 0x&quot;</span><br>                + Long.toHexString(newIdent) + <span class="hljs-string">&quot; while dispatching to &quot;</span><br>                + msg.target.getClass().getName() + <span class="hljs-string">&quot; &quot;</span><br>                + msg.callback + <span class="hljs-string">&quot; what=&quot;</span> + msg.what);<br>    &#125;<br><br>    msg.recycleUnchecked();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只看关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//首先拿到当前线程的Looper</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">loopOnce</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Looper me,</span><br><span class="hljs-params">        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> thresholdOverride)</span> &#123;<br>    <span class="hljs-comment">//死循环不断从MessageQueue中取消息，如果取不到消息就阻塞住一直到取到了消息</span><br>    <span class="hljs-comment">//这个next函数是怎么从MessageQueue中取消息的我们等下分析</span><br>    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> me.mQueue.next();<br>    <br>    <span class="hljs-comment">//还记得我们在发送消息时会把发送这个消息的Handler给保存在msg的target字段中吗？</span><br>    <span class="hljs-comment">//接下来会调这个handler的dispatchMessage函数并且把消息分发给它</span><br>    <span class="hljs-comment">//dispatchMessage函数是不是很熟悉？没错，这就是我们重写Handler时的那个函数</span><br>    msg.target.dispatchMessage(msg);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler = <span class="hljs-keyword">object</span> : Handler(Looper.getMainLooper()) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>)</span></span> &#123;<br>        <span class="hljs-keyword">when</span> (msg.what) &#123;<br>            <span class="hljs-number">1</span> -&gt; textview.text = msg.obj <span class="hljs-keyword">as</span> String<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，皆大欢喜，我们终于把主线流程给走完了，知道了从一个消息被发送到这个消息被分发给Handler的流程</p><p>我们来捋一下这个流程</p><p>首先，我们通过在子线程中使用Handler发送了一条消息，然后这条消息会被插入在MessageQueue中，并且这条消息会有一个target字段指明发送这条消息的Handler，然后looper会不断的从这个messageQueue中取消息再分发给对应的handler从而实现了跨线程通信。</p><p>是在什么时候实现的跨线程呢？每一个线程如果要处理跨线程的消息就要有一个自己的Looper和MessageQueue，以主线程为例，Android底层已经帮我们创建好了主线程的Looper和MessageQueue，我们要从子线程发送一条消息给主线程，就是把这条消息给插入到了主线程的MessageQueue中，然后主线程的Looper再从MessageQueue中取出消息分发给对应的Handler去处理。</p><p>我们接下看一下Looper是怎么从MessageQueue中取到消息的，看到MessageQueue的next函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Return here if the message loop has already quit and been disposed.</span><br>    <span class="hljs-comment">// This can happen if the application tries to restart a looper after quit</span><br>    <span class="hljs-comment">// which is not supported.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> mPtr;<br>    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pendingIdleHandlerCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;<br>            Binder.flushPendingCommands();<br>        &#125;<br><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    prevMsg = msg;<br>                    msg = msg.next;<br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Got a message.</span><br>                    mBlocked = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                    &#125;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>                    msg.markInUse();<br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// No more messages.</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Process the quit message now that all pending messages have been handled.</span><br>            <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                dispose();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// If first time idle, then get the number of idlers to run.</span><br>            <span class="hljs-comment">// Idle handles only run if the queue is empty or if the first message</span><br>            <span class="hljs-comment">// in the queue (possibly a barrier) is due to be handled in the future.</span><br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span><br>                    &amp;&amp; (mMessages == <span class="hljs-literal">null</span> || now &lt; mMessages.when)) &#123;<br>                pendingIdleHandlerCount = mIdleHandlers.size();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// No idle handlers to run.  Loop and wait some more.</span><br>                mBlocked = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-literal">null</span>) &#123;<br>                mPendingIdleHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];<br>            &#125;<br>            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);<br>        &#125;<br><br>        <span class="hljs-comment">// Run the idle handlers.</span><br>        <span class="hljs-comment">// We only ever reach this code block during the first iteration.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IdleHandler</span> <span class="hljs-variable">idler</span> <span class="hljs-operator">=</span> mPendingIdleHandlers[i];<br>            mPendingIdleHandlers[i] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// release the reference to the handler</span><br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">keep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                keep = idler.queueIdle();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (!keep) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    mIdleHandlers.remove(idler);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Reset the idle handler count to 0 so we do not run them again.</span><br>        pendingIdleHandlerCount = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// While calling an idle handler, a new message could have been delivered</span><br>        <span class="hljs-comment">// so go back and look again for a pending message without waiting.</span><br>        nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主流程代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">//如果暂时没有消息，就先阻塞住，会等到插入新消息的时候唤醒</span><br>            <span class="hljs-comment">//或者有消息，但是链表的头节点的那条消息还要等待一段时间才要执行</span><br>            <span class="hljs-comment">//那就计算出这个时间，然后阻塞这么长一个时间</span><br>            nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>                <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>                <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                        <span class="hljs-comment">//最近的那条要执行的消息的执行时间都要晚于当前的时间，那就计算出这个时间差值，然后阻塞</span><br>                        nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">//不是的话，就取出消息并返回</span><br>                        mBlocked = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                            prevMsg.next = msg.next;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            mMessages = msg.next;<br>                        &#125;<br>                        msg.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">return</span> msg;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>                &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>        msg.when = when;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>        <span class="hljs-type">boolean</span> needWake;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果没有被阻塞住，或者消息的targer Handler为null 以及消息是异步消息就不需要被唤醒</span><br>            <span class="hljs-comment">//关于如果没有被阻塞住就不需要就唤醒很容易理解</span><br>            <span class="hljs-comment">//至于后面俩个我们后面再来解释</span><br>            needWake = mBlocked &amp;&amp; p.target == <span class="hljs-literal">null</span> &amp;&amp; msg.isAsynchronous();<br>            Message prev;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                    needWake = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>            prev.next = msg;<br>        &#125;<br><br>        <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            <span class="hljs-comment">//唤醒</span><br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="细节流程原理"><a href="#细节流程原理" class="headerlink" title="细节流程原理"></a>细节流程原理</h2><p>讲完了主流程，我们接下来讲分支流程</p><h3 id="Message-obtain"><a href="#Message-obtain" class="headerlink" title="Message.obtain"></a>Message.obtain</h3><p>不知道大家注意到没，我在获取一个消息实例的时候，并不是去new 而是通过Message.obtain()去获取消息，这样做有什么好处呢？</p><p>因为新建和销毁一个Message对象存在性能损耗，所以Handler就希望一个消息实例在new出来后，使用完后把里面的相关信息全部清除掉，然后可以复用这个消息实例</p><p>当我们使用Message.obtain()时，会先去尝试是否能复用一个已经创建的消息实例，如果获取不到，才会去new一个，然后在每个消息执行完后，就会把这个消息的相关信息清除然后缓存起来</p><p>我们来看看相关源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message sPool;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title function_">obtain</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>            <span class="hljs-keyword">if</span> (sPool != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> sPool;<br>                sPool = m.next;<br>                m.next = <span class="hljs-literal">null</span>;<br>                m.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// clear in-use flag</span><br>                sPoolSize--;<br>                <span class="hljs-keyword">return</span> m;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到,这里会先拿到一个sPool，然后从sPoll中拿到一个消息实例，然后再把spoll给指到下一个</p><p>那这个spoll是个什么东西呢？</p><p>它就是一个消息实例，其实这里就是把所有等待复用的消息实例给通过链表的形式组织了起来，然后sPoll就是这个链表的头节点</p><p>在Looper的LoopOnce里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">loopOnce</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Looper me,</span><br><span class="hljs-params">        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> thresholdOverride)</span> &#123;<br>    <br>    msg.target.dispatchMessage(msg);<br><br>    msg.recycleUnchecked();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在消息执行完后，会调用msg.recycleUnchecked();</p><p>会在这里面清除掉msg的详细信息然后插入到sPoll中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">recycleUnchecked</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Mark the message as in use while it remains in the recycled object pool.</span><br>    <span class="hljs-comment">// Clear out all other details.</span><br>    flags = FLAG_IN_USE;<br>    what = <span class="hljs-number">0</span>;<br>    arg1 = <span class="hljs-number">0</span>;<br>    arg2 = <span class="hljs-number">0</span>;<br>    obj = <span class="hljs-literal">null</span>;<br>    replyTo = <span class="hljs-literal">null</span>;<br>    sendingUid = UID_NONE;<br>    workSourceUid = UID_NONE;<br>    when = <span class="hljs-number">0</span>;<br>    target = <span class="hljs-literal">null</span>;<br>    callback = <span class="hljs-literal">null</span>;<br>    data = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>        <span class="hljs-keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;<br>            next = sPool;<br>            sPool = <span class="hljs-built_in">this</span>;<br>            sPoolSize++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>我们之前说了,如果在子线程中要去使用handler是要去给子线程手动配置Looper的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">thread &#123;<br>    Looper.prepare()<br>    <span class="hljs-keyword">val</span> handler = Handler(Looper.myLooper()!!);<br>    <span class="hljs-comment">//开启Looper的消息循环，开始从这个线程的MessageQueue中取数据分发到对应的Handler</span><br>    Looper.loop()<br>    handler.sendEmptyMessage(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看Looper.prepare()干了些什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Looper&gt;(); <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">()</span> &#123;<br>       prepare(<span class="hljs-literal">true</span>);<br>   &#125;<br><br><span class="hljs-comment">//这个quitAllowed参数我们先忽略不讲 后面再提</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>       <span class="hljs-comment">//一个线程只能有一个Looper，否则就会报错</span><br>       <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>       &#125;<br>       sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>   &#125;<br></code></pre></td></tr></table></figure><p>可以看到把new 出来的Looper放到了ThreadLocal类型的静态变量sThreadLocal里面</p><p>在继续跟进ThreadLocal的源码前，我们首先大概介绍下ThreadLocal，防止在看ThreadLocal源码时迷了路</p><p><strong>ThreadLocal是一个以线程为作用域存储数据的一个类</strong>，什么叫以线程为作用域？就是说对于同一个ThreadLocal变量，不同的线程从里面去取数据能取到不同的值，就比如A线程在这个sThreadLocal里面存了A线程的Looper，B线程在这个sThreadLocal里面也存了B线程的Looper，然后A线程去和这个sThreadLocal说，我要取Looper出来，sThreadLocal会把A线程的Looper取出来，而不会取到B线程的Looper，B线程同理.构造这个ThreadLocal里面的泛型的实际类型就表明了这个ThreadLocal希望为线程存储什么类型的数据。</p><p>好的，接下来我们来看看原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets the current thread&#x27;s copy of this thread-local variable</span><br><span class="hljs-comment"> * to the specified value.  Most subclasses will have no need to</span><br><span class="hljs-comment"> * override this method, relying solely on the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125;</span><br><span class="hljs-comment"> * method to set the values of thread-locals.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span><br><span class="hljs-comment"> *        this thread-local.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">//首先拿到了当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//然后从当前线程中拿到了一个ThreadLocalMap的这样一个变量</span><br>    <span class="hljs-comment">//每一个线程都会有一个ThreadLocalMap变量</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">//如果Thread里面的ThreadLocalMap还没有初始化，就先初始化再存放值，否则就直接存放值</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="hljs-comment">     * by the ThreadLocal class. */</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br><br>            <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span><br>            <span class="hljs-comment">// least as common to use set() to create new entries as</span><br>            <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span><br>            <span class="hljs-comment">// path would fail more often than not.</span><br><br>            Entry[] tab = table;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>                 e != <span class="hljs-literal">null</span>;<br>                 e = tab[i = nextIndex(i, len)]) &#123;<br>                ThreadLocal&lt;?&gt; k = e.get();<br><br>                <span class="hljs-keyword">if</span> (k == key) &#123;<br>                    e.value = value;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                    replaceStaleEntry(key, value, i);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br><br>            tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>            <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>                rehash();<br>        &#125;<br></code></pre></td></tr></table></figure><p>总结一下：</p><p>ThreadLocal中有一个ThreadLocalMap变量，这个变量存储着键值对形式的数据。</p><ul><li>key为this，也就是当前ThreadLocal变量。</li><li>value为T，也就是要存储的值。</li></ul><p>每个线程中都有一个ThreadLocalMap,这样带来的好处就是，在不同的线程，访问同一个ThreadLocal对象，但是能获取到的值却不一样。</p><h3 id="quit"><a href="#quit" class="headerlink" title="quit"></a>quit</h3><p>在分析Looper和MessageQueue时说道，Looper一但开始消息循环就会不断死循环从MessageQueue里面去取消息，如果取不到消息就暂时阻塞住直到可以取到消息为止，那么有没有办法停止这个死循环呢？有的，可以调用Looper的quit方法停止消息循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Quits the looper.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * Causes the &#123;<span class="hljs-doctag">@link</span> #loop&#125; method to terminate without processing any</span><br><span class="hljs-comment"> * more messages in the message queue.</span><br><span class="hljs-comment"> * &lt;/p&gt;&lt;p&gt;</span><br><span class="hljs-comment"> * Any attempt to post messages to the queue after the looper is asked to quit will fail.</span><br><span class="hljs-comment"> * For example, the &#123;<span class="hljs-doctag">@link</span> Handler#sendMessage(Message)&#125; method will return false.</span><br><span class="hljs-comment"> * &lt;/p&gt;&lt;p class=&quot;note&quot;&gt;</span><br><span class="hljs-comment"> * Using this method may be unsafe because some messages may not be delivered</span><br><span class="hljs-comment"> * before the looper terminates.  Consider using &#123;<span class="hljs-doctag">@link</span> #quitSafely&#125; instead to ensure</span><br><span class="hljs-comment"> * that all pending work is completed in an orderly manner.</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #quitSafely</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quit</span><span class="hljs-params">()</span> &#123;<br>    mQueue.quit(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Quits the looper safely.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * Causes the &#123;<span class="hljs-doctag">@link</span> #loop&#125; method to terminate as soon as all remaining messages</span><br><span class="hljs-comment"> * in the message queue that are already due to be delivered have been handled.</span><br><span class="hljs-comment"> * However pending delayed messages with due times in the future will not be</span><br><span class="hljs-comment"> * delivered before the loop terminates.</span><br><span class="hljs-comment"> * &lt;/p&gt;&lt;p&gt;</span><br><span class="hljs-comment"> * Any attempt to post messages to the queue after the looper is asked to quit will fail.</span><br><span class="hljs-comment"> * For example, the &#123;<span class="hljs-doctag">@link</span> Handler#sendMessage(Message)&#125; method will return false.</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quitSafely</span><span class="hljs-params">()</span> &#123;<br>    mQueue.quit(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到有俩种方法，一种是直接quit，不管有没有正在执行的消息都直接退出，还有一种是有正在执行等待分发的任务先给分发完，延时的消息就不处理了，我们选其中一种进行分析</p><p>可以看到最终都是调用到了MessageQueue的quit方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">quit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> safe)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mQuitAllowed) &#123;<br>        <span class="hljs-comment">//如果退出主线程的Looper直接抛出异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Main thread not allowed to quit.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">//如果正在退出，返回</span><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//将正在退出的标志位设置为true</span><br>        mQuitting = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span> (safe) &#123;<br>            removeAllFutureMessagesLocked();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            removeAllMessagesLocked();<br>        &#125;<br><br>        <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting was previously false.</span><br>        nativeWake(mPtr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAllMessagesLocked</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> p.next;<br>        p.recycleUnchecked();<br>        p = n;<br>    &#125;<br>    mMessages = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里就是拿到了消息队列的头节点，然后一个一个调用去回收这个消息</p><p>大家可以尝试自己去分析一下removeAllFutureMessagesLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAllFutureMessagesLocked</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (p.when &gt; now) &#123;<br>            removeAllMessagesLocked();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Message n;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                n = p.next;<br>                <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (n.when &gt; now) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                p = n;<br>            &#125;<br>            p.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">do</span> &#123;<br>                p = n;<br>                n = p.next;<br>                p.recycleUnchecked();<br>            &#125; <span class="hljs-keyword">while</span> (n != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来说说把这个mQuitting标志位设置为true会造成什么连锁反应</p><p>1.如果正在退出，尝试往MessageQueue中插入数据会失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>    <span class="hljs-comment">//如果mQuitting为true 会直接返回false</span><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-type">IllegalStateException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                    msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>            Log.w(TAG, e.getMessage(), e);<br>            msg.recycle();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        msg.markInUse();<br>        msg.when = when;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>        <span class="hljs-type">boolean</span> needWake;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            needWake = mBlocked &amp;&amp; p.target == <span class="hljs-literal">null</span> &amp;&amp; msg.isAsynchronous();<br>            Message prev;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                    needWake = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>            prev.next = msg;<br>        &#125;<br><br>        <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.Looper中的死循环会退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">loopOnce</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Looper me,<span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> thresholdOverride)</span> &#123;<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> me.mQueue.next(); <br>    <span class="hljs-comment">//可以看到Looper中的死循环会在MessageQueue返回msg为null时就退出</span><br>    <span class="hljs-comment">//正常情况下如果不去调用quit方法，Looper是一定可以从MessageQueue中取到消息的，就算暂时取不到消息，也会阻塞住等待有消息再取出来并返回</span><br>    <span class="hljs-comment">//但是调用了quit方法后，MessageQueue就会返回null</span><br>    <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br><br>        msg.target.dispatchMessage(msg);<br><br><br>    msg.recycleUnchecked();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> mPtr;<br>    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    prevMsg = msg;<br>                    msg = msg.next;<br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    mBlocked = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                    &#125;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>                    msg.markInUse();<br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Process the quit message now that all pending messages have been handled.</span><br>            <span class="hljs-comment">//看这里</span><br>            <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                dispose();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异步消息和同步屏障"><a href="#异步消息和同步屏障" class="headerlink" title="异步消息和同步屏障"></a>异步消息和同步屏障</h3><p>啥子是异步消息和同步屏障？</p><p>在Handler中，有三种消息类型：</p><p><strong>同步消息</strong>。也就是普通的消息。</p><p><strong>异步消息</strong>。通过setAsynchronous(true)设置的消息（API &gt;&#x3D; 22）或者是async参数设置为true的handler发送的消息</p><p><strong>同步屏障消息</strong>。通过postSyncBarrier()方法添加的消息，特点是target为空，也就是没有对应的handler。</p><p>这三者之间的关系如何呢？</p><ul><li>正常情况下，同步消息和异步消息都是正常被处理，也就是根据时间when来取消息，处理消息。</li><li>当遇到同步屏障消息的时候，就开始从消息队列里面去找异步消息，找到了再根据时间决定阻塞还是返回消息。</li></ul><p>也就是说同步屏障消息不会被返回，他只是一个标志，一个工具，遇到它就代表要去先行处理异步消息了。</p><p>所以同步屏障和异步消息的存在的意义就在于有些消息需要“加急处理”。</p><p>我们来看看相关的源码</p><p>首先看看同步屏障</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">postSyncBarrier</span><span class="hljs-params">(<span class="hljs-type">long</span> when)</span> &#123;<br>    <span class="hljs-comment">// Enqueue a new sync barrier token.</span><br>    <span class="hljs-comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> mNextBarrierToken++;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain();<br>        msg.markInUse();<br>        msg.when = when;<br>        msg.arg1 = token;<br><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>        <span class="hljs-keyword">if</span> (when != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; p.when &lt;= when) &#123;<br>                prev = p;<br>                p = p.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// invariant: p == prev.next</span><br>            msg.next = p;<br>            prev.next = msg;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            msg.next = p;<br>            mMessages = msg;<br>        &#125;<br>        <span class="hljs-keyword">return</span> token;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面的逻辑没啥好说的，就是和之前在MessageQueue中去按照时间顺序去插入消息是一样的</p><p>接下来看到从MessageQueue中取消息时遇到了同步屏障消息和异步消失是怎么处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>    <span class="hljs-comment">//这个if判断表明遇到了同步屏障消息，因为同步屏障消息的target字段为空</span><br>    <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>        <span class="hljs-comment">//这一段循环结束的条件是 msg == null（表明找不到异步消息） 或者是msg是异步消息</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            prevMsg = msg;<br>            msg = msg.next;<br>        &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>            <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>            nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Got a message.</span><br>            mBlocked = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                prevMsg.next = msg.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mMessages = msg.next;<br>            &#125;<br>            msg.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>            msg.markInUse();<br>            <span class="hljs-keyword">return</span> msg;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// No more messages.</span><br>        nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Process the quit message now that all pending messages have been handled.</span><br>    <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>        dispose();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，如果当前Message是没有target的，就代表达到了当前的MessageQueue的同步消息屏障，队列会不断向后查询，同步消息将会被掠过，直到队列中出现了一个非同步消息或者消息队列已经为空，即将next的逻辑变为:弹出下一个异步消息。整体逻辑可以描述为:如果队列没有遍历到同步消息屏障，则正常按照时间弹出队首，如果遇到同步屏障，则只处理异步消息。就如同下图所示</p><p><img src="http://pic.zhongtai521.wang/20220424225711.png" alt="image-20220424225708977"></p><p>那么怎样清除同步消息队列呢？调用 removeSyncBarrier() 即可</p><h3 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h3><p>最后来看看IdleHandler</p><p>首先来看看IdleHandler是啥？</p><p>我们之前说当MessageQueue没有消息的时候，就会阻塞在next方法中，其实在阻塞之前，MessageQueue还会做一件事，就是检查是否存在IdleHandler，如果有，就会去执行它的queueIdle方法。</p><p>因此IdleHandler就是当消息队列里面没有当前要处理的消息了，需要堵塞之前，可以做一些空闲任务的处理。</p><p>我们可以使用IdleHandler去执行一些当系统空闲时才需要去执行的低优先级任务</p><p>可以通过如下方式加入一个IdleHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Looper.myQueue().addIdleHandler &#123;<br>    ...<br>    ...<br>    <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>返回false，表示执行完成后从MessageQueue中移除掉自己</p><p>来看看相关源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Return here if the message loop has already quit and been disposed.</span><br>    <span class="hljs-comment">// This can happen if the application tries to restart a looper after quit</span><br>    <span class="hljs-comment">// which is not supported.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> mPtr;<br>    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//IdleHandler的数量 初始化值为0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pendingIdleHandlerCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;<br>            Binder.flushPendingCommands();<br>        &#125;<br><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    prevMsg = msg;<br>                    msg = msg.next;<br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Got a message.</span><br>                    mBlocked = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                    &#125;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>                    msg.markInUse();<br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// No more messages.</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Process the quit message now that all pending messages have been handled.</span><br>            <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                dispose();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// If first time idle, then get the number of idlers to run.</span><br>            <span class="hljs-comment">// Idle handles only run if the queue is empty or if the first message</span><br>            <span class="hljs-comment">// in the queue (possibly a barrier) is due to be handled in the future.</span><br>            <br>            <span class="hljs-comment">//pendingIdleHandlerCount只有在初始化的时候会是负数，那么当此时没有消息可以处理的时候，就会去初始化</span><br>            <span class="hljs-comment">//pendingIdleHandlerCount</span><br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span><br>                    &amp;&amp; (mMessages == <span class="hljs-literal">null</span> || now &lt; mMessages.when)) &#123;<br>                pendingIdleHandlerCount = mIdleHandlers.size();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// No idle handlers to run.  Loop and wait some more.</span><br>                mBlocked = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-literal">null</span>) &#123;<br>                mPendingIdleHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];<br>            &#125;<br>            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);<br>        &#125;<br><br>        <span class="hljs-comment">// Run the idle handlers.</span><br>        <span class="hljs-comment">// We only ever reach this code block during the first iteration.</span><br>        <br>        <span class="hljs-comment">//遍历执行IdleHandler</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IdleHandler</span> <span class="hljs-variable">idler</span> <span class="hljs-operator">=</span> mPendingIdleHandlers[i];<br>            mPendingIdleHandlers[i] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// release the reference to the handler</span><br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">keep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                keep = idler.queueIdle();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (!keep) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    mIdleHandlers.remove(idler);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Reset the idle handler count to 0 so we do not run them again.</span><br>        pendingIdleHandlerCount = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// While calling an idle handler, a new message could have been delivered</span><br>        <span class="hljs-comment">// so go back and look again for a pending message without waiting.</span><br>        nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此 MessageQueue 中 next方法里的每一行代码我们都解释清楚了！</p><h2 id="Handler内存泄漏问题"><a href="#Handler内存泄漏问题" class="headerlink" title="Handler内存泄漏问题"></a>Handler内存泄漏问题</h2><p>在讲这个问题之前，我们首先来说说什么是内存泄漏。</p><p>大家应该知道，我们在java中new了一个对象后，大概率不会所有new出来的的对象就一直存在于我们程序的内存中吧？如果我们只是要短暂使用这个对象，用完后就不再用了，显然这个对象的内存空间就应该被回收，那么回收这个对象是由（JVM）也就是java虚拟机来负责的，这个我们不去介绍很多java虚拟机方面的知识，只是简单提一下，JVM在想去回收对象的时候，首先要知道哪些对象要被回收，哪些不要对吧？那它是怎么做到的呢？JVM会从一些对象开始，查找这些对象引用的对象，然后再从查找到的这些对象引用的对象继续查找它们引用的对象，就这样一直递归查询到底，最后形成一个引用图，那么最后存在在这个引用图上的对象就是不能被回收的，其它的对象就是需要被回收的</p><p>那内存泄漏的本质是什么呢？就是说<strong>长生命周期的对象它引用了短生命周期的对象</strong>，长生命周期的对象在这个引用图上存在的时间更长，这样当短生命周期的对象不再有用希望被回收的时候确因为被长生命周期对象所引用确无法被回收。</p><p><img src="C:\Users\wzt\AppData\Roaming\Typora\typora-user-images\image-20220427092325516.png" alt="image-20220427092325516" style="zoom:50%;" />👆灵魂画手再次上线</p><p>接下来，我们再来看看Handler为什么可能内存泄漏</p><p>最开始的时候说了，我这样子去用Handler是有问题的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler = <span class="hljs-keyword">object</span> : Handler(Looper.getMainLooper()) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>)</span></span> &#123;<br>        <span class="hljs-keyword">when</span> (msg.what) &#123;<br>            <span class="hljs-number">1</span> -&gt; textview.text = msg.obj <span class="hljs-keyword">as</span> String<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样子写有内存泄漏的风险，建议还是这样写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span>() : Handler(Looper.getMainLooper()) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.handleMessage(msg)<br>        ...<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这俩个有啥子区别呢？区别就在于一个是内部类，一个是静态内部类，内部类会持有外部类的引用，而静态内部类则不会</p><p>我们可以看下KT字节码反编译成java代码后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> &lt;undefinedtype&gt; handler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper()) &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Message msg)</span> &#123;<br>      Intrinsics.checkNotNullParameter(msg, <span class="hljs-string">&quot;msg&quot;</span>);<br>      <span class="hljs-keyword">switch</span>(msg.what) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>         <span class="hljs-type">TextView</span> <span class="hljs-variable">var10000</span> <span class="hljs-operator">=</span> (TextView)MainActivity.<span class="hljs-built_in">this</span>._$_findCachedViewById(id.textview);<br>         Intrinsics.checkNotNullExpressionValue(var10000, <span class="hljs-string">&quot;textview&quot;</span>);<br>         <span class="hljs-type">Object</span> <span class="hljs-variable">var10001</span> <span class="hljs-operator">=</span> msg.obj;<br>         <span class="hljs-keyword">if</span> (var10001 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;null cannot be cast to non-null type kotlin.String&quot;</span>);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>            var10000.setText((CharSequence)((String)var10001));<br>         &#125;<br>      <span class="hljs-keyword">default</span>:<br>      &#125;<br>   &#125;<br>&#125;;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Message msg)</span> &#123;<br>      Intrinsics.checkNotNullParameter(msg, <span class="hljs-string">&quot;msg&quot;</span>);<br>      <span class="hljs-built_in">super</span>.handleMessage(msg);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyHandler</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">super</span>(Looper.getMainLooper());<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我最开始的那种写法Handler是内部类会持有外部Activity的引用，而handler发送的msg会持有handler的应用，msg会被msgQueue引用，msgQueue又被Looper引用，Looper又被Threadlocal引用最终导致了Handler可能会内存泄漏。</p><h1 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h1><p>有些提供了参考答案（不完全对，仅代表我的思考）有些因为要讲清楚都能再开一节课了（比如在子线程中更新UI一定会报错吗）所以就不提供答案了，大家自己慢慢去思考，像这种问题想不出来很正常，因为确实对现阶段的你们可能很难（当然某些大佬除外），但是可以等以后积累的知识多了在回调回来解决。</p><p>MessageQueue是干嘛呢？用的什么数据结构来存储数据？</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">MessageQueue就是一个用于存储消息、用链表实现的特殊队列结构。<br></code></pre></td></tr></table></figure><p>Handler中延时消息是怎么实现的？</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">MessageQueue是一个按照消息时间排列的一个链表结构，根据消息的<span class="hljs-keyword">when</span>字段插入即可。<br></code></pre></td></tr></table></figure><p>MessageQueue的消息怎么被取出来的？</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">通过Looper的<span class="hljs-keyword">next</span>方法取消息，里面是一个死循环，保证一定可以取到一条消息,如果没有可用消息，那么就阻塞在这里，一直到有新消息的到来。<br><br>阻塞的情况有俩种 没有消息 和当前消息还没有到要发送的时间<br></code></pre></td></tr></table></figure><p>ThreadLocal运行机制？这种机制设计的好处？</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">ThreadLocal中有一个ThreadLocalMap变量，这个变量存储着键值对形式的数据。<br><br><span class="hljs-bullet">- </span>key为this，也就是当前ThreadLocal变量。<br><span class="hljs-bullet">- </span>value为T，也就是要存储的值。<br><br>每个线程中都有一个ThreadLocalMap,这样带来的好处就是，在不同的线程，访问同一个ThreadLocal对象，但是能获取到的值却不一样。<br></code></pre></td></tr></table></figure><p>为什么ThreadLocalMap要弱引用ThreadLocal?(需要懂内存泄漏的相关知识)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">因为ThreadLocalMap如果是强引用ThreadLocal的话，假如我们将<br>ThreadLocal置为<span class="hljs-literal">null</span>，会因为ThreadLocalMap持有了ThreadLocal的引用而无法被GC<br></code></pre></td></tr></table></figure><p>为什么不能在子线程中更新UI？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">因为<span class="hljs-keyword">Android中的UI控件不是线程安全的。</span><br><span class="hljs-keyword"></span><br>如果通过加锁来实现UI控件的线程安全会导致UI访问的效率降低影响用户体验。<br></code></pre></td></tr></table></figure><p>Looper中的quitAllowed字段是啥？有什么用？</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">是否允许退出的标志字段。在<span class="hljs-keyword">quit</span>方法中有被用到，如果这个字段为<span class="hljs-literal">false</span>，代表不允许退出，就会报错。<br><br><span class="hljs-keyword">quit</span>方法就是退出消息队列，终止消息循环。<br><br>- 首先设置了mQuitting字段为<span class="hljs-literal">true</span>。<br>- 然后判断是否安全退出，如果安全退出，就清空所有的延迟消息，之前没处理的非延迟消息还是需要处理<br>- 如果不是安全退出，就直接清空所有的消息<br><br><br><br>当调用了<span class="hljs-keyword">quit</span>方法之后，mQuitting为<span class="hljs-literal">true</span>，enqueuemessage方法中消息就发不出去了，会报错。next方法返回null，那么loop方法中就会退出死循环。<br></code></pre></td></tr></table></figure><p>Handler、Looper、MessageQueue、线程是一一对应关系吗？</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">一个线程只会有一个Looper对象，所以线程和Looper是一一对应的。<br><br>MessageQueue对象是在<span class="hljs-built_in">new</span> Looper的时候创建的，所以Looper和MessageQueue是一一对应的。<br><br><span class="hljs-keyword">Handler</span>的作用只是将消息加到MessageQueue中，并后续取出消息后，根据消息的target字段分发给当初的那个<span class="hljs-keyword">handler</span>，所以<span class="hljs-keyword">Handler</span>对于Looper是可以多对一的，也就是多个Hanlder对象都可以用同一个线程、同一个Looper、同一个MessageQueue。<br><br>总结：Looper、MessageQueue、线程是一一对应关系，而他们与<span class="hljs-keyword">Handler</span>是可以一对多的。<br></code></pre></td></tr></table></figure><p>Looper.loop方法是死循环，为什么不会卡死（ANR）?</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>主线程需要这样的死循环来处理<span class="hljs-keyword">View</span>界面的变化<br><br><span class="hljs-number">2.</span>而且没有消息的时候,<span class="hljs-keyword">handler</span>会阻塞，主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生。所以死循环也不会特别消耗CPU资源。<br><br><span class="hljs-number">3.</span>在收到跨进程消息后，会交给主线程的Hanlder再进行消息分发。所以Activity的生命周期都是依靠主线程的Looper.<span class="hljs-keyword">loop</span>，当收到不同Message时则采用相应措施，比如收到msg=H.LAUNCH_ACTIVITY，则调用ActivityThread.handleLaunchActivity()方法，最终执行到onCreate方法。<br><br><span class="hljs-number">4.</span>真正导致ANR的原因不是死循环，而是因为在某个消息处理的时候操作时间过长<br></code></pre></td></tr></table></figure><p>HandlerThread和IntentService的原理</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">HandlerThread就是一个封装了Looper的Thread类<br>通过获取 HandlerThread 的 looper 对象传递给 Handler 对象，可以在 <span class="hljs-built_in">handleMessage</span>()方法中执行异步任务。<br>HandlerThread 与线程池不同，HandlerThread 背后只有一个线程,多任务时需要等待处理<br><br>IntentService 是一个继承了 Service 的抽象类，它封装了HandlerThread 和 Handler，当 IntentService 被第一次启动时，它的 <span class="hljs-built_in">onCreate</span>()方法会被调用，<span class="hljs-built_in">onCreat</span>()方法会创建一个HandlerThread，然后使用它的 Looper 来构造一个 Handler 对象，这样通过 handler 发送的消息最终都会在HandlerThread 中执行。<br></code></pre></td></tr></table></figure><p>Handler内存泄漏的原理</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">内存泄漏的本质是因为长生命周期的对象持有了短生命周期对象的引用导致短生命周期的对象无法被正确回收。<br><br><span class="hljs-keyword">Handler</span>如果是activity的内部类，会导致<span class="hljs-keyword">handler</span>持有activity的引用，而<span class="hljs-keyword">handler</span>在发送message时,message会持有<span class="hljs-keyword">handler</span>的引用，而message又被messageQueue引用，messagequeue又被looper引用，looper又被threadlocal引用，threadlocal又被主线程引用，从而导致<span class="hljs-keyword">handler</span>内存泄漏。<br></code></pre></td></tr></table></figure><p>Android开发可以使用LeakCanary去检测是否发生了内存泄漏，试简单分析其检测内存泄漏的原理。</p><p>在子线程中更新UI一定会报错吗？</p><p>（这个问题很难，设计到的Android FrameWork层源码较多，提示，需要弄清楚这个问题，跟ActivityThread的handleResumeActivity有关，View的绘制流程就是从这个方法开始的）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/19/Retrofit&amp;RxJava/"/>
    <url>/2022/10/19/Retrofit&amp;RxJava/</url>
    
    <content type="html"><![CDATA[<h1 id="Retrofit-amp-RxJava"><a href="#Retrofit-amp-RxJava" class="headerlink" title="Retrofit&amp;RxJava"></a>Retrofit&amp;RxJava</h1><h2 id="初识Retrofit-amp-RxJava"><a href="#初识Retrofit-amp-RxJava" class="headerlink" title="初识Retrofit&amp;RxJava"></a>初识Retrofit&amp;RxJava</h2><p>一个App是由UI和数据组成的，没有数据的app只是一个空壳，而数据大部分是从网络上获取的，网络请求也是Android相当重要的部分。我们最开始网络请求用的是HTTPURLConnection，我们需要写很多重复的模板代码，后来改用OkHttp，情况有所好转。而Square公司的Retrofit是目前Android开发最流行的网络请求开源库，它基于OkHttp，可能大家之前已经用过了，它使用起来相当方便。但是作为一个合格的Android开发者，我们不能只会调api，要了解其原理，看看这个Retrofit到底好在哪里了，凭什么大家都用它呢？</p><p>而说到网络请求，离不开的就是异步&#x2F;多线程。Android的线程管理和Java不同，它有一个主线程：AndroidMainThread(好像是叫这个)，</p><p>用于处理屏幕刷新等任务，主线程永不退出，内部原理是消息队列Handler</p><p>如果你在主线程中执行了超过一定时间的耗时任务后，就会出现ANR（Application Not Responding程序未响应），大家玩手机肯定都遇到过</p><blockquote><p>在Android里，应用程序的响应性是由Activity Manager和WindowManager系统服务监视的 ，也就是AMS和WMS。当它监测到以下情况中的一个时，Android就会针对特定的应用程序显示ANR：</p><ol><li>在5秒内没有响应输入的事件（例如，按键按下，屏幕触摸）</li><li>BroadcastReceiver在10秒内没有执行完毕</li></ol></blockquote><p>而网络请求是很耗时的，所以我们需要切换线程来执行它，否则就会出现ANR，这是我们所不想看到的。因此对于安卓开发者来说，线程控制也是十分重要的。这也是为什么要把RxJava和Retrofit放到一起讲。Retrofit和RxJava都提供了清晰明了的异步调用api，比如Retrofit的Call.enqueue，RxJava的线程切换操作符，但是其实他们内部实现线程切换的原理都是线程池，只不过是线程池的具体实现有所差异，所以对线程池有一定的理解是必要的，不需要你把Java线程池整个实现出来，但是你要清楚原理。然后还有一个很重要的问题，我开的异步线程任务执行完毕了，主线程该怎么拿到异步线程返回的数据呢？有很多种方法，但是都离不开再切换到主线程，我们可以用Handler来切换，它是回调式的写法，而回调式的写法比较难以阅读，因为它不是同步式的写法，同步简单来说就是代码按书写顺序执行。Retrofit默认使用的方式就是回调。而RxJava和回调不同，它的链式调用采用同步式的写法，写起来简洁优雅，切换线程也只是一个操作符的事，写起来挺爽的。来看一段掌邮的某个ViewModel网络请求的代码：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220321112958337.png" alt="image-20220321112958337"></p><p>这种链式的同步写法明显比回调更清晰，看着就爽。但是我们不用做选择题，Retrofit本身支持RxJava，那么我们的网络请求就摆脱了回调地狱。</p><p>（既然聊到掌邮了，就再多说点，相信在座的大多数人都会成为移动开发部的一分子，未来不久掌邮会交到你们手里</p><p>掌邮的代码大家想看可以去拉下来看看，但是里面的代码其实真的挺乱的，比如相同功能的dialog工具类、rv的adapter就有好几个，所以我个人觉得有必要制定一个规范，一些简单常用的功能应该统一规范（比如一些Adapter，toast，dialog，activity&#x2F;fragment的跳转,rxjava的用法），有些工具类其实已经封装的很好了，但是如果没有相关文档或者足够详尽的注释或者没有硬性的要求，大家都不知道有这些个东西，就很容易自己写自己的，这样就会很乱，后续维护就会及其恶心，我之前迭代邮问，看吐了。。不是说写的不好吧，就是杂乱无章。还有就是依赖版本勤升，勤更新，拥抱新技术，要不然很容易年久失修，你长时间不升级它，技术更新的多了，再去动就很难了，可能你一升级依赖版本，跑都跑不动，掌邮现状。。）</p><p>同时这里用到了LiveData，这样我们只需要调用这一个方法就能实现切换线程进行网络请求，返回请求结果，切换到主线程更新UI一条龙操作。虽然RxJava的链式调用确实很简洁，但是不要被它吓到了，其实光链式调用的话，就是简单的建造者模式而已。</p><p>设计模式很重要，设计模式很重要，设计模式很重要，重要的事情说三遍，它是无数代OOP人总结的开发经验，对于代码设计和优化，比如解耦合等等有非常大的帮助，Retrofit,RxJava等第三方库里面也是大规模的用到设计模式。而回归本质，设计模式本身是一种思想，不要去生套某个设计模式的模板，理解其中的思想最重要，这些都是可迁移的，后面的内容也会涉及到Retrofit和RxJava中使用的设计模式</p><h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><p>首先我们要讲的是：Retrofit是怎么生成接口的对象的呢？</p><p>我们知道，接口是无法直接实例化的，你可能会说匿名内部类，但它的本质也是创建了一个类来继承了接口。</p><p>所以我们明确一点，我们只能创建具体的类的对象，所以Retrofit肯定在执行Retrofit.create(Interface)的时候动态创建了接口的实现类（动态指的就是运行时）</p><p>动态创建接口，抽象类，可继承类的实现类称作动态代理，而JDK内置了接口的动态代理，Retrofit就是通过它来创建接口对象的。但是如果你想动态代理抽象类，可继承类，那JDK就帮不了你了，有一个也很出名的三方库：Cglib实现了这个操作，我没咋用过，感兴趣的可以去了解一下</p><p>接下来的讲解涉及到源码，因为我不可能一行一行给大家解释源码，只能梳理一遍大致的流程，所以会省略一些无关紧要的方法和代码，讲解的过程也会很跳跃并且没那么详尽，其实大家要看源码也不应该要求面面俱到，明白它的工作流程即可，真要把每一行都看了很折磨，也没必要。限于此及我个人能力有限，大家如果跟不上了或者听不懂了是很正常的，下去之后对照源码和课件自己再梳理梳理</p><p>下面接着来讲动态代理</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>在讲动态代理之前我们先了解一下什么是静态代理，它是最普通，最常见的的代理模式：</p><p>接着分析一下retrofit.create(Interface)到底干了什么</p><blockquote><p><code>retrofit.create(Interface)</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实它际上使用了JDK的动态代理，Proxy.newInstance方法就是JDK自带的动态代理方法</span><br><span class="hljs-comment">//参数里面有接口的ClassLoader，所以肯定涉及到类的生成啦</span><br><span class="hljs-keyword">return</span> Proxy.newInstance(Interface.ClassLoader,Class[]&#123;interface&#125; interfaces,<span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>()):<br><br><span class="hljs-comment">//最终调用ProxyGenerator.generateClassFile()生成并加载接口的代理类</span><br>getProxyConstructor(Interface.classLoader loader,Interface interface)<br>ProxyBuilder().build()<br>defineProxyClass(interfaces)<br>ProxyGenerator.generateProxyClass()<br>ProxyGenerator.generateClassFile()<br><span class="hljs-comment">//我们来看一下这个动态生成的代理类长什么样子，如果想查看动态代理类，首先要设置一个标志：</span><br>    TODO<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>但是最大的问题还没有解决，接口定义的都是抽象方法啊，又没有具体的实现，你生成了一个接口的动态代理类可以，那里面的方法具体逻辑是什么呀？</p><p>我们注意看Proxy.newInstance还有一个参数：InvocationHandler，先来看看生成的动态代理类里面的方法的逻辑是什么：</p><p>TODO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//代理类中具体的方法逻辑通过反射委托给了InvocationHandler的invoke方法：</span><br>&gt;<span class="hljs-keyword">package</span> java.lang.reflect;<br><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>     Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object var1, Method var2, Object[] var3)</span> <span class="hljs-keyword">throws</span> Throwable;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>而在动态代理的时候，传入的InvocationHandler是由Retrofit自定义的，这是毋庸置疑的，因为网络请求的逻辑就是由Retrofit实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;Proxy.newProxyInstance(service.getClassLoader(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123;service&#125;,<br>   <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] emptyArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>         <span class="hljs-keyword">throws</span> Throwable &#123;<br>       <span class="hljs-comment">// 如果方法是在Object类实现的，直接invoke，因为我们知道Object类是所有类的父类，我们的动态代理类也不例外</span><br>       <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;<br>         <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-built_in">this</span>, args);<br>       &#125;<br>       args = args != <span class="hljs-literal">null</span> ? args : emptyArgs;<br>       <span class="hljs-type">Platform</span> <span class="hljs-variable">platform</span> <span class="hljs-operator">=</span> Platform.get();<br>       <span class="hljs-comment">//如果是平台默认方法，也直接调用，否则调用 loadServiceMethod(method).invoke(args)，</span><br>       <span class="hljs-comment">//也就是说网络请求方法等一般方法都是调用loadServiceMethod(method).invoke(args)，</span><br>       <span class="hljs-comment">//那Retrofit关于网络请求的逻辑肯定逃不开这个方法的范畴了</span><br>       <span class="hljs-keyword">return</span> platform.isDefaultMethod(method)<br>           ? platform.invokeDefaultMethod(method, service, proxy, args)<br>           : loadServiceMethod(method).invoke(args);<br> &#125;<br></code></pre></td></tr></table></figure></blockquote><p>我们现在知道通过动态代理，可以为接口动态生成一个代理类。那么现在来看一下Retrofit对于一个网络请求方法的具体逻辑到底是怎么样的：</p><h3 id="Retrofit网络请求的具体逻辑"><a href="#Retrofit网络请求的具体逻辑" class="headerlink" title="Retrofit网络请求的具体逻辑"></a>Retrofit网络请求的具体逻辑</h3><blockquote><p>因为我们在接口中定义的网络请求方法既不是Object类的方法，也不是平台默认方法，所以InvocationHandler最终会调用loadServiceMethod(method).invoke(args)，先来看看loadServiceMethod(method)到底返回了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;<br> result = ServiceMethod.parseAnnotations(<span class="hljs-built_in">this</span>, method);<br> <span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>调用了ServiceMethod.parseAnnotations(this, method)  看看它干了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//省略非核心代码</span><br>&gt;<span class="hljs-type">RequestFactory</span> <span class="hljs-variable">requestFactory</span> <span class="hljs-operator">=</span> RequestFactory.parseAnnotations(retrofit, method);<br>&gt;<span class="hljs-keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);<br></code></pre></td></tr></table></figure><ol><li>传入retrofit和method，创建RequestFactory对象</li><li>调用HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)</li></ol></blockquote><blockquote><p>那么看看HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory)做了什么事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//省略非核心代码</span><br>&gt;<span class="hljs-comment">//获取方法的注解，即&#x27;@GET&#x27;/&#x27;@POST&#x27;等</span><br>&gt;Annotation[] annotations = method.getAnnotations();<br><br>&gt;<span class="hljs-comment">//创建CallAdapter</span><br>&gt;CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =<br>      createCallAdapter(retrofit, method, adapterType, annotations);<br><br>&gt;<span class="hljs-comment">//创建Converter，用于处理请求结果Response</span><br>&gt;Converter&lt;ResponseBody, ResponseT&gt; responseConverter =<br>      createResponseConverter(retrofit, method, responseType);<br><br>&gt;<span class="hljs-comment">//OkHttpClient</span><br>&gt;okhttp3.Call.<span class="hljs-type">Factory</span> <span class="hljs-variable">callFactory</span> <span class="hljs-operator">=</span> retrofit.callFactory;<br>&gt;<span class="hljs-comment">//创建CallAdapted对象，其中的参数是Retrofit的核心，我们后面重点关注</span><br>&gt;<span class="hljs-comment">//那么就是调用它的invoke方法</span><br>&gt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallAdapted</span>&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>CallAdapted类是HttpServiceMethod的静态内部类，并且继承了HttpServiceMethod，它覆写了adapt方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallAdapted</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServiceMethod</span>&#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">protected</span> ReturnT <span class="hljs-title function_">adapt</span><span class="hljs-params">(Call&lt;ResponseT&gt; call, Object[] args)</span> &#123;<br>            <span class="hljs-keyword">return</span> callAdapter.adapt(call);<br>        &#125;<br>&gt;&#125;    <br></code></pre></td></tr></table></figure></blockquote><blockquote><p>然而它并没有覆写invoke方法，那么实际调用它父类也就是HttpServiceMethod的invoke方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Override</span><br>&gt;<span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> ReturnT <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object[] args)</span> &#123;<br>    <span class="hljs-comment">//这里创建OkHttpCall，传入了众多Retrofit重要参数，如果我们接口方法的返回值是Call,返回值就是它</span><br>    Call&lt;ResponseT&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpCall</span>&lt;&gt;(requestFactory, args, callFactory, responseConverter);<br>    <span class="hljs-comment">//那么这里调用的就是CallAdapted的adapt，将Call类型转换为我们想要的类型，</span><br>    <span class="hljs-comment">//比如RxJava的Observable,协程的Flow等等</span><br>    <span class="hljs-keyword">return</span> adapt(call, args);<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>下面重点分析Call&#x2F;OkHttpCall</p><p>执行到这里，我们的网络请求方法返回了OkHttpCall的实例，但是这里并没有执行网络请求，在我们调用Call.execute&#x2F;enqueue之后才会去真正的请求网络，现在来看看OkHttpCall的enqueue方法</p><p>OkHttpCall.enqueue()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//省略非核心代码</span><br>&gt;<span class="hljs-meta">@Override</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Callback&lt;T&gt; callback)</span> &#123;<br>   okhttp3.<span class="hljs-type">Call</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> createRawCall();<br>   call.enqueue(<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">okhttp3</span>.Callback() &#123;   <br>        <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> &#123;<br>               callback.onResponse(OkHttpCall.<span class="hljs-built_in">this</span>, response);<br>          &#125;<br>        <span class="hljs-meta">@Override</span><br>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(okhttp3.Call call, IOException e)</span> &#123;<br>              callback.onFailure(OkHttpCall.<span class="hljs-built_in">this</span>, e);<br>          &#125;<br>      &#125;)    <br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>实际调用了createRawCall方法返回的okhttp3.Call对象的enqueue，来看看createRawCall方法：</p><p>OkHttpCall.createRawCall():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;okhttp3.<span class="hljs-type">Call</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> callFactory.newCall(requestFactory.create(args));<br></code></pre></td></tr></table></figure><p>这里一下子就涉及到我们刚刚提到过的Retrofit的两个核心部分：CallFactory，RequestFactory，我们逐个讲解，先讲RequestFactory</p></blockquote><h4 id="1-Retrofit的请求构建器：RequestFactory"><a href="#1-Retrofit的请求构建器：RequestFactory" class="headerlink" title="1.Retrofit的请求构建器：RequestFactory"></a>1.Retrofit的请求构建器：RequestFactory</h4><p>见名知意：RequestFactory，那就是用来<strong>构建Http的请求（包括请求头，请求体，请求方法等等）</strong>的</p><blockquote><p>首先来看看RequestFactory的构造</p><p>在ServiceMethod.parseAnnotations(this, method)中，我们创建了RequestFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RequestFactory</span> <span class="hljs-variable">requestFactory</span> <span class="hljs-operator">=</span> RequestFactory.parseAnnotations(retrofit, method);<br></code></pre></td></tr></table></figure><p>最终调用了Refactory.Builder(retrofit, method).build()创建了RequestFactory实例，看看这个方法都干了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里获取了方法和方法参数的注解</span><br>Builder(Retrofit retrofit, Method method) &#123;<br>   <span class="hljs-built_in">this</span>.retrofit = retrofit;<br>   <span class="hljs-built_in">this</span>.method = method;<br>   <span class="hljs-built_in">this</span>.methodAnnotations = method.getAnnotations();<br>   <span class="hljs-built_in">this</span>.parameterTypes = method.getGenericParameterTypes();<br>   <span class="hljs-built_in">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();<br>&#125;<br><br>RequestFactory <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-comment">//解析方法注解</span><br>   <span class="hljs-keyword">for</span> (Annotation annotation : methodAnnotations) &#123;<br>     parseMethodAnnotation(annotation);<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//创建parameterHandler的集合，用于解析参数注解</span><br><span class="hljs-type">int</span> <span class="hljs-variable">parameterCount</span> <span class="hljs-operator">=</span> parameterAnnotationsArray.length;<br>parameterHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParameterHandler</span>&lt;?&gt;[parameterCount];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lastParameter = parameterCount - <span class="hljs-number">1</span>; p &lt; parameterCount; p++) &#123;<br>   <span class="hljs-comment">//TODO</span><br>   parameterHandlers[p] =<br>    parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestFactory</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>ParameterHandler是一个抽象类，它的几个实现类的名字和我们在参数中使用的注解一致，例如：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331101028411.png" alt="image-20220331101028411"></p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331101044593.png" alt="image-20220331101044593"></p><p>parseParameter方法调用了parseParameterAnnotation：它根据参数注解的类型，创建了对应的ParameterHandler实例</p></blockquote><blockquote><p>来看一下RequestFactory的构造：</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20220330220006851.png" alt="image-20220330220006851"></p><p>读取builder中的属性，设置一些与Http请求相关的参数</p><p>我们再回到上面的OkHttpCall.createRawCall()，它调用了requestFactory.create(args)：</p></blockquote><blockquote><p>RequestFactory.create(args)：用于创建Request，代表Http请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;okhttp3.Request <span class="hljs-title function_">create</span><span class="hljs-params">(Object[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-comment">//requestFactory构造时创建的parameterHandlers，用于处理参数注解</span><br>  ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;<br>   <br>  <span class="hljs-type">int</span> <span class="hljs-variable">argumentCount</span> <span class="hljs-operator">=</span> args.length;<br>      <br>  <span class="hljs-comment">//创建RequestBuilder对象，用于构建Request对象（即Http请求），需要设置一些Http请求相关的参数</span><br>  <span class="hljs-type">RequestBuilder</span> <span class="hljs-variable">requestBuilder</span> <span class="hljs-operator">=</span><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestBuilder</span>(<br>       httpMethod,<br>       baseUrl,<br>       relativeUrl,<br>       headers,<br>       contentType,<br>       hasBody,<br>       isFormEncoded,<br>       isMultipart);<br>  <br>  <span class="hljs-comment">//通过ParameterHandler解析参数注解</span><br>  List&lt;Object&gt; argumentList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(argumentCount);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; p &lt; argumentCount; p++) &#123;<br>     argumentList.add(args[p]);<br>     handlers[p].apply(requestBuilder, args[p]);<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> okhttp3.Request(requestBuilder);<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>ParameterHandler.apply()：ParameterHandler中为抽象方法，来看子类的是现，以Path为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Override</span><br>&gt;<span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestBuilder builder, <span class="hljs-meta">@Nullable</span> T value)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br> ...<br> <span class="hljs-comment">//调用了builder.addPathParam</span><br> builder.addPathParam(name, valueConverter.convert(value), encoded);<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>RequestBuilder.addPathParam：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331101623892.png" alt="image-20220331101623892"></p><p>把我们的url路径括起来的部分<img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331101729322.png" alt="image-20220331101729322" style="zoom: 67%;" />替换为我们的参数</p></blockquote><blockquote><p>我们再回到OkHttpCall.createRawCall()，现在Request请求构建好了，接下来是callFactory.newCall(Request):</p></blockquote><h4 id="2-Retrofit的网络请求底层实现：CallFactory"><a href="#2-Retrofit的网络请求底层实现：CallFactory" class="headerlink" title="2.Retrofit的网络请求底层实现：CallFactory"></a>2.Retrofit的网络请求底层实现：CallFactory</h4><p>用于返回一个Call对象，注意和刚才的OkHttpCall区分，OkHttpCall持有一个callFactory，callFactory用于创建一个okHttp3.Call的对象，网络请求的底层逻辑就在它里面</p><blockquote><p>首先来回顾一下OkHttpCall.createRawCall()中的callFactory是从哪来的：</p><p>我们在CallAdapted的invoke中构造OkHttpCall对象时，传入了这个CallFactory：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331102920675.png" alt="image-20220331102920675"></p><p>在HttpServiceMethod.parseAnnotations中，创建并返回了CallAdapted对象，callFactory是retrofit的属性：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331103139742.png" alt="image-20220331103139742"></p><p>这个属性是在创建Retrofit对象时通过Retrofit.Builder.client方法设置的</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331103324780.png" alt="image-20220331103324780"></p><p>OkHttpClient是CallFactory的实现类，我们一般使用的CallFactory就是OkHttpClient，当没有手动添加CallFactory时，Retrofit提供的默认的CallFactory其实就是默认的OkHttpClient，因为Retrofit底层的网络请求就是通过OkHttp实现的。</p><p>当然你也可以尝试写一个CallFactory的实现类替代OkHttp</p></blockquote><blockquote><p>我们回到OkHttpCall.createRawCall()：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331103718354.png" alt="image-20220331103718354"></p><p>所以实际调用的是OkHttpClient.newCall(Request)：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331103950614.png" alt="image-20220331103950614"></p><p>实际上调用了：<code>RealCall.newRealCall(OkHttpClient, Request, false /* for web socket */)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">static</span> RealCall <span class="hljs-title function_">newRealCall</span><span class="hljs-params">(OkHttpClient client, Request originalRequest, <span class="hljs-type">boolean</span> forWebSocket)</span> &#123;<br>    <span class="hljs-comment">// Safely publish the Call instance to the EventListener.</span><br>    <span class="hljs-type">RealCall</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealCall</span>(client, originalRequest, forWebSocket);<br>    call.transmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transmitter</span>(client, call);<br>    <span class="hljs-keyword">return</span> call;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>至此我们的Call对象就构建好了，enqueue实际上调用的是RealCall.enqueue：</p></blockquote><blockquote><p>现在来分析RealCall.enqueue，到这里就是OkHttp的内容了:</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331105519578.png" alt="image-20220331105519578"></p><p>将网络请求任务放到线程池中，（注意一点：AsyncCall是OkHttpClient的非静态内部类，所以它持有OkHttpClient实例的引用），它实现了Runnable接口，所以它的逻辑在run方法中：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331105846708.png" alt="image-20220331105846708"></p><p>run()调用了execute()：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331110233683.png" alt="image-20220331110233683"></p><ol><li><p>开始计时，我们在使用HTTPURLConnection时也设置了ConnectionTimeOut，因为请求是有时间限制的，OkHttp就是在这里计时的</p></li><li><p>getResponseWithInterceptorChain()：请求的实际逻辑</p></li><li><p>请求成功，回调onResponse()</p></li></ol><p>  请求失败(超时，异常等)，回调onFailure()</p><ol start="5"><li>最后通知线程池任务完成</li></ol></blockquote><blockquote><p>我们重点关注OkHttp是怎么发出请求的，也就是getResponseWithInterceptorChain()方法：</p></blockquote><p>在讲这个方法之前，我们先来了解一下一种设计模式：</p><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>参考：<a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility">责任链设计模式（职责链模式） (refactoringguru.cn)</a></p><p>（<strong>亦称：</strong> 职责链模式、命令链、CoR、Chain of Command、Chain of Responsibility）</p><ul><li><strong>目的</strong>：<strong>责任链模式</strong>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</li></ul><p>（我们以一个实例介绍它）</p><ul><li><p><strong>:disappointed:问题：（</strong></p><p>假如你正在开发一个在线订购系统。 你希望对接口的访问进行限制，你希望只有用户登录后才可以创建订单，管理员则可以访问所有订单，所以你在请求发送到前给它做了一些处理：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331134414439.png" alt="image-20220331134414439"></p><p>过了一段时间，你觉得网络请求性能太差了，你希望将已经发送的请求进行缓存，再次请求发送已经被缓存的请求时就可以直接返回结果。又有人跟你提议希望你给请求进行加密………经过了一段时间你实现了这些需求：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331134636866.png" alt="image-20220331134636866"></p><p>你把所有的检查都放在了一起，本来处理请求的代码就已经混乱不堪， 而每次新增功能都会使其更加臃肿。 修改某个检查步骤有时会影响其他的检查步骤。 最糟糕的是， 当你希望复用这些检查步骤来保护其他系统组件时，你只能复制部分代码，因为这些组件只需部分而非全部的检查步骤。</p><p>系统会变得让人非常费解， 而且其维护成本也会激增。 你在艰难地和这些代码共处一段时间后， 有一天终于决定对整个系统进行重构。</p></li><li><p>:smiley:<strong>解决方案</strong>: )</p><p>我们的思路很简单：将每个检查步骤抽取为单个类。而责任链模式建议我们将这些处理者串联成一条链条：<img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331135240328.png" alt="image-20220331135240328"></p><p>每个处理者接收请求之后，对它进行相应的处理，再把处理后的请求传给下一个处理者</p></li></ul><p>不过还有一种稍微不同的方式 （也是更经典一种）， 那就是处理者接收到请求后自行决定是否能够对其进行处理。 如果自己能够处理， 处理者就不再继续传递请求。 因此在这种情况下， 每个请求要么最多有一个处理者对其进行处理， 要么没有任何处理者对其进行处理。</p><p>你发没发现，这和我们Android的View树很像？</p><h4 id="OkHttp中的责任链模式"><a href="#OkHttp中的责任链模式" class="headerlink" title="OkHttp中的责任链模式"></a>OkHttp中的责任链模式</h4><p>我们再通过OkHttp中的责任链模式，来看看责任链的代码实现，来看看OkHttp中责任链模式的各个部分：</p><ol><li><p>OkHttp中的“请求”：<strong>Request</strong></p></li><li><p>OkHttp中的“接受者”：<strong>Inteceptor（拦截器）</strong>：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331140126695.png" alt="image-20220331140126695"></p><p>Inteceptor是个接口，唯一定义的方法是intercept，这个方法完美概括了拦截器的职责：</p><ol><li>方法名intercept：拦截</li><li>参数Chain：请求的传递</li><li>返回值Response：获得请求结果,</li></ol><ul><li>一般情况下，一个Interceptor在处理请求之后，传递给下一个拦截器（通过Chain实现），最后一个拦截器负责发送处理后的Request并取得Response，然后Response会反向传递，直到传给第一个Interceptor,所以每一个拦截器不仅可以处理Request，也可以处理Response</li></ul></li></ol><blockquote><p>现在具体来看看getResponseWithInterceptorChain()方法，看看OkHttp中的责任链到底是怎么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">Response <span class="hljs-title function_">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-comment">// 创建一个拦截器List</span><br>  List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  <span class="hljs-comment">//首先将OkHttpClient中的拦截器添加进来，这是我们自己添加的拦截器，如果我们想添加拦截器，只需要：（演示）</span><br>  interceptors.addAll(client.interceptors());<br>  <span class="hljs-comment">//再添加OkHttp的默认拦截器</span><br>  interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryAndFollowUpInterceptor</span>(client));<br>  interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BridgeInterceptor</span>(client.cookieJar()));<br>  interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheInterceptor</span>(client.internalCache()));<br>  interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectInterceptor</span>(client));<br>  <span class="hljs-keyword">if</span> (!forWebSocket) &#123;<br>    interceptors.addAll(client.networkInterceptors());<br>  &#125;<br>  interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallServerInterceptor</span>(forWebSocket));<br><br>  <span class="hljs-comment">//构造Interceptor.Chain，传入interceptors，关注这个0，它代表当前拦截器interceptor在List&lt;Interceptor&gt;中的索引</span><br>  Interceptor.<span class="hljs-type">Chain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(interceptors, transmitter, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>,<br>      originalRequest, <span class="hljs-built_in">this</span>, client.connectTimeoutMillis(),<br>      client.readTimeoutMillis(), client.writeTimeoutMillis());<br><br>  <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> chain.proceed(originalRequest);、<br>  <span class="hljs-keyword">return</span> response;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.首先构建了一个Chain实例，实际上是RealInterceptorChain实现类的实例</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331141742484.png" alt="image-20220331141742484"></p><p>Chain是Interceptor的内部类：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331141918435.png" alt="image-20220331141918435"></p><p>我们接着看getResponseWithInterceptorChain()接下来做了什么，调用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> chain.proceed(originalRequest);<br></code></pre></td></tr></table></figure><p>实际调用了RealInterceptorChain.proceed(Request)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">// 省略非关键代码</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">proceed</span><span class="hljs-params">(Request request, Transmitter transmitter, <span class="hljs-meta">@Nullable</span> Exchange exchange)</span><br><span class="hljs-keyword">throws</span> IOException &#123;<br><br><span class="hljs-type">RealInterceptorChain</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(interceptors, transmitter, exchange,<br>   index + <span class="hljs-number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);<br>   <br><span class="hljs-comment">//此时index是0，那么就是获取第一个拦截器</span><br>  <span class="hljs-type">Interceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> interceptors.get(index);<br>   <span class="hljs-comment">//调用  </span><br>  <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> interceptor.intercept(next);<br>  <br>  <span class="hljs-keyword">return</span> response;<br>  &#125;<br></code></pre></td></tr></table></figure><p>  首先重新构建了RealInterceptorChain，区别是index +&#x3D; 1</p><p>随后获取第一个拦截器（index &#x3D; 0），并调用：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331143427393.png" alt="image-20220331143427393"></p><p>传入了index+&#x3D;1的Chain。我们以RetryAndFollowUpInterceptor（重试&amp;跟踪重定向拦截器）为例，看看它的intercept方法干了什么：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&gt;<span class="hljs-comment">//省略非关键代码（这里只关注它作为Interceptor的实现，不关注它对Request或Response做了什么处理）</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercept</span><span class="hljs-params">(chain: <span class="hljs-type">Interceptor</span>.<span class="hljs-type">Chain</span>)</span></span>: Response &#123;<br>&gt;<span class="hljs-keyword">val</span> realChain = chain <span class="hljs-keyword">as</span> RealInterceptorChain<br><span class="hljs-keyword">var</span> request = chain.request<br><br><span class="hljs-keyword">var</span> response: Response<br>  <br>  response = realChain.proceed(request)<br> <span class="hljs-keyword">return</span> response<br>  &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  调用response &#x3D; realChain.proceed(request)并返回，又回到了Chain.proceed方法，但因为index &#x3D; index+1,它会调用下一个拦截器的intercept，我们的Request就这样沿着拦截器链传递下去了</p><p>最终会返回Response，Response从最后一个拦截器返回至第一个拦截器</p><p>再返回到getResponseWithInterceptorChain()中：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331144954739.png" alt="image-20220331144954739"></p><p>Response再返回到getResponseWithInterceptorChain()的调用处：RealCall.execute()：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331145415564.png" alt="image-20220331145415564"></p><p>然后Response就会传给我们在Call.enqueue时传入的回调了</p><p>至此Call.enqueue(Callback)分析结束，Retrofit大致流程的分析基本结束</p><p>这里提一点，我并没有讲OkHttp具体的网络请求逻辑，具体的逻辑都在那几个默认拦截器里面，大家感兴趣的自己去看它们的源码⑧，在课上讲它们肯定是讲不完的。</p></blockquote><h4 id="3-Retrofit的适配器：CallAdapter"><a href="#3-Retrofit的适配器：CallAdapter" class="headerlink" title="3.Retrofit的适配器：CallAdapter"></a>3.Retrofit的适配器：CallAdapter</h4><p>我们刚刚分析了Call.enqueue(Callback)的过程，那如果我们的返回值不是Call呢？</p><blockquote><p>我们前面分析过，调用网络请求接口的方法，实际上是调用InvocationHandler.invoke，进而调用CallAdapted.invoke()：</p></blockquote><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331152212443.png" alt="image-20220331152212443"></p><blockquote><p>返回值并不是Call，而是adapt(call,args)：</p></blockquote><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331152305134.png" alt="image-20220331152305134"></p><blockquote><p>callAdapter是在HttpServiceMethod.parseAnnotations方法中创建的：</p></blockquote><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331152521193.png" alt="image-20220331152521193"></p><p>参数解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回 方法返回值的类型，包括泛型类型</span><br><span class="hljs-type">Type</span> <span class="hljs-variable">adapterType</span> <span class="hljs-operator">=</span> method.getGenericReturnType();<br><span class="hljs-comment">//方法注释，@GET、@POST...</span><br>Annotation[] annotations = method.getAnnotations();<br></code></pre></td></tr></table></figure><blockquote><p>createCallAdapter方法：去Retrofit中储存的CallAdapter.Factory数组找到与adapterType对应的CallAdapter.Factory</p><p>（我们通过调用Retrofit.Builder#addCallAdapterFactory(Factory)添加到Retrofit中储存的CallAdapter.Factory数组），并通过它构造一个CallAdapter实例，代码略多，这里就不贴了</p><p>CallAdapter构造完了，我们回到adapt，调用callAdapter.adapt(call)，看看它干了什么：</p><p>先来看看CallAdapter的定义吧，它是个接口：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Adapts a &#123;<span class="hljs-doctag">@link</span> Call&#125; with response type &#123;<span class="hljs-doctag">@code</span> R&#125; into the type of &#123;<span class="hljs-doctag">@code</span> T&#125;. Instances are</span><br><span class="hljs-comment"> * created by &#123;<span class="hljs-doctag">@linkplain</span> Factory a factory&#125; which is &#123;<span class="hljs-doctag">@linkplain</span></span><br><span class="hljs-comment"> * Retrofit.Builder#addCallAdapterFactory(Factory) installed&#125; into the &#123;<span class="hljs-doctag">@link</span> Retrofit&#125; instance.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//CallAdapter用于将Call&lt;R&gt;转换为T（接口方法处声明的返回值，对应上面的adapterType），</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CallAdapter</span>&lt;R, T&gt; &#123;<br>    <span class="hljs-comment">//返回Call&lt;R&gt;中的R</span><br>  Type <span class="hljs-title function_">responseType</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//将Call&lt;R&gt;转换为T</span><br>  T <span class="hljs-title function_">adapt</span><span class="hljs-params">(Call&lt;R&gt; call)</span>;<br><br>    <span class="hljs-comment">//工厂方法，用于构造CallAdapter对象</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>      <span class="hljs-comment">//返回一个CallAdapter实例，如果本Factory不能处理该returnType，则返回null</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(<br>        Type returnType, Annotation[] annotations, Retrofit retrofit);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Extract the upper bound of the generic parameter at &#123;<span class="hljs-doctag">@code</span> index&#125; from &#123;<span class="hljs-doctag">@code</span> type&#125;. For</span><br><span class="hljs-comment">     * example, index 1 of &#123;<span class="hljs-doctag">@code</span> Map&lt;String, ? extends Runnable&gt;&#125; returns &#123;<span class="hljs-doctag">@code</span> Runnable&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Type <span class="hljs-title function_">getParameterUpperBound</span><span class="hljs-params">(<span class="hljs-type">int</span> index, ParameterizedType type)</span> &#123;<br>      <span class="hljs-keyword">return</span> Utils.getParameterUpperBound(index, type);<br>    &#125;<br><br>    <span class="hljs-comment">//如果Type是泛化类型，返回原始类型</span><br>    <span class="hljs-comment">//example: List&lt;String&gt; --&gt; List</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; getRawType(Type type) &#123;<br>      <span class="hljs-keyword">return</span> Utils.getRawType(type);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>接下来以RxJava3CallAdapterFactory为例分析：</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;Retrofit.Builder()<br>&gt;.addCallAdapterFactory(RxJava3CallAdapterFactory.createSynchronous())<br></code></pre></td></tr></table></figure><p>首先是RxJava3CallAdapterFactory.get：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Override</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(<br>&gt;<span class="hljs-comment">//期望返回值类型</span><br>&gt;Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;<br>&gt;<span class="hljs-comment">//获取returnType的原始类型</span><br>&gt;Class&lt;?&gt; rawType = getRawType(returnType);<br><br>&gt;<span class="hljs-comment">//?</span><br>&gt;<span class="hljs-keyword">if</span> (rawType == Completable.class) &#123;<br>&gt;<span class="hljs-comment">// Completable is not parameterized (which is what the rest of this method deals with) so it</span><br>&gt;<span class="hljs-comment">// can only be created with a single configuration.</span><br>&gt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RxJava3CallAdapter</span>(<br>  Void.class, scheduler, isAsync, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&gt;&#125;<br><br>&gt;<span class="hljs-comment">//判断是否是Flowable/Single/Maybe</span><br>&gt;<span class="hljs-type">boolean</span> <span class="hljs-variable">isFlowable</span> <span class="hljs-operator">=</span> rawType == Flowable.class;<br>&gt;<span class="hljs-type">boolean</span> <span class="hljs-variable">isSingle</span> <span class="hljs-operator">=</span> rawType == Single.class;<br>&gt;<span class="hljs-type">boolean</span> <span class="hljs-variable">isMaybe</span> <span class="hljs-operator">=</span> rawType == Maybe.class;<br>&gt;<span class="hljs-comment">//如果不是Observable/Flowable/Single/Maybe其中之一，那么RxJava3CallAdapterFactory无法处理这个类型，返回null</span><br>&gt;<span class="hljs-keyword">if</span> (rawType != Observable.class &amp;&amp; !isFlowable &amp;&amp; !isSingle &amp;&amp; !isMaybe) &#123;<br>&gt;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&gt;&#125;<br><br>&gt;<span class="hljs-type">boolean</span> <span class="hljs-variable">isResult</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>   <span class="hljs-comment">//Observable的泛型既不是Response也不是Result</span><br>&gt;<span class="hljs-type">boolean</span> <span class="hljs-variable">isBody</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>&gt;Type responseType;<br><br>&gt;<span class="hljs-comment">//判断返回值是否有泛型，没有就抛异常</span><br>&gt;<span class="hljs-keyword">if</span> (!(returnType <span class="hljs-keyword">instanceof</span> ParameterizedType)) &#123;<br>&gt;<span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span><br>  isFlowable ? <span class="hljs-string">&quot;Flowable&quot;</span> : isSingle ? <span class="hljs-string">&quot;Single&quot;</span> : isMaybe ? <span class="hljs-string">&quot;Maybe&quot;</span> : <span class="hljs-string">&quot;Observable&quot;</span>;<br>&gt;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>  name<br>          + <span class="hljs-string">&quot; return type must be parameterized&quot;</span><br>          + <span class="hljs-string">&quot; as &quot;</span><br>          + name<br>          + <span class="hljs-string">&quot;&lt;Foo&gt; or &quot;</span><br>          + name<br>          + <span class="hljs-string">&quot;&lt;? extends Foo&gt;&quot;</span>);<br>&#125;<br><br>  <span class="hljs-comment">//获取返回值第一个泛型参数，（即Observable&lt;R&gt;中的R）</span><br><span class="hljs-type">Type</span> <span class="hljs-variable">observableType</span> <span class="hljs-operator">=</span> getParameterUpperBound(<span class="hljs-number">0</span>, (ParameterizedType) returnType);<br>  <span class="hljs-comment">//获取泛型参数的原始类型，因为泛型可以嵌套</span><br>Class&lt;?&gt; rawObservableType = getRawType(observableType);<br>  <span class="hljs-comment">//检查返回值是Observable&lt;Response&lt;T&gt;&gt;的情况，确保Response/Result有泛型,</span><br>  <span class="hljs-comment">//Response有泛型，将返回值类型由Response&lt;T&gt;设置为T；否则抛异常</span><br><span class="hljs-keyword">if</span> (rawObservableType == Response.class) &#123;<br>  <span class="hljs-keyword">if</span> (!(observableType <span class="hljs-keyword">instanceof</span> ParameterizedType)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>        <span class="hljs-string">&quot;Response must be parameterized&quot;</span> + <span class="hljs-string">&quot; as Response&lt;Foo&gt; or Response&lt;? extends Foo&gt;&quot;</span>);<br>  &#125;<br>  responseType = getParameterUpperBound(<span class="hljs-number">0</span>, (ParameterizedType) observableType);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawObservableType == Result.class) &#123;<br>  <span class="hljs-keyword">if</span> (!(observableType <span class="hljs-keyword">instanceof</span> ParameterizedType)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>        <span class="hljs-string">&quot;Result must be parameterized&quot;</span> + <span class="hljs-string">&quot; as Result&lt;Foo&gt; or Result&lt;? extends Foo&gt;&quot;</span>);<br>  &#125;<br>  responseType = getParameterUpperBound(<span class="hljs-number">0</span>, (ParameterizedType) observableType);<br>  isResult = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  responseType = observableType;<br>    <span class="hljs-comment">//返回值类型是Observable&lt;R&gt;中的R</span><br>  isBody = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RxJava3CallAdapter</span>(<br>    responseType, scheduler, isAsync, isResult, isBody, isFlowable, isSingle, isMaybe, <span class="hljs-literal">false</span>);<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>RxJava3CallAdapter.adapt(call)：将call转换成接口方法返回值，这个转换是通过Observable嵌套实现的，现在先不讲，因为讲了估计也是一头雾水，学完下面要讲的RxJava再来看就很简单了</p><p>但是这里有一个要注意的地方：就是这个isAsync参数。理解它之前，我们首先要明确一点：不管怎么转换，其实都是由Call.enqueue&#x2F;execute来得到请求结果Response的，isAsync决定是异步还是同步，这个值实际上是由我们RxJava3CallAdapterFactory的创建方式决定的，RxJava3CallAdapterFactory有三种创建方式：</p><ul><li>RxJava3CallAdapterFactory.create()：</li></ul><p>异步 isAsync&#x3D;true，使用Call.enqueue获取Response，而enqueue使用OkHttp的线程池，所以就会导致网络请求不在subscribeOn(可以指定网络请求的线程)指定的线程执行（学完RxJava再来理解）</p><ul><li>RxJava3CallAdapterFactory.createSynchronous()：</li></ul><p>同步 isAsync&#x3D;false，使用Call.execute获取Response</p><ul><li>RxJava3CallAdapterFactory.createWithScheduler(Scheduler):</li></ul><p>自己指定线程，相当于给Observable调用一次subscribeOn()（学完RxJava再来理解）</p><p>所以我们在addCallAdapterFactory时也要注意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//isAsync影响RxJava3CallAdapter的adapt方法（学完RxJava再来理解）</span><br>&gt;<span class="hljs-meta">@Override</span><br>&gt;<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">adapt</span><span class="hljs-params">(Call&lt;R&gt; call)</span> &#123;<br>  <span class="hljs-comment">//首先构造Observable&lt;Response&lt;R&gt;&gt;</span><br>Observable&lt;Response&lt;R&gt;&gt; responseObservable =<br>    isAsync ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallEnqueueObservable</span>&lt;&gt;(call) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallExecuteObservable</span>&lt;&gt;(call);<br><br>Observable&lt;?&gt; observable;<br><span class="hljs-keyword">if</span> (isResult) &#123;<br>  observable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResultObservable</span>&lt;&gt;(responseObservable);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isBody) &#123;<br>  observable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BodyObservable</span>&lt;&gt;(responseObservable);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  observable = responseObservable;<br>&#125;<br><br><span class="hljs-keyword">if</span> (scheduler != <span class="hljs-literal">null</span>) &#123;<br>  observable = observable.subscribeOn(scheduler);<br>&#125;<br><br><span class="hljs-keyword">if</span> (isFlowable) &#123;<br>  <span class="hljs-keyword">return</span> observable.toFlowable(BackpressureStrategy.LATEST);<br>&#125;<br><span class="hljs-keyword">if</span> (isSingle) &#123;<br>  <span class="hljs-keyword">return</span> observable.singleOrError();<br>&#125;<br><span class="hljs-keyword">if</span> (isMaybe) &#123;<br>  <span class="hljs-keyword">return</span> observable.singleElement();<br>&#125;<br><span class="hljs-keyword">if</span> (isCompletable) &#123;<br>  <span class="hljs-keyword">return</span> observable.ignoreElements();<br>&#125;<br><span class="hljs-keyword">return</span> RxJavaPlugins.onAssembly(observable);<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="4-Retrofit的转换器：Converter"><a href="#4-Retrofit的转换器：Converter" class="headerlink" title="4.Retrofit的转换器：Converter"></a>4.Retrofit的转换器：Converter</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">/**</span><br><span class="hljs-comment">&gt;* Convert objects to and from their representation in HTTP. Instances are created by &#123;<span class="hljs-doctag">@linkplain</span></span><br><span class="hljs-comment">&gt;* Factory a factory&#125; which is &#123;<span class="hljs-doctag">@linkplain</span> Retrofit.Builder#addConverterFactory(Factory) installed&#125;</span><br><span class="hljs-comment">&gt;* into the &#123;<span class="hljs-doctag">@link</span> Retrofit&#125; instance.</span><br><span class="hljs-comment">&gt;*/</span><br></code></pre></td></tr></table></figure><p>Converter用于处理数据序列化。这个是Converter接口的注释，翻译一下：用于将对象转换至它在HTTP中的形式，或者将HTTP中的数据转换成对象</p><p>我们一般是从JSON转换：</p><p>Gson:     <code>com.squareup.retrofit:converter-gson</code><br>Jackson:<code>com.squareup.retrofit:converter-jackson</code><br>Moshi:    <code>com.squareup.retrofit:converter-moshi</code></p><p>除了上面列出的，当然你自己也可以添加处理其他数据格式的<code>Converter.Factory</code>来转换JSON以外的其他数据格式，或者自己实现<code>Converter.Factory</code>类来定制自己的转换器</p><p>我们解析JSON，一般添加的是GsonConverterFactory，使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;Retrofit.Builder().addConverterFactory(GsonConverterFactory.create())<br></code></pre></td></tr></table></figure><p>如果不添加它，在接口返回值是JSON时就会出现这样的转换异常：找不到转换成对应数据类的Converter</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220331211146987.png" alt="image-20220331211146987"></p></blockquote><p>至此，我们就大致完整的分析了一遍Retrofit :clap::clap:</p><h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><h3 id="什么是RxJava？"><a href="#什么是RxJava？" class="headerlink" title="什么是RxJava？"></a>什么是RxJava？</h3><p>RxJava在GitHub上的简介：</p><blockquote><p>RxJava：a library for composing asynchronous and event-based programs using observable sequences for the Java VM</p><p>翻译：在JVM平台上运行，通过事件序列组合 异步的基于事件的程序 的库</p></blockquote><p>概念总是抽象的，总结来说Rxjava干了两件事：</p><ul><li><strong>基于事件流的链式调用</strong>，使得RxJava写起来简洁优雅，</li><li><strong>基于功能众多的操作符，</strong>随着程序逐渐复杂，依然能够保持简洁优雅，比如<strong>切换线程</strong></li></ul><p>再来看一下刚才我们看的掌邮的那段代码吧：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220321112958337.png" alt="image-20220321112958337"></p><h3 id="基于事件流的链式调用"><a href="#基于事件流的链式调用" class="headerlink" title="基于事件流的链式调用"></a>基于事件流的链式调用</h3><p>在讲解这点之前，我们首先来了解或回顾一下一种设计模式：</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><blockquote><p>我们还是从问题引入</p><p>:disappointed:问题:（</p><p>假如你有两种类型的对象：  <code>顾客</code>和 <code>商店</code> 。 顾客对某个特定品牌的产品非常感兴趣 （例如最新型号的 iPhone 手机）， 而该产品很快将会在商店里上架。</p><p>一方面，顾客可以每天来商店看看产品是否到货。 但如果商品尚未到货时， 来到商店的顾客都会空手而归。</p><p>另一方面， 每次新产品到货时， 商店可以向所有顾客发送邮件 （可能会被视为垃圾邮件）。 这样， 部分顾客就无需反复前往商店了， 但也可能会惹恼对新产品没有兴趣的其他顾客。</p><p>我们似乎遇到了一个矛盾： 要么让顾客浪费时间检查产品是否到货， 要么让商店浪费资源去通知没有需求的顾客。</p><p>:smiley:解决方案：）订阅机制</p><p>解决方案不难想出：商店保留一个列表，记录所有关注商品上架的顾客，商品到货后再通知列表上的顾客，这就是订阅机制</p><p>订阅机制很常见，比如你在B站关注了一个Up主，</p><ul><li>观察者模式的应用</li></ul><p>观察者模式既简单又常用，当我们在B站关注了一个Up主，那么在ta发布了新视频或开播后，就会给所有的粉丝推送一条通知</p><p>再比如大家熟悉的LiveData，它的实现就是最基本的观察者模式，只不过绑定了生命周期</p><p>订阅机制中有两类成员：</p><ol><li><code>发布者 （publisher）</code>:它会将自身状态的改变发布给关注这个变化的对象</li><li><code>订阅者（subscriber）</code>:所有希望关注发布者状态变化的其他对象被称为订阅者</li></ol><p>实现订阅机制也很简单：</p><ol><li>第一步，发布者需要持有一个订阅者数组<code>subscriber[]</code>，并且在事件发生时，遍历这个数组，通知给每一个订阅者，并且包含添加&#x2F;删除订阅者的方法</li><li>订阅者需要包含响应事件的方法，我们定义<code>subscriber</code>接口，它唯一定义了一个方法<code>update()</code>，由具体的订阅者类实现这个接口，这样发布者在事件产生时才知道如何通知给订阅者</li></ol><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220329144944789.png" alt="image-20220329144944789" style="zoom:80%;" /></blockquote><h4 id="RxJava中的观察者模式"><a href="#RxJava中的观察者模式" class="headerlink" title="RxJava中的观察者模式"></a>RxJava中的观察者模式</h4><p>RxJava的核心就是观察者模式，但它在实现上比较特殊，这种特殊性使得它支持简洁的链式调用：</p><p>我们首先来了解一下RxJava的基本使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//RxJava中的发布者称作Observable，如字面意思，可被观察的</span><br><span class="hljs-comment">//创建Observable对象的方式有很多种：</span><br><br><span class="hljs-number">1.</span>Observable.create(ObservableOnSubscribe&lt;<span class="hljs-built_in">Int</span>&gt; &#123; emitter -&gt;<br>  emitter.apply &#123;<br>     <span class="hljs-comment">//发送事件1，2，3</span><br>     onNext(<span class="hljs-number">1</span>)<br>     onNext(<span class="hljs-number">2</span>)<br>     onNext(<span class="hljs-number">3</span>)<br>   &#125;<br>&#125;<br>                    <br><span class="hljs-comment">//ObservableOnSubscribe接口，在它定义的方法中我们需要完成事件的生产和发送，因为它是SAM，所以我们可以用labmda表达式的写法： </span><br><span class="hljs-comment">//emitter负责将事件发送，这个emitter其实就是订阅者,onNext就是订阅者的回调方法</span><br>Observable.create&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>    it.onNext(<span class="hljs-number">1</span>)<br>    it.onNext(<span class="hljs-number">1</span>)<br>    it.onNext(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">//和第一种写法的效果一样，如果我们不需要生产事件，那么用just更方便，just用于发送现成的事件</span><br><span class="hljs-comment">//如果是网络请求，它就不适用了，因为我们要先请求数据</span><br><span class="hljs-number">2.</span>Observable.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// RxJava中的订阅者称作Observer，它是一个接口，定义了几种回调</span><br><span class="hljs-keyword">val</span> observer = <span class="hljs-keyword">object</span> : Observer&lt;<span class="hljs-built_in">Int</span>&gt;&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;&#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">Int</span>)</span></span> &#123;&#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;&#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 现在我们看RxJava的Observer是怎么订阅Observable的:</span><br>observable.subscribe(observer)<br><span class="hljs-comment">// 这里看起来有一点奇怪啊：为什么是发布者订阅订阅者呢？按照正常的逻辑不是订阅者订阅发布者吗</span><br><span class="hljs-comment">// 其实不管谁订阅谁，只要订阅后发布者保存了订阅者的引用就没问题，而RxJava之所以这样设计，是为了链式调用的顺畅，不需要管它</span><br><span class="hljs-comment">// 我们需要关注的是：在observable.subscribe(observer)这行代码调用后，即订阅发生后，</span><br><span class="hljs-comment">// Observable会立即调用构造时创建的生产&amp;发送事件的方法，将事件通知给订阅者</span><br></code></pre></td></tr></table></figure><p>在<code>observable.subscribe(observer)</code>调用之后，<code>Observable</code>就会开始生产<code>事件</code>，并且事件会沿着我们的<code>链条</code>向下流动，直到交给<code>Observer</code>，事件被消费</p><p>再来看看我们刚刚写的链条，虽然这个链条有点短，只有Observable和Observer：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//在这简化了一下，将所有的操作合在一起</span><br>Observable.create(ObservableOnSubscribe&lt;<span class="hljs-built_in">Int</span>&gt; &#123; emitter -&gt;<br>    emitter.apply &#123;<br>      onNext(<span class="hljs-number">1</span>)<br>      onNext(<span class="hljs-number">2</span>)<br>      onNext(<span class="hljs-number">3</span>)<br>      onComplete()<br>    &#125; <br>  &#125;)<br>    .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;<span class="hljs-built_in">Int</span>&gt;&#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;&#125;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">Int</span>)</span></span> &#123; println(t) &#125;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;&#125;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    &#125;)<br></code></pre></td></tr></table></figure><p>执行起来就是如下图这样一个效果：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f0c20c52f9f3a80368dd629c6abef178.png" alt="img"></p><h3 id="RxJava中的线程切换"><a href="#RxJava中的线程切换" class="headerlink" title="RxJava中的线程切换"></a>RxJava中的线程切换</h3><p>我们将RxJava中的线程操作符和RxJava的基本流程放在一起讲，我认为这样好理解一点</p><p>RxJava中的线程切换涉及到两个操作符：</p><ul><li><code>subscribeOn(Scheduler)</code>：指定生产事件的线程，<strong>只有第一次调用生效</strong></li><li><code>observeOn(Scheduler)</code>：指定该操作符之后所有针对事件操作的线程，直到下一个<code>observeOn</code>再次切换线程，<strong>每次调用都生效</strong></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//RxJava的线程切换就是这么简单，想想之前回调式的切换线程的写法，被完爆</span><br>Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>  .subscribeOn(Schedulers.newThread())<br>  .observeOn(Schedulers.newThread())<br>  .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;<span class="hljs-built_in">Int</span>&gt;&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;&#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">Int</span>)</span></span> &#123;&#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;&#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;&#125;<br>  &#125;)<br><span class="hljs-comment">//现在才有链条的样子</span><br></code></pre></td></tr></table></figure><p>那么，为什么<code>observeOn(Scheduler)</code>可以多次使用来切换线程，而<code>subscribeOn(Scheduler)</code>只能切换一次呢？</p><p>我们带着这个问题，从源码角度分析一下RxJava的订阅流程以及操作符的基本原理：</p><h4 id="RxJava的基本订阅机制分析-amp-subscribeOn操作符"><a href="#RxJava的基本订阅机制分析-amp-subscribeOn操作符" class="headerlink" title="RxJava的基本订阅机制分析&amp;subscribeOn操作符"></a>RxJava的基本订阅机制分析&amp;subscribeOn操作符</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//首先分析Observable的创建:Observable.create()</span><br>Observable.create()(ObservableOnSubscribe&lt;<span class="hljs-built_in">Int</span>&gt; &#123; emitter -&gt;<br>    emitter.apply &#123;<br>      onNext(<span class="hljs-number">1</span>)<br>      onNext(<span class="hljs-number">2</span>)<br>      onNext(<span class="hljs-number">3</span>)<br>      onComplete()<br>    &#125; <br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/uTools_1648554296237.png" alt="uTools_1648554296237"></p><p><code>RxJavaPlugins.onAssembly(new ObservableCreate&lt;&gt;(source));</code>RxJavaPlugins.onAssembly将<code>ObservableCreate</code>对象原封不动的返回，不进一步分析</p><p>那么我们现在来看一下<code>ObservableCreate</code>的构造，它继承了Observable抽象类：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220329195340818.png" alt="image-20220329195340818"></p><p>并传入了一个<code>ObservableOnSubscribe</code>对象，还记得它吗：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//它就是在create()时，我们自己定义的生产&amp;发送事件的方法</span><br>Observable.create()(ObservableOnSubscribe&lt;<span class="hljs-built_in">Int</span>&gt; &#123; emitter -&gt;<br>    emitter.apply &#123;<br>      onNext(<span class="hljs-number">1</span>)<br>      onNext(<span class="hljs-number">2</span>)<br>      onNext(<span class="hljs-number">3</span>)<br>      onComplete()<br>    &#125; <br>  &#125;)<br></code></pre></td></tr></table></figure><p>create()返回了一个<code>ObservableCreate</code>对象，并将<code>ObservableOnSubscribe</code>传给了它</p><p>所以实际调用的subscribe方法是ObservableCreate定义的，那么接下来分析<code>ObservableCreate.subscribe(Observer)</code>：</p><p>subscribe是Observable抽象类 里面的方法，在ObservableCreate中没有覆写，我们看一下它做了什么：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/123.png" alt="123"></p><ul><li><p>**1.**和之前一样，把observer原封不动的返回，不分析</p></li><li><p>**2.**实际上只调用了subscribeActual，那么subscribe的具体逻辑在subscribeActual中，它是Observable定义的抽象方法，ObservableCreate覆写了它：</p></li></ul><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/12312.png" alt="12312"></p><p>里面做了两件事：</p><ul><li><p>**1.**回调observer的onSubscribe方法</p></li><li><p>**2.**source.subscribe(parent)：即调用create()时我们传入的生产&#x2F;发送事件的方法，所以onSubscribe回调在事件流产生之前</p><p>   从第一行代码我们也能猜出，这个Emitter发射器其实就是Observer</p></li></ul><p>RxJava的基本订阅机制分析结束 </p><p>接下来看看<code>subscribeOn(Scheduler)</code>做了些什么：</p><p>它定义在Observable中：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/RU1231231.png" alt="RU1231231"></p><p>构造了一个ObservableSubscribeOn对象，它也继承了Observable。并将当前Observable（this）（注意这里的说法：当前Observable，为什么这么说呢，我们看这个方法，它将this包装成了一个新的Observable返回，而RxJava几乎所有的操作符都会这么做：将this包装成一个新的Observable，所以Observable会被一层一层包装，最后调用subscibe的Observable是<code>包装的最多的Observable</code>）和Scheduler作为参数传入它的构造方法，那么我们来看看这个ObservableSubscribeOn类的构造：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220329201550871.png" alt="image-20220329201550871"></p><p>他继承了AbstractObservableWithUpstream抽象类，构造时调用了父类的构造：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/1231231.png" alt="1231231"></p><p>父类的构造，保存了我们当前的Observable（this）</p><p>如果subscribeOn之后直接subcribe，那么调用的就是ObservableSubscribeOn的subscribe方法，而我们知道subscribe方法的逻辑实际上在subscribeActual中，来看看ObservableSubscribeOn的subscribeActual方法干了什么：</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20220329202545388.png" alt="image-20220329202545388"></p><p>前两行暂且不讨论，不代表它们不重要，后面会讲到，</p><p>关键在最后一行，scheduler类似线程池，SubscribeTask实现了Runnable，那么看一下这个SubscribeTask的run方法：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330090354732.png" alt="image-20220330090354732"></p><p>其实就是先切换线程，再调用source.subscribe(observer)，而source是在subscribeOn调用之前创建的Observable，我们叫它上层Observable</p><p>那么总结一下，subscribeOn操作符干了几件事：</p><ol><li>新建了一个Observable，并保存上一层Observable（如果你多次调用subscribeOn，那么就会一层一层创建很多Observable，而每一层都保存了上一层的引用。其实绝大部分操作符都会这样做），这就像给上层Observable（本例中是ObservableCreate）套了一个壳一样，</li></ol><p>如果连续调用两次subscribeOn：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">observable<br>  .subscribeOn(Schedulers.trampoline())<br>  .subscribeOn(Schedulers.newThread())<br>  .subscribe &#123;<br><span class="hljs-comment">//    println(&quot;ObserverOn: &quot; + Thread.currentThread().name)</span><br>  &#125;<br>Thread.sleep(<span class="hljs-number">1000000</span>)<br></code></pre></td></tr></table></figure><p>执行情况如图所示：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330092533820.png" alt="image-20220330092533820"></p><p>而最后subscribe(Observer)时，调用的是完全包装的Observable的subscribe，而下层Observable的subscribe会调用上层Observable的subscribe，直到调用顶层Observable比如ObservableCreate的subscribe，之后开始生产&amp;发送事件。我们刚刚分析过，subscribeOn创建的Observable会在调用上层Observable的subscribe之前切换线程，而如果多次切换线程，最后切换到的线程才是执行线程。而按照subscribe的执行顺序，在多次subscribeOn的情况下，最后的线程切换是由第一次subscribeOn创建的Observable执行，所以最上层ObservableCreate的subscribe方法的线程是第一次调用的subscribeOn切换的线程</p><p>到这里，我们分析完RxJava的基本订阅机制和subscribeOn操作符，以及为什么subscribeOn只有第一次生效</p><p>接下来分析observeOn操作符：</p><h4 id="observeOn操作符"><a href="#observeOn操作符" class="headerlink" title="observeOn操作符"></a>observeOn操作符</h4><p>和subscribeOn一样，它是Observable抽象类定义的方法：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330093305420.png" alt="image-20220330093305420"></p><p>和subscribeOn返回了一个ObservableSubscribeOn对象类似，observeOn返回了一个ObservableObserveOn对象，和subscribeOn同理，也是对上层Observable的包装，看看ObservableObserveOnsubscribeActual方法都做了什么吧：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330093506692.png" alt="image-20220330093506692"></p><p>先做了一个判断scheduler是不是TrampolineScheduler，TrampolineScheduler表示在当前线程执行，代表不需要切换线程，直接调用上层Observable的subscribe，否则，将Observer包装成ObserveOnObserver再向上传递。</p><p>回顾subscribeOn的subscribeActual方法的第一行：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220403001609758.png" alt="image-20220403001609758"></p><p>其实它也包装了Observer，<strong>我们可以认为，在每个操作符中，都会包装Observable和Observer</strong></p><p>如果我们连续调用两次observeOn:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> observable = Observable.create&lt;<span class="hljs-built_in">Int</span>&gt; &#123; emitter -&gt;<br>  emitter.onNext(<span class="hljs-number">1</span>)<br>&#125;<br>observable<br>  .observeOn(Schedulers.trampoline())<br>  .observeOn(Schedulers.newThread())<br>  .subscribe &#123;<br>    println(<span class="hljs-string">&quot;ObserverOn: &quot;</span> + Thread.currentThread().name)<br>  &#125;<br></code></pre></td></tr></table></figure><p>执行流程如图：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330105512818.png" alt="image-20220330105512818"></p><p>在我们调用subscribe后，每向上传递到一个ObservableObserveOn，Observer就被包装一层，直到传递到顶层ObservableCreate，完全包装的Observer用于构造CreateEmitter</p><p>紧接着顶层Observable的subscribe就是事件的发送和消费，我们接着分析：</p><p>回顾ObservableCreate的subscribeActual：</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20220403002950713.png" alt="image-20220403002950713"></p><ol><li>将完全包装的Observer用于构造CreateEmitter</li><li>调用我们在代码中创建Observable时传入的生产&amp;发送事件的方法：</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> observable = Observable.create&lt;<span class="hljs-built_in">Int</span>&gt; &#123; emitter -&gt;<br>  emitter.onNext(<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>来看一下Emitter.onNext：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330110015210.png" alt="image-20220330110015210"></p><p>实际上调用了obsever的onNext，它就是构造传进的obsever，在本例中是ObserveOnObserver，所以实际调用的是它的onNext：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330151424771.png" alt="image-20220330151424771"></p><p>将事件入事件队列：queue.offer(t)，调用schedule():</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330152142549.png" alt="image-20220330152142549"></p><p>启动线程池，且只调用一次</p><p>ObserveOnObserver实现了Runnable接口，来看看它的run方法：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/12371273.png" alt="12371273"></p><p>会走到drainNormal中：</p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330152807935.png" alt="image-20220330152807935" style="zoom:80%;" /><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330152820549.png" alt="image-20220330152820549"></p><p>只需要关注红框内的代码：从队列中取出事件，并发送给downStream（下层Observer，命名很合理）</p><p>总结一下，ObserveOnObserver消费事件时，会开启一个线程池，切换线程后，开启一个死循环不断从事件队列queue中取出事件，交给downStream，即下游（内层）的Obsever</p><p>为什么observeOn每次调用都会生效呢，是因为后调用的observeOn切换线程的顺序和代码中observeOn操作符的顺序一致，前面分析完，这里应该不难理解，如果还是理解不了，就再去理解一下前面那张连续调用两次observeOn的执行流程图</p><p>至此，RxJava的线程切换我们就分析完了</p><p><strong>onSubscribe和Disposable</strong>：</p><p><strong>onSubscribe的执行流程</strong></p><p>我们先分析onSubscribe的执行流程，先猜测它的流向和事件一样自上而下</p><p>以这段代码为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>    .subscribeOn(Schedulers.newThread())<br>    .observeOn(Schedulers.newThread())<br>    .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;<span class="hljs-built_in">Int</span>&gt;&#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;&#125;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">Int</span>)</span></span> &#123;&#125;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;&#125;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    &#125;)<br></code></pre></td></tr></table></figure><p>首先在我们subscribe之后，subscribe中传入的obsever，也就是第一个Obsever，我们记做O1，因为subsribe由下向上传递，每经过一个操作符Obsever就会被包一层，最终Obsever就是这样：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220401191555825.png" alt="image-20220401191555825"></p><p>onSubscribe是在顶层Observable的subscribe与事件发送之间执行的，来看顶层Observable的subscribeActual：</p><p>这里的顶层Observable是由just创建的，和create有所不同，但是对于onSubscribe没区别：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220401190728461.png" alt="image-20220401190728461"></p><p>首先调用了SubscribeOnObserver.onSubscribe：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220401191753621.png" alt="image-20220401191753621"></p><p>它并没有调用内层Observer的onSubscribe，难道传到这里就断了？我们再回顾一下之前落下的ObservableSubscribeOn.subscribeActual的第二行：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220401192118514.png" alt="image-20220401192118514"></p><p>其实是在subscribe向上传递到subscribeOn操作符时，就回调了onSubscribe，相当于subscribeOn把onSubscribe切成两段。它在这里调用下一层Observer的onSubscribe，即observeOn创建的ObserveOnObserver，<strong>并把自己作为参数</strong>，ObserveOnObserver的onSubscribe方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> void onSubscribe(Disposable d) &#123;<br>        downstream.onSubscribe(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用了内层Observer的onSubscribe，<strong>也是把自己传当作参数</strong></p><p>所以我们知道两点</p><ul><li>onSubscribe的传递和onNext，onComplete等事件不一样</li><li>onSubscribe传入的Disposable参数是上一层Observer对象</li></ul><p><strong>事件的中断：</strong></p><p>RxJava中的事件流可以包含很多事件，那事件在发送的过程中能不能中断呢？答案是肯定的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//以以下代码为例</span><br>Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>  .subscribeOn(Schedulers.newThread())<br>  .observeOn(Schedulers.newThread())<br>  .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;<span class="hljs-built_in">Int</span>&gt;&#123;<br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> disposable : Disposable<br>      <span class="hljs-comment">//我们在onSubscribe时可以保存这个Disposable对象</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>      disposable = d<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-comment">//调用disposable.dispose()，之后的onNext事件就不会被消费，原理是：</span><br>        <span class="hljs-comment">//上层Observer在向下传递事件前，会判断一个标志位，disposable.dispose()改变这个标志位会</span><br>        <br>        <span class="hljs-comment">//但是这并不影响事件的正常发送，</span><br>        <span class="hljs-comment">//由于onSubscribe中传入的Disposable对象是上层Observer，所以事件还是会正常传递到上层Observer，</span><br>        <span class="hljs-comment">//只不过最终不会传递到原始Observer</span><br>      <span class="hljs-keyword">if</span> (t == <span class="hljs-number">2</span>) disposable.dispose()<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;&#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;&#125;<br>  &#125;)<br></code></pre></td></tr></table></figure><h3 id="RxJava常用操作符"><a href="#RxJava常用操作符" class="headerlink" title="RxJava常用操作符"></a>RxJava常用操作符</h3><h4 id="变换："><a href="#变换：" class="headerlink" title="变换："></a>变换：</h4><h5 id="map"><a href="#map" class="headerlink" title="map:"></a>map:</h5><p>作用：对 被观察者发送的每1个事件都通过 <strong>指定的函数</strong> 处理，从而变换成另外一种事件</p><p>使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>  .map &#123; <br>    it.toString()<br>  &#125;<br>  .subscribe(<span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>      println(<span class="hljs-string">&quot;subOn:<span class="hljs-subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">String</span>)</span></span> &#123;<br>      println(<span class="hljs-string">&quot;int to str: <span class="hljs-variable">$t</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>    &#125;<br><br>  &#125;)<br></code></pre></td></tr></table></figure><p>原理：先看张图片了解一下它的原理</p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/1da8059c654103264b6f4e2f15b2c891.png" alt="1da8059c654103264b6f4e2f15b2c891" style="zoom:150%;" /><p>我之前说过，几乎所有的操作符都是通过包装Obseverable和Obsever实现功能，map也不例外，来看看它到底干了什么：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330155332588.png" alt="image-20220330155332588"></p><p>Function是个单一抽象方法接口，所以我们可以用lamda的写法使用map，它定义了一个将T转换为R的方法，T是原来事件的类型，即原始事件类型，R在我们使用map时根据返回值确定：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330155623308.png" alt="image-20220330155623308"></p><p>将Function的实例mapper作为参数，创建并返回了一个ObservableMap对象，我们来看看ObservableMap的subscribeActual方法：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330155850351.png" alt="image-20220330155850351"></p><p>给Observer包装了一层MapObserver&lt;T,U&gt;，那么来看看MapObserver是怎么消费事件的吧，这是它的onNext方法：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220330160428693.png" alt="image-20220330160428693"></p><p>就是调用Function.apply(T)，将T类型的事件转为类型为U的事件，再交给下游Observer</p><h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap:"></a>flatMap:</h5><p>作用：</p><ol><li>为事件序列中每个事件都创建一个 <code>Observable</code> 对象；</li><li>将新建的每个<code>Observable</code> 都合并到一个 新建的、总的<code>Observable</code> 对象</li><li>新建的、总的<code>Observable</code> 对象 将 新合并的事件序列 发送给观察者（<code>Observer</code>）</li></ol><p>使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Observable.create&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>  it.onNext(<span class="hljs-number">1</span>)<br>  it.onNext(<span class="hljs-number">12</span>)<br>  it.onNext(<span class="hljs-number">123</span>)<br>&#125;<br>  .flatMap &#123;<br>    Observable.just(it,it,it)<br><span class="hljs-comment">//      .subscribeOn(Schedulers.newThread())</span><br>  &#125;<br>  .safeSubscribe(<span class="hljs-keyword">object</span> : Observer&lt;<span class="hljs-built_in">Int</span>&gt;&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">Int</span>)</span></span> &#123;<br>      println(t)<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>      e.printStackTrace()<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>    &#125;<br>  &#125;)<br></code></pre></td></tr></table></figure><p>我们来看看flatMap做了什么：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220401142746490.png" alt="image-20220401142746490"></p><p>最终调用四个参数的flatMap方法，和其他操作符类似，flatMap也创建了一个新的Observable，叫做ObservableFlatMap</p><p>来看看它的subscribeActual方法：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220401142935263.png" alt="image-20220401142935263"></p><p>将下层Observer包装成MergeObserver，并传入了用于类型切换的mapper，那么我们看看，当事件流向MergeObserver时发生了什么，以MergeObserver的onNext为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//省略无关代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNext</span><span class="hljs-params">(T t)</span> &#123;<br>    ObservableSource&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span>&gt; p = mapper.apply(t);<br>    subscribeInner(p);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用mapper将事件转化为Observable，接着调用了subscribeInner：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//为了方便理解，对源码进行了一些删减和改动</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">subscribeInner</span><span class="hljs-params">(ObservableSource&lt;? extends U&gt; p)</span> &#123;<br>    <span class="hljs-comment">//如果我们刚刚创建的Observable只有一个事件，可能判断成功</span><br>      <span class="hljs-keyword">if</span> (p insatnceOf Supplier)&#123;<br>          tryEmitScalar(p)<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-comment">//否则就会走这里，上面其实是是针对单一事件做的优化，这个是一般情况，单一事件在这里执行也是对的</span><br>          InnerObserver&lt;T, U&gt; inner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerObserver</span>&lt;&gt;(<span class="hljs-built_in">this</span>, uniqueId++);<br>          <span class="hljs-keyword">if</span> (addInner(inner)) &#123;<br>              p.subscribe(inner);<br>          &#125;<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果判断成功，tryEmitScalar会直接将Observable中的事件发送给下游，这是针对单一事件做的优化。为什么我说可能会走这里，</p><p>因为如果我们在mapper创建Observable时，使用了操作符比如subscribeOn(Schedulers.newThread())，</p><p>而ObservableSubscribeOn没有实现Supplier，所以尽管顶层Observable的确是只有一个事件，p insatnceOf Supplier返回的还是false</p><p>else里面是更一般的情况，首先创建了一个InnerObserver对象，将this（MergeObserver）传入</p><p>接着调用this.addInner(inner)，MergeObserver持有一个InnerObserver数组，这个方法将inner添加至这个数组，添加成功就返回true，</p><p>然后调用p.subscribe(inner)将我们p中的事件发送给我们的InnerObserver来消费事件</p><p>InnerObserver消费事件的几个方法和普通的Observer不同，首先来看一下InnerObserver的onSubscribe：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSubscribe</span><span class="hljs-params">(Disposable d)</span> &#123;<br>    <span class="hljs-keyword">if</span> (DisposableHelper.setOnce(<span class="hljs-built_in">this</span>, d)) &#123;<br>        <span class="hljs-comment">//注意这里，按照onSubscribe的流程，参数d是InnerObserver上一层的Observer，</span><br>        <span class="hljs-comment">//顶层Obsever，即完全包装的Observer是由just创建的，如果just传入的参数&gt;1</span><br>        <span class="hljs-comment">//那么它创建的顶层Obsever，类型是FromArrayDisposable，</span><br>        <span class="hljs-comment">//它实现了QueueDisposable，然而按照onSubscribe的流程，</span><br>        <span class="hljs-comment">//参数d是直接包装InnerObserver的Observer，所以如果使用了subscribeOn，d就是SubscribeOnObsever，</span><br>        <span class="hljs-comment">//它并没有实现QueueDisposable，所以这里返回false，这个要注意一下，猜测QueueDisposable和Supplier互斥</span><br>        <span class="hljs-comment">//我们讨论没有subscribeOn的情况</span><br>        <span class="hljs-keyword">if</span> (d <span class="hljs-keyword">instanceof</span> QueueDisposable) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            QueueDisposable&lt;U&gt; qd = (QueueDisposable&lt;U&gt;) d;<br><br>            <span class="hljs-comment">//这里返回QueueDisposable.ASYNC</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);<br>            <span class="hljs-keyword">if</span> (m == QueueDisposable.SYNC) &#123;<br>                fusionMode = m;<br>                queue = qd;<br>                done = <span class="hljs-literal">true</span>;<br>                parent.drain();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//所以会走到这里</span><br>            <span class="hljs-keyword">if</span> (m == QueueDisposable.ASYNC) &#123;<br>                fusionMode = m;<br>                queue = qd;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本例中，d是just创建的Observer，这里将它赋值给InnerObserver的queue属性，就相当于把要发送的事件交给InnerObserver，然后调用parent.drain()，parent是MergeObsever：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220401165144126.png" alt="image-20220401165144126"></p><p>调用且只调用一次drainLoop()：它会<strong>按照添加顺序</strong>遍历MergeObserver的InnerObserver数组，将发送InnerObserver需要发送的事件，当一个InnerObserver的事件全部发送完成后，会从数组中删除它，这个方法<strong>能够保证事件按照Observable中事件的顺序</strong>。</p><p>如果在本例中我们使用了subscribeOn，也就是d instanceof QueueDisposable返回false，会直接发送Observable中的事件，但是不能保证发送顺序和添加顺序一致，详见InnerObserver.onNext</p><p>总结一下上述流程：flapMap操作符包装了一个新的Observable：ObservableFlatMap，它在subscribeActual的时候会将Observer包装成MergeObserver，MergeObsever对于接收到的每一个事件，都会调用我们使用flapMap操作符传入的高阶函数来新创建一个Observable，并创建一个InnerObserver与之对应并储存Observable中的事件，并将它添加到MergeObsever的一个InnerObserver数组中</p><p>MergeObsever会按照Observable的添加顺序遍历InnerObserver数组，发送它们需要发送的事件，保证了事件发送顺序和生产顺序的一致；但是如果mapper创建的Observable使用了其他操作符，可能会导致Observable instanceof QueueDisposable返回false，InnerObserver创建后立即发送事件，不能保证发送顺序和生产顺序一致</p><h5 id="concatMap："><a href="#concatMap：" class="headerlink" title="concatMap："></a>concatMap：</h5><p>相比于flatMap只有一点不同，就是无论如何，concatMap的事件都是按Observable创建顺序发送的</p><h4 id="生命周期回调："><a href="#生命周期回调：" class="headerlink" title="生命周期回调："></a>生命周期回调：</h4><h5 id="doOn…："><a href="#doOn…：" class="headerlink" title="doOn…："></a>doOn…：</h5><p>分为以下几种：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220403105711333.png" alt="image-20220403105711333"></p><p>并且我们可以获取到对应的事件：</p><p><img src="https://gitee.com/zhu-yuchong/blog-picture/raw/master/img/image-20220403105311173.png" alt="image-20220403105311173"></p><h4 id="延迟发送："><a href="#延迟发送：" class="headerlink" title="延迟发送："></a>延迟发送：</h4><h5 id="delay："><a href="#delay：" class="headerlink" title="delay："></a>delay：</h5><p>作用：延迟subscibe发送事件</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 指定延迟时间</span><br><span class="hljs-comment">// 参数1 = 时间；参数2 = 时间单位</span><br>delay(<span class="hljs-type">long</span> delay,TimeUnit unit)<br><br><span class="hljs-comment">// 2. 指定延迟时间 &amp; 调度器</span><br><span class="hljs-comment">// 参数1 = 时间；参数2 = 时间单位；参数3 = 线程调度器</span><br>delay(<span class="hljs-type">long</span> delay,TimeUnit unit,mScheduler scheduler)<br><br><span class="hljs-comment">// 3. 指定延迟时间  &amp; 错误延迟</span><br><span class="hljs-comment">// 错误延迟，即：若存在Error事件，则如常执行，执行后再抛出错误异常</span><br><span class="hljs-comment">// 参数1 = 时间；参数2 = 时间单位；参数3 = 错误延迟参数</span><br>delay(<span class="hljs-type">long</span> delay,TimeUnit unit,<span class="hljs-type">boolean</span> delayError)<br><br><span class="hljs-comment">// 4. 指定延迟时间 &amp; 调度器 &amp; 错误延迟</span><br><span class="hljs-comment">// 参数1 = 时间；参数2 = 时间单位；参数3 = 线程调度器；参数4 = 错误延迟参数</span><br>delay(<span class="hljs-type">long</span> delay,TimeUnit unit,mScheduler scheduler,<span class="hljs-type">boolean</span> delayError): 指定延迟多长时间并添加调度器，错误通知可以设置是否延迟<br></code></pre></td></tr></table></figure><h4 id="重复发送："><a href="#重复发送：" class="headerlink" title="重复发送："></a>重复发送：</h4><h5 id="repeat："><a href="#repeat：" class="headerlink" title="repeat："></a>repeat：</h5><p>作用：无条件重复发送</p><p>使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>  .repeat(<span class="hljs-number">3</span>)<br><span class="hljs-comment">//重复发送三次事件</span><br></code></pre></td></tr></table></figure><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><h5 id="filter："><a href="#filter：" class="headerlink" title="filter："></a>filter：</h5><p>作用：根据指定条件过滤</p><p>使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>  .filter &#123;<br>    it&gt;=<span class="hljs-number">2</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>RxJava的操作符太多了，全讲的话根本讲不完，这里只是挑几个简单常用的介绍一下原理和使用，了解更多操作符可以看这个文章：</p><p><a href="https://blog.csdn.net/carson_ho/article/details/79191327">Carson带你学Android：RxJava操作符教程</a></p><p>至此，RxJava我们就算过了一遍，本课结束:clap::clap:</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/19/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <url>/2022/10/19/%E8%87%AA%E5%AE%9A%E4%B9%89View/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><em><strong>由于采用 Typora 书写，github 不支持部分格式，建议 clone 后用 Typora 观看</strong></em></p><h1 id="自定义View与动画"><a href="#自定义View与动画" class="headerlink" title="自定义View与动画"></a>自定义View与动画</h1><h2 id="一、自定义View"><a href="#一、自定义View" class="headerlink" title="一、自定义View"></a>一、自定义View</h2><h3 id="1、为什么要自定义？"><a href="#1、为什么要自定义？" class="headerlink" title="1、为什么要自定义？"></a>1、为什么要自定义？</h3><blockquote><p>一句话：官方的控件满足不了产品想要的效果 (</p><p>但其实，官方控件已经能满足绝大多数需求了，正常情况下自定义 View 是下下策，因为造自定义 View 的轮子是一件很耗时也很耗精力的事。</p><p>这里分享一下我大一暑假时遇到的事情，当时共 5 个组分开做积分商城，产品给了一个积分商城的设计图，其中主页有一个上滑展开的需求，我们组（我和钟智），我就负责做这个上滑的界面。当时我花了好像 3、4 天的时间去设计一个自定义 View（原谅我当时还不知道协调者布局这个东西），结果啊，产品改需求了，靠</p><p>经过上面的这个故事后，相信大家应该理解到了选择自定义 View 会面临的风险</p><p>后来我又花了接近一周的时间还是用自定义 View 写出了产品的新需求，限于当时我的能力，现在去看当时写的代码，存在一些耦合的地方，算是给以后学弟留坑了😁</p><p>OK，回到这里，自定义 View 确实是下下策，不止会影响你的心情，如果你的代码设计得不好的话（比如耦合度很高，代码逻辑混乱），还会影响以后维护代码人的心情。（说个笑话：听说代码写得越烂，越不容易被辞退 :）</p></blockquote><h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><blockquote><p>这里自定义 View 是一个习惯性的统称</p><p>如果按照类型来分：</p><ul><li><p>自定义 View</p><blockquote><p>指直接或间接继承于 View 的控件，如：TextView、Button</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">View</span> &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TextView</span> &#123;&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>自定义 ViewGroup</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ViewGroup</span> &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FrameLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ViewGroup</span> &#123;&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><p>如果按照学习的内容来分，大致分为以下内容</p><ul><li><p>View 的测量与布局</p><blockquote><p>测量就是与 Measure 相关的方法，如：<code>onMeasure()</code></p><p>布局就是与 Layout 相关的方法，如：<code>onLayout()</code></p><p>这两个一般是在一起调用的，并且通常是在 自定义 ViewGroup 中才会涉及到（View 中也可以实现，比如 TextView 就重写了 <code>onLayout()</code> 方法）</p></blockquote></li><li><p>View 的绘制</p><blockquote><p>绘制就是与 Draw 相关的方法，如：<code>onDraw()</code></p><p>为什么要列出绘制？</p><p>因为很多动画都是依靠重写绘制来实现的，所以绘制也比较重要</p></blockquote></li><li><p>事件分发</p><blockquote><p>一般指触摸事件的分发</p><p>这个应该是自定义 View 中最难也最重要的内容了，如果你想设计出一些很炫酷的界面，就得精通事件分发</p><p>事件分发会在下下节课讲解</p></blockquote></li></ul><p>接下来就是正式开始讲解自定义 View 的时间，由于时间原因，在加上你们的现阶段能力的原因，本节课更偏向于讲解如何使用自定义 View，而不是讲解底层内容，底层内容以博客的形式分享</p></blockquote><h3 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h3><blockquote><p>该部分内容参考：<a href="https://www.cnblogs.com/angeldevil/p/3479431.html#three">https://www.cnblogs.com/angeldevil/p/3479431.html#three</a></p><p>View 一共有四个构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span> &#123;<br><span class="hljs-comment">// 这个用于在代码中直接 new 一个 View，这个 context 一般都是 activity，代表上下文</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(Context context)</span><br><br><span class="hljs-comment">// 这个用于在 xml 中书写，系统自动将你写在 xml 中的属性装换为一个 AttributeSet 对象，然后调用这个函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">Context context, </span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> AttributeSet attrs</span><br><span class="hljs-params">)</span><br><br><span class="hljs-comment">// 这个一般用于设置默认属性，使用的情况较少</span><br><span class="hljs-comment">// 系统不会主动调用，一般是开发者自己设置</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">Context context, </span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> AttributeSet attrs, </span><br><span class="hljs-params"><span class="hljs-type">int</span> defStyleAttr</span><br><span class="hljs-params">)</span><br><br><span class="hljs-comment">// 这个与上面的类似，也是设置默认属性，使用的情况也较少，且只支持 Android 5.0 以上</span><br><span class="hljs-comment">// 系统不会主动调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">Context context, </span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> AttributeSet attrs, </span><br><span class="hljs-params"><span class="hljs-type">int</span> defStyleAttr, </span><br><span class="hljs-params"><span class="hljs-type">int</span> defStyleRes</span><br><span class="hljs-params">)</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>前面两个构造函数各位应该都能看懂，关键在于后面两个，他们与设置默认属性相关，在讲解前我们先得知道一个 View 可以通过哪些方式设置属性</p></blockquote><h4 id="1、直接写在-XML-中"><a href="#1、直接写在-XML-中" class="headerlink" title="1、直接写在 XML 中"></a>1、直接写在 XML 中</h4><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.cardview.widget.CardView</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:cardBackgroundColor</span>=<span class="hljs-string">&quot;@android:color/darker_gray&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:cardCornerRadius</span>=<span class="hljs-string">&quot;8dp&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这样就会给当前 View 设置属性</p><p>原理是系统自动把这些属性写入到 AttributeSet 类里面，然后调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> View(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)<br></code></pre></td></tr></table></figure><p>来生成 View 对象</p></blockquote><h4 id="2、使用-style-设置属性"><a href="#2、使用-style-设置属性" class="headerlink" title="2、使用 @style 设置属性"></a>2、使用 @style 设置属性</h4><blockquote><p>在 <code>style.xml</code> 中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myCardView_style&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cardBackgroundColor&quot;</span>&gt;</span>@android:color/darker_gray<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cardCornerRadius&quot;</span>&gt;</span>8dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 <code>layout.xml</code> 中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.cardview.widget.CardView</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/myCardView_style&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这个一般用于多个相同控件复用属性的时候</p><p>原理与上一个是一样的，它会把 <code>style=&quot;@style/MyCardView&quot;</code> 里写的属性一起写入 AttributeSet 类里面</p><blockquote><p>问题：如果 <code>style=&quot;@style/MyCardView&quot;</code> 与 xml 中有相同属性它会怎么处理呢？</p><p>经过测试后，xml 中定义的属性会覆盖 <code>style=&quot;@style/MyCardView&quot;</code> 中定义的属性</p></blockquote></blockquote><h4 id="3、在-theme-中设置某种控件的默认属性"><a href="#3、在-theme-中设置某种控件的默认属性" class="headerlink" title="3、在 theme 中设置某种控件的默认属性"></a>3、在 theme 中设置某种控件的默认属性</h4><blockquote><p>在 <code>theme.xml</code> 中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MyAppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-comment">&lt;!--下面这个 @style/MyCardView 就是前面写的 &lt;style name=&quot;MyCardView&quot;&gt;--&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cardViewStyle&quot;</span>&gt;</span>@style/myCardView_style<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里 <code>name=&quot;cardViewStyle&quot;</code> 意思是定义 CardView 的默认属性<br>这个默认属性是如何生效的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原因在于 CardView 的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CardView</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-meta">@NonNull</span> Context context, </span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> AttributeSet attrs</span><br><span class="hljs-params">)</span> &#123;<br><span class="hljs-built_in">this</span>(context, attrs, R.attr.cardViewStyle);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CardView</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-meta">@NonNull</span> Context context, </span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> AttributeSet attrs, </span><br><span class="hljs-params"><span class="hljs-type">int</span> defStyleAttr</span><br><span class="hljs-params">)</span> &#123;<br><span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以发现，两个参数的构造函数使用了 <code>this(context, attrs, R.attr.cardViewStyle)</code> 调用了三个参数的构造函数，其中他给第三个参数传入了一个值 <code>R.attr.cardViewStyle</code>，我们去扒它源码，看下这是什么东西（直接点击导包中的 <code>import androidx.cardview.R</code> 就可以跳到源码中）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;reference&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cardViewStyle&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里可能你们会看不懂，我简单讲一下：这个 <code>format=&quot;reference&quot;</code> 代表这个属性接受的类型，而 <code>reference</code> 表示接受的类型为一个引用值，比如：<code>@style/xxx</code>、<code>@color/xxx</code>、<code>@drawable/xxx</code> 就是引用值</p><p>然后 <code>name=&quot;cardViewStyle&quot;</code> 代表这个属性的唯一名字</p><p>这个 attr 的引用就是 CardView 可以在 theme 中设置默认属性的原因，因为系统调用 CardView 两个参数的构造函数，然后它这个构造函数主动调用了三个参数的构造函数，并且传入了 <code>R.attr.cardViewStyle</code>，所以构造函数的第三个参数对应的是一个<code>style</code> 格式的引用，但需要你自己在 View 中指定名字</p><p>引用 <code>theme.xml</code> 有以下几种方式：</p><ul><li><p>全局引用，所有 View 都会使用该配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/MyAppTheme&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>某个 Activity 引用，当前 Activity 内使用该配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.section3.test.TestActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/MyAppTheme&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>某个 Activity 使用代码引用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setTheme(R.style.MyAppTheme)<br>    setContentView(R.layout.layout_card0)<br>&#125;<br><span class="hljs-comment">// 注意在 Activity 中使用必须在 setContentView 之前</span><br></code></pre></td></tr></table></figure></li><li><p>单个 View 使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.cardview.widget.CardView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/MyAppTheme&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>看到这里你可能有点晕，我们简单梳理一下流程：</p><pre><code class=" mermaid">graph TBid1(&quot;系统读取你写的 xml&quot;)--&gt;id2id2[&quot;生成 AttributeSet，然后调用两个参数的构造函数&quot;]--&gt;id3id3[&quot;两个参数的调用三个参数的，并传入 R.attr.cardViewStyle&quot;]--&gt;id4id4[&quot;View 开始从 theme 中读取属性&quot;]--&gt;id5id5[&quot;View 在 theme 中发现 name=cardViewStyle&gt;xxxx&lt; 的定义&quot;]--&gt;id6id6(&quot;读取 @style/MyCardView 里面的属性&quot;)</code></pre></blockquote><h4 id="4、调用构造函数的-defStyleRes"><a href="#4、调用构造函数的-defStyleRes" class="headerlink" title="4、调用构造函数的 defStyleRes"></a>4、调用构造函数的 defStyleRes</h4><blockquote><p>由于 CardView 没有重写第四个构造函数（可能是为了兼容 Android 5.0 以下？），所以这里我用 FrameLayout 来演示</p><p>先在 <code>style.xml</code> 中定义属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myFrameLayout&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_width&quot;</span>&gt;</span>match_parent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_height&quot;</span>&gt;</span>match_parent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:background&quot;</span>&gt;</span>@android:color/black<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在代码中这样使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> frameLayout = FrameLayout(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, R.style.myFrameLayout_style)<br></code></pre></td></tr></table></figure><p>当你不能在 xml 中申明，只能在代码中动态生成时，就可以使用这种写法，有个优点就是使用 <code>style.xml</code> 可以进行属性的复用，但一般都用不到复用，这时候就可以使用 LayoutParams 和调用对应方法来代替：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> frameLayout = FrameLayout(<span class="hljs-keyword">this</span>)<br><span class="hljs-comment">// Android 第一节课我们讲过，父布局可以给子布局设置属性</span><br><span class="hljs-comment">// 且属性都以 layout_ 开头，所以 layout_width 和 layout_height </span><br><span class="hljs-comment">// 对应由 LayoutParams 来设置</span><br>frameLayout.layoutParams = ViewGroup.LayoutParams(<br> ViewGroup.LayoutParams.MATCH_PARENT,<br> ViewGroup.LayoutParams.MATCH_PARENT<br>)<br><span class="hljs-comment">// background 属于 View 自身属性，所以对应 View 自身方法</span><br>frameLayout.setBackgroundColor(Color.BLACK)<br><br><span class="hljs-comment">// 但这样写有一个缺点就是：LayoutParams 这东西只能设置少量的属性，</span><br><span class="hljs-comment">// 而且 LayoutParams 有很多个，具体选择那个需要看你的 View 被添加到</span><br><span class="hljs-comment">// 哪种父布局里，如果是 LinearLayout，就是 LinearLayout.LayoutParams(...)</span><br></code></pre></td></tr></table></figure><p>可能有人不知道 LayoutParams 是什么东西，你暂时可以把它看成是用来保存 View 中有关<strong>父布局属性</strong>的一个数据类，供父布局使用，后面会再次讲解</p><p>除了上面这种动态生成时传入默认属性，你也可以在构造器中设置你的自定义 View 的默认属性：</p><p>一般是这样定义构造器的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 由于 java 是基础，我先用 java 来定义构造器，后面再使用 kt 来优化写法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Section3View</span> <span class="hljs-title">extends</span> <span class="hljs-title">View</span> &#123;<br> <span class="hljs-keyword">public</span> Section3View(Context context) &#123;<br>     <span class="hljs-comment">// 注意这里调用的是 this，而不是 super</span><br>     <span class="hljs-keyword">this</span>(context, <span class="hljs-literal">null</span>);<br> &#125;<br><br> <span class="hljs-keyword">public</span> Section3View(<br>     Context context, <br>     <span class="hljs-meta">@Nullable</span> AttributeSet attrs<br> ) &#123;<br>     <span class="hljs-comment">// 注意这里调用的是 this，而不是 super</span><br>     <span class="hljs-keyword">this</span>(context, attrs, R.attr.mySection3View_attrs);<br> &#125;<br><br> <span class="hljs-keyword">public</span> Section3View(<br>     Context context, <br>     <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <br>     int defStyleAttr<br> ) &#123;<br>     <span class="hljs-comment">// 注意这里调用的是 this，而不是 super</span><br>     <span class="hljs-comment">// 这里就是设置默认属性</span><br>     <span class="hljs-keyword">this</span>(<br>         context, <br>         attrs, <br>         defStyleAttr, <br>         R.style.mySection3View_defaultAttrs<br>     );<br> &#125;<br><br> <span class="hljs-keyword">public</span> Section3View(<br>     Context context, <br>     <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <br>     int defStyleAttr, <br>     int defStyleRes<br> ) &#123;<br>     <span class="hljs-comment">// 直到这里才调用 super</span><br>     <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>R.attr.mySection3View_attrs</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--value/attrs.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mySection3View_attrs&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;reference&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 <code>R.style.mySection3View_defaultAttrs</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--value/style.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mySection3View_defaultAttrs&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:background&quot;</span>&gt;</span>@android:color/black<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果你去对照官方控件的写法，你会发现他们的构造函数也是这样写的，前三个都是调用 <code>this()</code>，只有最后一个调用   <code>super()</code>，但他们一般只设置了 <code>R.attr.mySection3View_attrs</code>，用于开发者在 theme 中定义全局属性（[第三点](#3、在 theme 中设置某种控件的默认属性)），而 <code>R.style.mySection3View_defaultAttrs</code> 在官网控件中一般没设置，都是写个 0，代表没得默认属性</p><blockquote><p>为什么有两个默认属性？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">Context context, </span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> AttributeSet attrs, </span><br><span class="hljs-params"><span class="hljs-type">int</span> defStyleAttr, </span><br><span class="hljs-params"><span class="hljs-type">int</span> defStyleRes</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure><p>你会发现第三个参数 <code>defStyleAttr</code> 和第四个 <code>defStyleRes</code> 都是设置默认参数，但为什么要同时存在两个呢？</p><p>原因：<code>defStyleAttr</code> 是从 theme 中读取默认值，但如果我们只能动态生成 View，又需要多次用到一些属性，在 Android 5.0 之前要么每次都手动调用方法来设置，要么写在 theme 中，但这样未免麻烦了些，在 Android 5.0 后增加了这个 <code>defStyleRes</code> 参数，就可以直接把属性写在 <code>style.xml</code> 中，方便复用</p><p><strong>但这里有很重要的一点：</strong>使用 <code>defStyleRes</code> 时不能设置 <code>defStyleAttr</code>，给 <code>defStyleAttr</code> 填入 0 或者 theme 中不设置对应的属性即可</p></blockquote><p>回到这里，前面 java 的写法确实感觉有些臃肿了，我们来看看 kt 的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 必须添加 @JvmOverloads，不然 java 层无法使用该构造器</span><br><span class="hljs-comment">// 会导致 xml 中的 View 无法生成</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Section3ViewKt</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context,<br>    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = R.attr.mySection3View_attrs,<br>    defStyleRes: <span class="hljs-built_in">Int</span> = R.style.mySection3View_defaultAttrs<br>) : View(context, attrs, defStyleAttr, defStyleRes) &#123;<br>&#125;<br><span class="hljs-comment">// 如果你没得 R.attr.mySection3View 或 R.style.MySection3View_defaultAttrs</span><br><span class="hljs-comment">// 可以直接赋值为 0，就是没得默认属性设置</span><br></code></pre></td></tr></table></figure><p><strong>讲到这里，构造函数中的四个参数各位应该知道有什么作用了，这里我们总结一下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(Context context)</span><br><span class="hljs-comment">// 用于在代码中动态生成自定义 View</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">    Context context, </span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> AttributeSet attrs</span><br><span class="hljs-params">)</span><br><span class="hljs-comment">// 用于写在 xml 里面系统调用</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">    Context context,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> AttributeSet attrs, </span><br><span class="hljs-params">    <span class="hljs-type">int</span> defStyleAttr</span><br><span class="hljs-params">)</span><br><span class="hljs-comment">// 用于设置全局默认属性值，通常是通过上面两个参数的构造函数来间接调用</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">    Context context, </span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> AttributeSet attrs, </span><br><span class="hljs-params">    <span class="hljs-type">int</span> defStyleAttr, </span><br><span class="hljs-params">    <span class="hljs-type">int</span> defStyleRes</span><br><span class="hljs-params">)</span><br><span class="hljs-comment">// 也是用于设置默认属性值，只是不用写在 theme 中，通常用于动态生成代码中或自己自定义 View 的时候</span><br></code></pre></td></tr></table></figure><p>前面讲了 4 种方式来设置属性，还有一种方式也可以来设置属性</p></blockquote><h4 id="5、直接在-theme-中定义属性"><a href="#5、直接在-theme-中定义属性" class="headerlink" title="5、直接在 theme 中定义属性"></a>5、直接在 theme 中定义属性</h4><blockquote><p>这个与第三点：[在 theme 中设置某种控件的默认属性](#3、在 theme 中设置某种控件的默认属性) 有些类似，但它值允许直接写在 theme 中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span> <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Theme.CustomViewWithAnimStudy&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--如果你加了这行代码，你会发现应用大部分控件变成黑色了--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:background&quot;</span>&gt;</span>@android:color/black<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>但是，</strong>这个是不分控件的给全部 View 设置属性，一般不会使用到它，只有设置整个应用的主题时会用到</p><p>比如你可以试试把这几个属性改一下，就会发现应用的标题栏颜色从紫色改成了你设置的颜色</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/purple_500<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryVariant&quot;</span>&gt;</span>@color/purple_700<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorOnPrimary&quot;</span>&gt;</span>@color/white<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorSecondary&quot;</span>&gt;</span>@color/teal_200<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorSecondaryVariant&quot;</span>&gt;</span>@color/teal_700<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorOnSecondary&quot;</span>&gt;</span>@color/black<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这些属性对应了某种具体位置的颜色，可以看看这篇博客：<a href="https://blog.csdn.net/smartzzg/article/details/104788412">https://blog.csdn.net/smartzzg/article/details/104788412</a></p><h3 id="五种属性定义方法的顺序"><a href="#五种属性定义方法的顺序" class="headerlink" title="五种属性定义方法的顺序"></a>五种属性定义方法的顺序</h3><blockquote><p>我们讲了有 5 种不同的属性定义，如果定义了相同属性，他们存在一个优先级顺序：</p><p>[1、直接写在 XML 中](#1、直接写在 XML 中)</p><p>[2、使用 @style 设置属性](#2、使用 @style 设置属性)</p><p>[3、在 theme 中设置某种控件的默认属性](#3、在 theme 中设置某种控件的默认属性)</p><p>[4、调用构造函数的 defStyleRes](#4、调用构造函数的 defStyleRes)</p><p>[5、直接在 theme 中定义属性](#5、直接在 theme 中定义属性)</p><p>这里注意：使用 <code>defStyleRes </code> 时不能设置 <code>defStyleAttr</code>，给 <code>defStyleAttr</code> 填入 0 或者 theme 中不设置对应的属性即可</p></blockquote><p><strong>到这里 View 的四个构造函数基本分析完毕了，接下来我们开始讲解里面的方法</strong></p></blockquote><h3 id="4、onDraw"><a href="#4、onDraw" class="headerlink" title="4、onDraw()"></a>4、onDraw()</h3><blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对 View 进行绘制</p><h3 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h3><ul><li>[Canvas 画布](#1、Canvas 画布)</li><li>[Paint 画笔](#2、Paint 画笔)</li><li>[Path 路径](#3、Path 路径)</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 该方法是一个回调，为什么是回调，在之后的 invalidate() 会进行讲解</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br><span class="hljs-keyword">super</span>.onDraw(canvas)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里讲一个小技巧：可以把 <code>Canvas?</code> 中的 <code>?</code> 为去掉</p><p>因为在 kt 重写 <code>onDraw()</code> 方法时，源代码 java 层中并没有给参数 <code>canvas</code> 加上 <code>@NonNull</code>，导致 kt 不知道它会不会为空，但我们作为开发者肯定是知道它不会为空的，所以去掉 <code>?</code>，可以减少后续的判断，不然很可能写出这样的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onDraw(canvas)<br>    canvas?.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>    canvas?.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>    canvas?.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>    canvas?.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>    canvas?.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>    canvas?.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>&#125;<br></code></pre></td></tr></table></figure><p>看着好像没得什么问题，不就多打了一个 <code>?</code> 吗？</p><p>确实看着没有什么问题，但你把 kt 转成 java，你就会发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Canvas canvas)</span> &#123;<br>   <span class="hljs-built_in">super</span>.onDraw(canvas);<br>   <span class="hljs-keyword">if</span> (canvas != <span class="hljs-literal">null</span>) &#123;<br>      canvas.drawRect(<span class="hljs-number">0.0F</span>, <span class="hljs-number">0.0F</span>, <span class="hljs-number">100.0F</span>, <span class="hljs-number">200.0F</span>, <span class="hljs-built_in">this</span>.mBlackPaint);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (canvas != <span class="hljs-literal">null</span>) &#123;<br>      canvas.drawRect(<span class="hljs-number">0.0F</span>, <span class="hljs-number">0.0F</span>, <span class="hljs-number">100.0F</span>, <span class="hljs-number">200.0F</span>, <span class="hljs-built_in">this</span>.mBlackPaint);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (canvas != <span class="hljs-literal">null</span>) &#123;<br>      canvas.drawRect(<span class="hljs-number">0.0F</span>, <span class="hljs-number">0.0F</span>, <span class="hljs-number">100.0F</span>, <span class="hljs-number">200.0F</span>, <span class="hljs-built_in">this</span>.mBlackPaint);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (canvas != <span class="hljs-literal">null</span>) &#123;<br>      canvas.drawRect(<span class="hljs-number">0.0F</span>, <span class="hljs-number">0.0F</span>, <span class="hljs-number">100.0F</span>, <span class="hljs-number">200.0F</span>, <span class="hljs-built_in">this</span>.mBlackPaint);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (canvas != <span class="hljs-literal">null</span>) &#123;<br>      canvas.drawRect(<span class="hljs-number">0.0F</span>, <span class="hljs-number">0.0F</span>, <span class="hljs-number">100.0F</span>, <span class="hljs-number">200.0F</span>, <span class="hljs-built_in">this</span>.mBlackPaint);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (canvas != <span class="hljs-literal">null</span>) &#123;<br>      canvas.drawRect(<span class="hljs-number">0.0F</span>, <span class="hljs-number">0.0F</span>, <span class="hljs-number">100.0F</span>, <span class="hljs-number">200.0F</span>, <span class="hljs-built_in">this</span>.mBlackPaint);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个 canvas 都单独判断了一遍是否为空，不知道你们怎么想，但我的强迫症不允许出现这种情况，所以建议各位写自定义 View 时，把方法参数中可以去掉 <code>?</code> 的顺手给去掉</p><p>除了 <code>onDraw()</code> 以外，还有 <code>override fun onTouchEvent(event: MotionEvent?)</code> 的 <code>?</code> 也可以去掉</p><blockquote><p>怎么看 kt 转成的 java 代码？</p> <img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320161207313.png" alt="image-20220320161207313" style="zoom:50%;" /> <img src="C:/Users/%E9%83%AD%E7%A5%A5%E7%91%9E/AppData/Roaming/Typora/typora-user-images/image-20220320144121673.png" alt="image-20220320144121673" style="zoom:50%;" /></blockquote><p>接下来我们开始讲解 <code>onDraw()</code> 需要的其他知识</p></blockquote></blockquote><h4 id="1、Canvas-画布"><a href="#1、Canvas-画布" class="headerlink" title="1、Canvas 画布"></a>1、Canvas 画布</h4><blockquote><p>由于时间原因，这里不会讲得很详细，你们可以在这些地方进行学习：</p><ul><li><a href="https://carsonho.blog.csdn.net/article/details/60598775">https://carsonho.blog.csdn.net/article/details/60598775</a></li><li><a href="https://qijian.blog.csdn.net/article/details/50995268">https://qijian.blog.csdn.net/article/details/50995268</a></li></ul><table><thead><tr><th>参数</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td><em><strong>canvas</strong></em></td><td>Canvas</td><td>字面翻译是“帆布”，你可以看成是系统底层给了你一张“画布”（canvas），然后你在这张画布上进行绘图</td></tr></tbody></table><p>那怎么进行画图呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这个 paint 你可以把它看成是“画笔”</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mBlackPaint = Paint().apply &#123;<br>color = Color.BLACK <span class="hljs-comment">// 设置画笔颜色为黑色</span><br>&#125;<br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br><span class="hljs-keyword">super</span>.onDraw(canvas)<br><span class="hljs-comment">// 画一个 (0, 0) - (100, 200) 的黑色矩形</span><br>canvas.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面代码，调用 <code>canvas.drawRect()</code> 就可以画一个黑色矩形在 View 里面</p><p>接下来，我们看一下效果：</p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320144833039.png" alt="image-20220320144833039" style="zoom:50%;float:left" /><p>如果你没有自定义 View 基础的话，可能会觉得有些奇怪</p><p>我们从小学开始学的坐标系第一象限不是向上为 Y 正半轴，向右为 X 正半轴，那么按照惯性思维，(0, 0) - (100, 200) 为什么不是下图这样的？</p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320144833039.png" alt="image-20220320144833039" style="zoom:50%;transform:rotateX(180deg);float:left" /><p>其实原因在于 View 中坐标系的 y 轴是反过来的，我猜测是因为：为了设配手机的特点，比如我们看一些列表，都是手指往上滑动，查看下面的内容，所以为了好开发，View 中的坐标原点就设置在了左上角，向下为 Y 正半轴，向右为 X 正半轴</p><p>这个算是基础内容了，如果不知道的话，可以去看看这篇文章：<a href="https://blog.csdn.net/carson_ho/article/details/56009827">https://blog.csdn.net/carson_ho/article/details/56009827</a></p><p>Canvas 里面不止有绘制矩形的方法，还有绘制圆的方法，绘制文字的方法······，这里不会去讲解这些基础内容，可以去下面这些地方去查看：</p><ul><li><a href="https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/graphics/Canvas?hl=en">https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/graphics/Canvas?hl=en</a></li></ul></blockquote><h4 id="2、Paint-画笔"><a href="#2、Paint-画笔" class="headerlink" title="2、Paint 画笔"></a>2、Paint 画笔</h4><blockquote><p>前面的代码演示中出现了 <code>Paint</code>，这个类主要是管画笔的，除了设置颜色以外，他还可以设置线的粗细等</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这是我的某个自定义 View 设置的 Paint</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mCircleBackgroundPaint <span class="hljs-keyword">by</span> lazyUnlock &#123;<br>    Paint().apply &#123;<br>        color = mCircleBackground<br>        style = Paint.Style.FILL<br>        isAntiAlias = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Paint 的方法有很多，这里给出文章，你们有时间可以去看看，那本自定义黑书对于 Paint 的内容有点少，建议去看书作者写的文章，里面有很多其他高级用法</p><ul><li><a href="https://qijian.blog.csdn.net/article/details/50995268">https://qijian.blog.csdn.net/article/details/50995268</a></li></ul></blockquote><h4 id="3、Path-路径"><a href="#3、Path-路径" class="headerlink" title="3、Path 路径"></a>3、Path 路径</h4><blockquote><p>Path 表示路径，常用于绘制曲线，绘制不规则的图形等</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这是我的某个自定义 View 设置的 Path</span><br><span class="hljs-comment">// 主要是写了根据变化的 offset 值来计算圆的半径，最后绘制一个圆</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">drawFirstCircle</span><span class="hljs-params">(path: <span class="hljs-type">Path</span>, offset: <span class="hljs-type">Float</span>, total: <span class="hljs-type">Float</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> radio = abs(offset / total)<br>    <span class="hljs-keyword">val</span> startMove = <span class="hljs-number">0.6F</span><br>    <span class="hljs-keyword">val</span> k = <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> - startMove)<br>    <span class="hljs-keyword">val</span> b = <span class="hljs-number">1</span> - k<br>    <span class="hljs-keyword">val</span> y = offset / abs(offset) * max(<span class="hljs-number">0F</span>, k * radio + b) * total<br>    <span class="hljs-keyword">val</span> r = getNewRadius(y)<br>    <span class="hljs-keyword">val</span> dx = (outerX - abs(y)) / (outerR + r) * r<br>    <span class="hljs-keyword">val</span> dy = outerY / (outerR + r) * r<br>    firstPointX = <span class="hljs-keyword">if</span> (offset &gt; <span class="hljs-number">0</span>) dx + y <span class="hljs-keyword">else</span> -dx + y<br>    firstPointY = dy<br>    path.addCircle(y, <span class="hljs-number">0F</span>, r, Path.Direction.CCW)<br>&#125;<br></code></pre></td></tr></table></figure><p>方法有很多，这里不进行讲解，给出下面文章：</p><ul><li><a href="https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/graphics/Path?hl=en">https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/graphics/Path?hl=en</a></li><li><a href="https://carsonho.blog.csdn.net/article/details/60597923">https://carsonho.blog.csdn.net/article/details/60597923</a></li><li><a href="https://qijian.blog.csdn.net/article/details/50995268">https://qijian.blog.csdn.net/article/details/50995268</a></li></ul></blockquote><h4 id="4、其他东西"><a href="#4、其他东西" class="headerlink" title="4、其他东西"></a>4、其他东西</h4><blockquote><p>上面并没有列完基础知识，因为基础知识实在是太多了，这里是写不下的，接下来我讲一些其他经验性的东西</p></blockquote><h5 id="1、onDraw-里面禁止-new-对象"><a href="#1、onDraw-里面禁止-new-对象" class="headerlink" title="1、onDraw() 里面禁止 new 对象"></a>1、onDraw() 里面禁止 new 对象</h5><blockquote><p>很多初学者在刚开始写的时候很喜欢在 <code>onDraw()</code> 里面 new 对象，之前 <code>canvas.drawRect()</code> 不是要传入一个画笔吗？就会有人这样写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br> <span class="hljs-keyword">super</span>.onDraw(canvas)<br> <span class="hljs-keyword">val</span> blackPaint = Paint()<br> blackPaint.color = Color.BLACK<br> canvas.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, blackPaint)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写时 AS 还会报一个黄，告诉你这样写是不对的，但你知道为什么不对吗？</p><p>原因：<code>onDraw()</code> 在一直刷新视图时，在 60 帧的手机上会每隔 16 毫秒回调一次，90 帧的手机上每隔 11 毫秒回调一次（1000 ÷ 90），所以在一秒钟，60 帧的手机会生成 60 个 Paint 对象，90 帧手机生成 90 个对象，这样疯狂 new 对象，会让手机出现卡顿，这跟上节课讲的 <code>onBindViewHolder()</code> 不要写点击监听一样，但这个会比它更严重</p><p>但 AS 的智能提示并不是能发现所有的问题，比如下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br> <span class="hljs-keyword">super</span>.onDraw(canvas)<br> <span class="hljs-keyword">set</span> &#123; <br>     <span class="hljs-comment">// ...</span><br> &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">set</span><span class="hljs-params">(func: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br> func.invoke()<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况较难发现，这样写每次都会生成一个匿名内部类，建议加上 <code>inline</code> 关键字</p><p><strong>该禁令同样适用于 <code>onMeasure()</code>、<code>onLayout()</code>！</strong></p></blockquote><h5 id="2、不要在-onDraw-里面进行耗时操作"><a href="#2、不要在-onDraw-里面进行耗时操作" class="headerlink" title="2、不要在 onDraw() 里面进行耗时操作"></a>2、不要在 onDraw() 里面进行耗时操作</h5><blockquote><p>原因跟上面一样</p><p><strong>该禁令同样适用于 <code>onMeasure()</code>、<code>onLayout()</code>！</strong></p></blockquote><h5 id="3、不要持有-canvas-对象"><a href="#3、不要持有-canvas-对象" class="headerlink" title="3、不要持有 canvas 对象"></a>3、不要持有 canvas 对象</h5><blockquote><p>每次回调的 canvas 对象并不是一定是同一个（大部分情况下是同一个），而且每次的回调只能表示当前帧的状态，比如我们来个违规操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br> <span class="hljs-keyword">super</span>.onDraw(canvas)<br> <span class="hljs-comment">// 开一个线程模拟持有 canvas 对象</span><br> thread &#123;<br>     <span class="hljs-comment">// 延迟 20 毫秒才绘图</span><br>     sleep(<span class="hljs-number">20</span>)<br>     canvas.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可能猜都猜不到它把图绘制到哪里去了</p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320163052101.png" alt="image-20220320163052101" style="zoom:50%;float:left" /><p>好家伙，它竟然把图绘制到标题栏上了，这里猜测原因如下（没有去查看源码找真正原因）：</p><ul><li>整个应用共用了同一个 canvas 对象</li><li>因开启线程后 sleep，所以 canvas 是整个应用绘制完成后再调用的 <code>canvas.drawRect()</code></li><li><strong>标题栏是在最后进行绘制的</strong>，此时的 canvas 的坐标系是以标题栏为准的</li></ul><p>这怎么验证呢？</p><blockquote><p>你把开发者模式模式的 <code>显示布局边界</code> 给打开，你会看到下面这种图：</p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320164459116.png" alt="image-20220320164459116" style="zoom: 67%;float:left" /><p>这里说明标题栏的文字是一个 View 来显示的</p><p>那我们试试把标题栏给去掉会发生什么？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--theme.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320164844556.png" alt="image-20220320164844556" style="zoom: 67%;float:left" /><p>嘿，去掉标题栏后绘制的位置对了，所以这里我提出猜测：标题栏是在最后进行绘制的</p><p>其实我们可以验证一下这个猜测，写一个在它后面绘制的 View 验证下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.ndhzs.lib.section4.MySection4ViewCanvas</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;300dp&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;300dp&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320165148269.png" alt="image-20220320165148269" style="zoom: 67%;float:left" /><p>果然，我的猜测应该是合理的</p></blockquote></blockquote><h5 id="4、自定义-View-和-ViewGroup-在绘制中的不同"><a href="#4、自定义-View-和-ViewGroup-在绘制中的不同" class="headerlink" title="4、自定义 View 和 ViewGroup 在绘制中的不同"></a>4、自定义 View 和 ViewGroup 在绘制中的不同</h5><blockquote><p>在自定义 ViewGroup 中，一般不会重写 <code>onDraw()</code>，因为 ViewGroup 对 <code>onDraw()</code> 进行了处理，只有在<strong>有背景图时</strong>，才会调用 <code>onDraw()</code>，所以在自定义 ViewGroup 时想绘图一般是重写 <code>dispatchDraw(Canvas canvas)</code>，这个方法也可以决定是绘制在子 View 上层还是子 View 下层，具体的你们自己去实践一下吧，这里给出文章链接：<a href="https://www.jianshu.com/p/89efaf8bd3dd">https://www.jianshu.com/p/89efaf8bd3dd</a></p></blockquote><h4 id="5、onDraw-的绘制流程"><a href="#5、onDraw-的绘制流程" class="headerlink" title="5、onDraw() 的绘制流程"></a>5、onDraw() 的绘制流程</h4><blockquote><p>这东西属于高阶内容，限于时间关系，这里我就不讲了，可以看看这些文章：</p><ul><li><a href="https://blog.csdn.net/carson_ho/article/details/56011153">https://blog.csdn.net/carson_ho/article/details/56011153</a></li><li><a href="https://github.com/Idtk/Blog/blob/master/Blog/9%E3%80%81Invalidate.md">https://github.com/Idtk/Blog/blob/master/Blog/9%E3%80%81Invalidate.md</a></li></ul></blockquote><h3 id="5、invalidate"><a href="#5、invalidate" class="headerlink" title="5、invalidate()"></a>5、invalidate()</h3><blockquote><p>这东西你目前只需要记住以下几点就可以了：</p><ul><li>调用后会在<strong>下一帧回调</strong> <code>onDraw()</code> 进行刷新</li><li>下一帧是指下一次屏幕刷新的时候</li></ul><p>如果你想探究源码的话，我只能丢文章出来了：</p><ul><li><a href="https://juejin.cn/post/7017452765672636446">https://juejin.cn/post/7017452765672636446</a></li></ul><p>OK，这个方法讲完了，因为往深了讲，会涉及到 Handler 机制、ViewRootImpl 等 Framwork 层源码</p><p>哦，想起了，还要一点，除了 <code>invalidate()</code> 外还有一个 <code>postInvalidate()</code> 用于在其他线程里刷新</p><p>但考虑到可能会有其他学长来听课，我还是画一个简单的流程图</p><pre><code class=" mermaid">graph TBid1(&quot;View&quot;)--&gt;id2id2[&quot;调用invalidate()刷新&quot;]--&gt;id3id3&#123;&quot;parent == null&quot;&#125;--不为 null--&gt;id4id4[&quot;告诉父布局有子布局要重绘&quot;]--&gt;id3--为 null--&gt;id5id5[&quot;传递到了 ViewRootImpl (一个管理布局的类)&quot;]--&gt;id6id6[&quot;ViewRootImpl 调用 mChoreographer 发送一个 post (一个专门监听屏幕刷新的类)&quot;]-.-&gt;id7id7[&quot;屏幕刷新了，回调 ViewRootImpl，开始重新走 View 测量和绘图流程&quot;]--&gt;id8id8(&quot;从顶部布局最后回调到 View 的 onDraw()&quot;)</code></pre><p>其实还有亿点细节，这里我就不讲述了，自己看下面图，其实这图仍有许多没有画上</p><pre><code class=" mermaid">sequenceDiagramView-&gt;&gt;View: invalidate()View-&gt;&gt;ViewGroup: invalidateChild()alt 如果是硬件加速ViewGroup-&gt;&gt;other ViewGroups: onDescendantInvalidated()other ViewGroups-&gt;&gt;DecorView: onDescendantInvalidated()DecorView-&gt;&gt;ViewRootImpl: onDescendantInvalidated()ViewRootImpl-&gt;&gt;ViewRootImpl: invalidate()else 如果是软件加速ViewGroup-&gt;&gt;other ViewGroups: invalidateChildInParent()other ViewGroups-&gt;&gt;DecorView: invalidateChildInParent()DecorView-&gt;&gt;ViewRootImpl: invalidateChildInParent()ViewRootImpl-&gt;&gt;ViewRootImpl: invalidateRectOnScreen()endViewRootImpl-&gt;&gt;ViewRootImpl: scheduleTraversals()ViewRootImpl-&gt;&gt;Choreographer: postCallback(mTraversalRunnable)Choreographer-&gt;&gt;Handler: sendMessage*()Handler-&gt;&gt;Handler: 等到下一次屏幕刷新Handler-&gt;&gt;ViewRootImpl: mTraversalRunnable.run()ViewRootImpl-&gt;&gt;ViewRootImpl: doTraversal()ViewRootImpl-&gt;&gt;ViewRootImpl: performTraversals()ViewRootImpl-&gt;&gt;ViewRootImpl: performDraw()ViewRootImpl-&gt;&gt;DecorView: draw()DecorView-&gt;&gt;other ViewGroups: draw()other ViewGroups-&gt;&gt;ViewGroup: draw()ViewGroup-&gt;&gt;View: draw()View-&gt;&gt;View: onDraw()</code></pre><p>END</p></blockquote><h3 id="6、自定义属性-AttributeSet"><a href="#6、自定义属性-AttributeSet" class="headerlink" title="6、自定义属性 AttributeSet"></a>6、自定义属性 AttributeSet</h3><blockquote><p>前面我们提到系统会把你 xml 中写得属性装换为一个 AttributeSet 对象，那我们怎么自定义自己的属性呢？</p><p>首先，需要新建一个 <code>res/value/attrs.xml</code> 文件，比如我想要自定义一个圆半径的属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br> <span class="hljs-comment">&lt;!--这个 name 是 View 的类名--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MySection6View&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--这个 name 是自定义属性的名称，formate 是接受的类型--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my6_circleRadius&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上述代码，这里有需要注意的一点：</p><ul><li>自定义属性的名称不能与官方的重复，而且建议加上前缀，与官方的进行区分，比如我就加上了 <code>my6_</code></li></ul><p><code>formate</code> 有下面几种类型：</p><table><thead><tr><th>类型</th><th>说明</th><th>用法</th><th></th></tr></thead><tbody><tr><td><em><strong>dimension</strong></em></td><td>长度值</td><td>“1dp”、”1px”、”@dimen&#x2F;xxx”</td><td>这里无所谓 dp、px，系统会最终装换成 px</td></tr><tr><td><em><strong>reference</strong></em></td><td>引用值</td><td>“@drawable&#x2F;xxx”、”@style&#x2F;xxx”</td><td></td></tr><tr><td><em><strong>color</strong></em></td><td>颜色值</td><td>“#FFFFFFFF”、”@color&#x2F;xxx”</td><td></td></tr><tr><td><em><strong>float</strong></em></td><td>小数</td><td>“1.0”</td><td></td></tr><tr><td><em><strong>boolean</strong></em></td><td>布尔类型</td><td>“true”、”@bool&#x2F;xxx”</td><td></td></tr><tr><td><em><strong>interger</strong></em></td><td>整数</td><td>“1”、”@interget&#x2F;xxx”</td><td></td></tr><tr><td><em><strong>string</strong></em></td><td>字符串</td><td>“string”、”@string&#x2F;xxx”</td><td></td></tr><tr><td><em><strong>fraction</strong></em></td><td>百分数</td><td>“50%”、”@fraction&#x2F;xxx”</td><td></td></tr><tr><td><em><strong>enum</strong></em></td><td>枚举</td><td><a href="#enum">看下文</a></td><td></td></tr><tr><td><em><strong>flag</strong></em></td><td>位运算</td><td><a href="#flag">看下文</a></td><td></td></tr></tbody></table><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--比如我设置圆的位置属性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my6_circleGravity&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;enum&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320195658810.png" alt="image-20220320195658810" style="zoom:50%;float:left" /><p>设置后在使用时它的属性就只能选择你填写的那几个</p></blockquote><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><blockquote><p>就是进行位运算，这里我们以 FrameLayout 的 <code>layout_gravity</code> 为例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;layout_gravity&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--0011 0000--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;top&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x30&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--0101 0000--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bottom&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x50&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--0000 0011--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x03&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--0000 0101--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x05&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--0001 0000--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center_vertical&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x10&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--0000 0001--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x01&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--0001 0001--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x11&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;start&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x00800003&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;end&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x00800005&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>你是否还记得你曾经这样使用过？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;top|left&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>这里你会发现它把 <code>top|left</code> 报黄了，原因在于它推荐你使用 <code>start</code> 去代替 <code>left</code>，因为在部分国家是从右边往左边阅读文字的，所以，Android 为了国际化，就设计出了 <code>start</code> 代替 <code>left</code>，<code>end</code> 代替 <code>right</code></p></blockquote></blockquote><h3 id="类型的混用"><a href="#类型的混用" class="headerlink" title="类型的混用"></a>类型的混用</h3><blockquote><p>比如 <code>android:layout_width</code> 是这样定义的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;layout_width&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fill_parent&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;-1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;-1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;-2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>还有 <code>android:background</code> 是这样定义的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;background&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;reference|color&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>所以你传入 <code>@drawable/xxx</code> 和 <code>#FFFFFFFF</code>，它都可以获取，只是填入颜色值时使用 <code>TypedValue#getDrawable()</code> 得到是 ColorDrawable</p><p>也支持这样混用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--这是 View 的一个属性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;focusable&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;boolean|enum&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;auto&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x00000010&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但这样使用只能手动去判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFocusableAttribute</span><span class="hljs-params">(TypedArray attributes)</span> &#123;<br>    <span class="hljs-type">TypedValue</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypedValue</span>();<br>    <span class="hljs-keyword">if</span> (attributes.getValue(com.android.internal.R.styleable.View_focusable, val)) &#123;<br>        <span class="hljs-keyword">if</span> (val.type == TypedValue.TYPE_INT_BOOLEAN) &#123;<br>            <span class="hljs-keyword">return</span> (val.data == <span class="hljs-number">0</span> ? NOT_FOCUSABLE : FOCUSABLE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> val.data;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> FOCUSABLE_AUTO;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>前面讲了类型的定义，那我们怎么获取这些属性呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mCircleRadius = <span class="hljs-number">100</span><br><span class="hljs-comment">// 这个 enum 属性更建议使用枚举来保存，官方通常使用的注解，但 kt 很怪，注解不起作用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mCircleGravity = <span class="hljs-number">0</span><br><span class="hljs-keyword">init</span> &#123;<br>    <span class="hljs-keyword">if</span> (attrs != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 主要就是调用下面这个方法去获取属性</span><br>        <span class="hljs-keyword">val</span> ty = context.obtainStyledAttributes(attrs, R.styleable.MySection6View)<br>        mCircleRadius = ty.getDimensionPixelSize(<br>            R.styleable.MySection6View_my6_circleRadius,<br>            mCircleRadius<br>        )<br>        mCircleGravity = ty.getInt(<br>            R.styleable.MySection6View_my6_circleGravity,<br>            mCircleGravity<br>        )<br>        ty.recycle()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还好只有两个属性，但如果有多达上百个属性这样写未免太占行数了，所以，秉持着少写代码的原则，我使用了 kt 扩展函数来优化（下面是我写的课表自定义 View）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 先把属性的读取单独提取到一个类中</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NetLayout</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context,<br>    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = R.attr.netLayoutStyle,<br>    defStyleRes: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : ViewGroup(context, attrs, defStyleAttr, defStyleRes), INetLayout &#123;<br>    <span class="hljs-comment">// 属性值</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> mNetAttrs: NetLayoutAttrs = NetLayoutAttrs.newInstance(<span class="hljs-keyword">this</span>, attrs)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 我把属性单独写在了一个类里面</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NetLayoutAttrs</span>(<br>    rowCount: <span class="hljs-built_in">Int</span>,<br>    columnCount: <span class="hljs-built_in">Int</span><br>) : BaseViewAttrs &#123;<br><br>    <span class="hljs-keyword">var</span> rowCount = rowCount<br>        <span class="hljs-keyword">internal</span> <span class="hljs-keyword">set</span><br>    <span class="hljs-keyword">var</span> columnCount = columnCount<br>        <span class="hljs-keyword">internal</span> <span class="hljs-keyword">set</span><br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newInstance</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            view: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            attrs: <span class="hljs-type">AttributeSet</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">            defStyleAttr: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            defStyleRes: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>: NetLayoutAttrs &#123;<br>            <span class="hljs-keyword">return</span> newAttrs(<br>                view,<br>                attrs,<br>                R.styleable.NetLayout,<br>                defStyleAttr,<br>                defStyleRes<br>            ) &#123;<br>                <span class="hljs-comment">// 这里你就会看到直接使用 R.styleable.xxx.int() 来获取属性，这样写起来舒服多了</span><br>                NetLayoutAttrs(<br>                    R.styleable.NetLayout_net_rowCount.int(ROW_COUNT),<br>                    R.styleable.NetLayout_net_columnCount.int(COLUMN_COUNT)<br>                )<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ROW_COUNT = <span class="hljs-number">4</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> COLUMN_COUNT = <span class="hljs-number">4</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这是定义扩展函数的接口</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BaseViewAttrs</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">newAttrs</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        view: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        attrs: <span class="hljs-type">AttributeSet</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@StyleableRes</span></span></span><br><span class="hljs-params"><span class="hljs-function">        styleableId: <span class="hljs-type">IntArray</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        defStyleAttr: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        defStyleRes: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        func: <span class="hljs-type">Typedef</span>.() -&gt; <span class="hljs-type">T</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: T = BaseViewAttrs.newAttrs(view, attrs, styleableId, defStyleAttr, defStyleRes, func)<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">newAttrs</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            view: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            attrs: <span class="hljs-type">AttributeSet</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-meta">@StyleableRes</span></span></span><br><span class="hljs-params"><span class="hljs-function">            styleableId: <span class="hljs-type">IntArray</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            defStyleAttr: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            defStyleRes: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            func: <span class="hljs-type">Typedef</span>.() -&gt; <span class="hljs-type">T</span></span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>: T &#123;<br>            <span class="hljs-keyword">val</span> ty = view.context.obtainStyledAttributes(attrs, styleableId, defStyleAttr, defStyleRes)<br>            <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;<br>                <span class="hljs-comment">// 这是保存在 Debug 模式中能看到的信息，具体怎么查看，你可以去看看这个方法的源码</span><br>                view.saveAttributeDataForStyleable(<br>                    view.context, styleableId, attrs, ty, defStyleAttr, defStyleRes)<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> Typedef(ty, view.context).func()<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                ty.recycle()<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Typedef</span>(<span class="hljs-keyword">val</span> ty: TypedArray, <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> context: Context) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">int</span><span class="hljs-params">(defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.int(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">color</span><span class="hljs-params">(defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.color(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">colorById</span><span class="hljs-params">(<span class="hljs-meta">@ColorRes</span> defValueId: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.color(<br>            ContextCompat.getColor(context, defValueId))<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">dimens</span><span class="hljs-params">(defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.dimens(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">dimens</span><span class="hljs-params">(defValue: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> = <span class="hljs-keyword">this</span>.dimens(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">layoutDimens</span><span class="hljs-params">(defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.layoutDimens(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">dimensById</span><span class="hljs-params">(<span class="hljs-meta">@DimenRes</span> defValueId: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span><br>        .dimens(context.resources.getDimensionPixelSize(defValueId))<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">string</span><span class="hljs-params">(defValue: <span class="hljs-type">String</span>? = <span class="hljs-literal">null</span>)</span></span>: String = <span class="hljs-keyword">this</span>.string(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">boolean</span><span class="hljs-params">(defValue: <span class="hljs-type">Boolean</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = <span class="hljs-keyword">this</span>.boolean(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">float</span><span class="hljs-params">(defValue: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> = <span class="hljs-keyword">this</span>.float(ty, defValue)<br>        <span class="hljs-keyword">internal</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> E: RuntimeException&gt;</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">intOrThrow</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            attrsName: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.intOrThrow&lt;E&gt;(ty, attrsName)<br>        <span class="hljs-keyword">internal</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> E: RuntimeException&gt;</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">stringOrThrow</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            attrsName: <span class="hljs-type">String</span>)</span></span>: String = <span class="hljs-keyword">this</span>.stringOrThrow&lt;E&gt;(ty, attrsName)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">int</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getInt(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">color</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getColor(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">dimens</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getDimensionPixelSize(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">dimens</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getDimension(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">layoutDimens</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getLayoutDimension(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">string</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">String</span>? = <span class="hljs-literal">null</span>)</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> ty.getString(<span class="hljs-keyword">this</span>) ?: defValue ?: <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">boolean</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Boolean</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getBoolean(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">float</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getFloat(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> E: RuntimeException&gt;</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">intOrThrow</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    ty: <span class="hljs-type">TypedArray</span>, attrsName: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">if</span> (!ty.hasValue(<span class="hljs-keyword">this</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> E::<span class="hljs-keyword">class</span>.java.getConstructor(String::<span class="hljs-keyword">class</span>.java)<br>            .newInstance(<span class="hljs-string">&quot;属性 <span class="hljs-variable">$attrsName</span> 没有被定义！&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.int(ty, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> E: java.lang.RuntimeException&gt;</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">stringOrThrow</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    ty: <span class="hljs-type">TypedArray</span>, attrsName: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: String &#123;<br>    <span class="hljs-keyword">if</span> (!ty.hasValue(<span class="hljs-keyword">this</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> E::<span class="hljs-keyword">class</span>.java.getConstructor(String::<span class="hljs-keyword">class</span>.java)<br>            .newInstance(<span class="hljs-string">&quot;属性 <span class="hljs-variable">$attrsName</span> 没有被定义！&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.string(ty)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义-layout-属性"><a href="#自定义-layout-属性" class="headerlink" title="自定义 layout_ 属性"></a>自定义 layout_ 属性</h3><p>之前在我给大家上的 Android 第一节课讲过，父 View 是可以给子 View 额外添加属性的，且属性名以 <code>layout_</code> 开头</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--比如说这个里面所有 layout_ 开头的都是父 View 给子 View 添加的额外属性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;top|left&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那如何自定义 ViewGroup 如何设置自己想要的属性？</p><p>比如我给它添加一个表示子 View 位置的属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--注意：这种属性的设置必须以 _Layout 结尾，这是官方的规范！--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;My6ViewGroup_Layout&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--注意：属性名建议带有 layout_ 开头的标识--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my6VG_layout_position&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;integer&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在 xml 中写得时候，AS 会进行智能提示</p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321194906364.png" alt="image-20220321194906364" style="zoom:67%;" /><p>那怎么获取这个属性呢？</p><p>这个我们留到 <a href="#1%E3%80%81LayoutParams">LayoutParams</a> 再讲解</p></blockquote><h3 id="7、onMeasure"><a href="#7、onMeasure" class="headerlink" title="7、onMeasure()"></a>7、onMeasure()</h3><blockquote><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>测量自身和子控件大小</p><h3 id="涉及知识"><a href="#涉及知识" class="headerlink" title="涉及知识"></a>涉及知识</h3><ul><li><code>MeasureSpecs</code></li><li><code>LayoutParams</code></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 与上面讲的 onDraw() 一样，也是一个回调，该回调的作用是由 requestLayout() 触发</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(widthMeasureSpec: <span class="hljs-type">Int</span>, heightMeasureSpec: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主要用法"><a href="#主要用法" class="headerlink" title="主要用法"></a>主要用法</h3><ul><li>调用 <code>setMeasuredDimension()</code>，设置自身宽和高</li><li>遍历子 View，再调用 <code>child.measure()</code>，设置子 View 的宽和高</li></ul><pre><code class=" mermaid">graph LRid1(&quot;ViewRootImpl 开始测量&quot;)--&gt;id2id2[&quot;ViewGroup#mearsure()&quot;]--&gt;id3id3[&quot;ViewGroup#onMeasure()&quot;]--&gt;id4id4[&quot;View#measure()&quot;]--&gt;id5(&quot;View#onMeasure()&quot;)</code></pre></blockquote><h4 id="1、LayoutParams"><a href="#1、LayoutParams" class="headerlink" title="1、LayoutParams"></a>1、LayoutParams</h4><blockquote><p>这就是一个很简单的数据类，用于在子 View 中保存父类需要的信息</p><p>我们直接来看一下 FrameLayout 的 LayoutParams</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 你会发现这 LayoutParams 很简单</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LayoutParams</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MarginLayoutParams</span> &#123;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对应 layout_gravity 属性没有被设置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNSPECIFIED_GRAVITY</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这就是 layout_gravity 属性的保存值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> android.view.Gravity</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref android.R.styleable#FrameLayout_Layout_layout_gravity</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">gravity</span> <span class="hljs-operator">=</span> UNSPECIFIED_GRAVITY;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LayoutParams</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context c, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> &#123;<br>        <span class="hljs-built_in">super</span>(c, attrs);<br>        <span class="hljs-comment">// 看到这里你应该就能回答之前留下的问题了</span><br>        <span class="hljs-comment">// 父 View 读取子 View 中的属性是在 LayoutParams 中获取的</span><br>        <span class="hljs-comment">// 可能你会奇怪于 View 是什么时候开始加载 LayoutParams</span><br>        <span class="hljs-comment">// 这个留到后面讲 setContentView 再讲解</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">TypedArray</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> c.obtainStyledAttributes(attrs, R.styleable.FrameLayout_Layout);<br>        gravity = a.getInt(R.styleable.FrameLayout_Layout_layout_gravity, UNSPECIFIED_GRAVITY);<br>        a.recycle();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LayoutParams</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;<br>        <span class="hljs-built_in">super</span>(width, height);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LayoutParams</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> gravity)</span> &#123;<br>        <span class="hljs-built_in">super</span>(width, height);<br>        <span class="hljs-built_in">this</span>.gravity = gravity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LayoutParams</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup.LayoutParams source)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LayoutParams</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup.MarginLayoutParams source)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LayoutParams</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutParams source)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>        <span class="hljs-built_in">this</span>.gravity = source.gravity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要想使用这个 <code>LayoutParams</code> 还得重写这几个方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这个是检查 LayoutParams 是否是你想要的 LayoutParams</span><br><span class="hljs-comment">// 注意：这个 LayoutParams 是需要打个 ? 的，因为存在传入一个 null 的情况</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkLayoutParams</span><span class="hljs-params">(p: <span class="hljs-type">LayoutParams</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-comment">// 这是惯用写法</span><br>    <span class="hljs-keyword">return</span> p <span class="hljs-keyword">is</span> NetLayoutParams<br>&#125;<br><br><span class="hljs-comment">// 这个是通过 AttributeSet 得到你自己的 LayoutParmas</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">generateLayoutParams</span><span class="hljs-params">(attrs: <span class="hljs-type">AttributeSet</span>)</span></span>: LayoutParams &#123;<br>    <span class="hljs-keyword">return</span> NetLayoutParams(context, attrs)<br>&#125;<br><br><span class="hljs-comment">// 这个是装换 LayoutParms</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">generateLayoutParams</span><span class="hljs-params">(lp: <span class="hljs-type">LayoutParams</span>)</span></span>: LayoutParams &#123;<br>    <span class="hljs-comment">// 这也是惯用写法，注意：要把你 LayoutParams 的所有父类都要写完</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (lp) &#123;<br>        <span class="hljs-keyword">is</span> NetLayoutParams -&gt; NetLayoutParams(lp)<br>        <span class="hljs-keyword">is</span> MarginLayoutParams -&gt; NetLayoutParams(lp)<br>        <span class="hljs-keyword">else</span> -&gt; NetLayoutParams(lp)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这个是得到默认的 LayoutParams</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">generateDefaultLayoutParams</span><span class="hljs-params">()</span></span>: LayoutParams &#123;<br>    <span class="hljs-keyword">return</span> NetLayoutParams(<br>        NetLayoutParams.UNSET,<br>        NetLayoutParams.UNSET,<br>        NetLayoutParams.UNSET,<br>        NetLayoutParams.UNSET<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>这几个方法会在什么时候被调用，我们会在后面的 <a href="#1%E3%80%81LayoutInflater">LayoutInflater</a> 讲解</p></blockquote><h4 id="2、MeasureSpecs"><a href="#2、MeasureSpecs" class="headerlink" title="2、MeasureSpecs"></a>2、MeasureSpecs</h4><blockquote><p>推荐文章：<a href="https://www.jianshu.com/p/1260a98a09e9">https://www.jianshu.com/p/1260a98a09e9</a></p><p>它保存了测量模式和测量大小</p><p>比如上面代码中的：<code>widthMeasureSpec</code> 和 <code>heightMeasureSpec</code></p><p>可能你会比较疑惑它是怎么用一个 int 来保存的，其实原理很简单，它使用高 2 位保存测量模式，后 30 为测量大小</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用方式，原理就是位运算</span><br><span class="hljs-keyword">val</span> wSize = MeasureSpec.getSize(widthMeasureSpec)<br><span class="hljs-keyword">val</span> wMode = MeasureSpec.getMode(widthMeasureSpec)<br></code></pre></td></tr></table></figure><p>测量模式有以下三种：</p><table><thead><tr><th>模式</th><th>说明</th><th>应用场景</th></tr></thead><tbody><tr><td><em><strong>EXACTLY</strong></em></td><td>有具体值时</td><td>一般对应 <code>match_parent</code> 和具体的值</td></tr><tr><td><em><strong>AT_MOST</strong></em></td><td>自适应大小</td><td>一般对应 <code>wrap_content</code></td></tr><tr><td><em><strong>UNSPECIFIED</strong></em></td><td>可任意取值</td><td>只出现于 <code>ScrollView</code>、<code>ListView</code> 这类控件中</td></tr></tbody></table><p>重写 ViewGroup 时就是通过这些来判断子 View 应该取得的高度的</p><p>关于怎么取，可以看这个在 ViewGroup 中的方法，里面是常见情况时的取法，该方法在很多官方控件中被使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> spec 子 View 能得到的 MeasureSpecs，一般是父 View 的测量模式 + 想给出的大小</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> padding 间距值，一般这样填入：layoutParams.leftMargin + layoutParams.rightMargin</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> childDimension 子 View 的宽或者高，固定填入：child.width 或者 child.height</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getChildMeasureSpec</span><span class="hljs-params">(<span class="hljs-type">int</span> spec, <span class="hljs-type">int</span> padding, <span class="hljs-type">int</span> childDimension)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(spec); <span class="hljs-comment">// 测量模式</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">specSize</span> <span class="hljs-operator">=</span> MeasureSpec.getSize(spec); <span class="hljs-comment">// 测量长度</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, specSize - padding); <span class="hljs-comment">// 先减去间距值得到的最大长度</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">resultSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 保存最后的长度值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">resultMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 保存最后的测量，模式</span><br><br>    <span class="hljs-keyword">switch</span> (specMode) &#123;<br>    <span class="hljs-comment">// 如果测量模式是具体值，即一般对应父 View 为 match_parent 或者 确定值</span><br>    <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>        <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 假设子 View 固定为 100dp</span><br>            resultSize = childDimension;<br>            resultMode = MeasureSpec.EXACTLY;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>            <span class="hljs-comment">// 子 View 是 match_parent</span><br>            resultSize = size; <span class="hljs-comment">// 那结果值就是最大值</span><br>            resultMode = MeasureSpec.EXACTLY; <span class="hljs-comment">// 测量模式保持一样，为具体值</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>            <span class="hljs-comment">// 子 View 是 wrap_content</span><br>            resultSize = size;<br>            resultMode = MeasureSpec.AT_MOST; <span class="hljs-comment">// 改变测量模式为自适应大小</span><br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 如果测量模式是自适应大小，即一般对应父 View 为 wrap_content</span><br>    <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>        <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 假设子 View 固定为 100dp</span><br>            resultSize = childDimension;<br>            resultMode = MeasureSpec.EXACTLY;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>            <span class="hljs-comment">// 子 View 是 match_parent</span><br>            <span class="hljs-comment">// 这里比较重要</span><br>            <span class="hljs-comment">// 这里对应父 View 为 wrap_content，但子 View 却为 match_parent</span><br>            resultSize = size; <span class="hljs-comment">// 这里的意思是给出子 View 能得到的最大值</span><br>            resultMode = MeasureSpec.AT_MOST;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>            <span class="hljs-comment">// 子 View 是 wrap_content</span><br>            resultSize = size;<br>            resultMode = MeasureSpec.AT_MOST;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 如果测量模式是可任意取值，即一般对应父 View 为 ScrollView</span><br>    <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>        <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 假设子 View 固定为 100dp</span><br>            resultSize = childDimension;<br>            resultMode = MeasureSpec.EXACTLY;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>            <span class="hljs-comment">// 子 View 是 match_parent</span><br>            <span class="hljs-comment">// 这个 sUseZeroUnspecifiedMeasureSpec 变量用于兼容 Android 旧版本</span><br>            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;<br>            resultMode = MeasureSpec.UNSPECIFIED;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>            <span class="hljs-comment">// 子 View 是 wrap_content</span><br>            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;<br>            resultMode = MeasureSpec.UNSPECIFIED;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你以后开发自定义 ViewGroup，在给子 View 测量时我更推荐使用该方法，遵循官方的写法可以提高可读性</p></blockquote><h4 id="3、onMeasure-源码相关分析"><a href="#3、onMeasure-源码相关分析" class="headerlink" title="3、onMeasure() 源码相关分析"></a>3、onMeasure() 源码相关分析</h4><h5 id="1、FrameLayout-的-onMeasure-源码分析"><a href="#1、FrameLayout-的-onMeasure-源码分析" class="headerlink" title="1、FrameLayout 的 onMeasure() 源码分析"></a>1、FrameLayout 的 onMeasure() 源码分析</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接下来是起飞环节</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> getChildCount();<br><br> <span class="hljs-comment">// 判断自身是否有一边不是具体值，作用如下：</span><br> <span class="hljs-comment">// 比如 FrameLayout 的宽是 wrap_content，但其中一个子 View 宽为 match_parent</span><br> <span class="hljs-comment">// 那么这个时候 FrameLayout 是不知道该给这个子 View 宽度多少的</span><br> <span class="hljs-comment">// 但我们可以通过其他 View 来判断 FrameLayout 能得到的宽度</span><br> <span class="hljs-comment">// 这个时候就知道 FraneLayout 宽度值能取多少了</span><br> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">measureMatchParentChildren</span> <span class="hljs-operator">=</span><br>         MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||<br>         MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;<br> <span class="hljs-comment">// 这个是保存上述所说的那种子 View，用于二次测量</span><br> mMatchParentChildren.clear(); <br><br> <span class="hljs-type">int</span> <span class="hljs-variable">maxHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <span class="hljs-type">int</span> <span class="hljs-variable">maxWidth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <span class="hljs-comment">// 状态值，用来记录子 View 是否得到了想要的大小，用的很少，忽略即可</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">childState</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br><br> <span class="hljs-comment">// 遍历所有子 View</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getChildAt(i);<br>     <span class="hljs-comment">// 这个 mMeasureAllChildren 是一个属性，作用：是否忽略 Gone 的影响</span><br>     <span class="hljs-comment">// child.getVisibility() != GONE：Gone 时不测量子 View</span><br>     <span class="hljs-comment">// 这个 Gone 时再自己写自定义 View 建议也判断上</span><br>     <span class="hljs-keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;<br>         <span class="hljs-comment">// measureChildWithMargins() 里面调用了测量子 View 的方法</span><br>         <span class="hljs-comment">// 之后会提到该方法，你只需要知道调用后可以得到子 View 测量的宽和高</span><br>         <span class="hljs-comment">// 但这个宽和高不是 width 和 height，而是 measuredWidth 和 measuredHeight</span><br>         measureChildWithMargins(child, widthMeasureSpec, <span class="hljs-number">0</span>, heightMeasureSpec, <span class="hljs-number">0</span>);<br>         <span class="hljs-comment">// 得到 LayoutParams，主要是从里面取得定义的 Margin 值</span><br>         <span class="hljs-keyword">final</span> <span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (LayoutParams) child.getLayoutParams();<br>         <span class="hljs-comment">// 保存子 View 中最大的宽度</span><br>         maxWidth = Math.max(maxWidth,<br>                 child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);<br>         <span class="hljs-comment">// 保存子 View 中最大的高度</span><br>         maxHeight = Math.max(maxHeight,<br>                 child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);<br>         <span class="hljs-comment">// 状态值，忽略即可，在 ViewRootImpl 中有使用，一般情况下自定义 View 不用</span><br>         childState = combineMeasuredStates(childState, child.getMeasuredState());<br>         <span class="hljs-comment">// 最开始的那个 boolean 值，用来保存是 match_parent 的 View</span><br>         <span class="hljs-keyword">if</span> (measureMatchParentChildren) &#123;<br>             <span class="hljs-keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||<br>                     lp.height == LayoutParams.MATCH_PARENT) &#123;<br>                 mMatchParentChildren.add(child);<br>             &#125;<br>         &#125;<br>     &#125;<br> &#125;<br><br> <span class="hljs-comment">// 最大值加上 padding 值</span><br> <span class="hljs-comment">// getPadding*WithForeground() 是内部方法，我们自己用时是使用 getPadding*() 代替</span><br> maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();<br> maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();<br><br> <span class="hljs-comment">// 检查最小值的设置</span><br> <span class="hljs-comment">// View 都自带了一个 android:minHeight 属性，自己自定义 View 时建议把这个适配一下</span><br> maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());<br> maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());<br><br> <span class="hljs-comment">// 得到前台的背景图，再与最大值比较</span><br> <span class="hljs-keyword">final</span> <span class="hljs-type">Drawable</span> <span class="hljs-variable">drawable</span> <span class="hljs-operator">=</span> getForeground();<br> <span class="hljs-keyword">if</span> (drawable != <span class="hljs-literal">null</span>) &#123;<br>     maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());<br>     maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());<br> &#125;<br><br> <span class="hljs-comment">// 关键方法，调用 setMeasuredDimension() 设置自身宽和高</span><br> setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),<br>         resolveSizeAndState(maxHeight, heightMeasureSpec,<br>                 childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));<br><br> <span class="hljs-comment">// 在上面那个调用过后，就能得到自身的宽和高了</span><br> <span class="hljs-comment">// 然后这里再重写测量为 match_parent 的 View</span><br> count = mMatchParentChildren.size();<br> <span class="hljs-comment">// 这个 count 判断我个人感觉有点问题</span><br> <span class="hljs-comment">// count 是指为 match_parent View 的数量，</span><br> <span class="hljs-comment">// 而如果我只有一个 View 是 match_parent，那它不是就不会重新测量了吗？</span><br> <span class="hljs-comment">// 真奇怪，我感觉该用 childCount</span><br> <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> mMatchParentChildren.get(i);<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">MarginLayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (MarginLayoutParams) child.getLayoutParams();<br><br>         <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> childWidthMeasureSpec;<br>         <span class="hljs-keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;<br>             <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, getMeasuredWidth()<br>                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()<br>                        - lp.leftMargin - lp.rightMargin);<br>                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(<br>                        width, MeasureSpec.EXACTLY);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,<br>                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +<br>                        lp.leftMargin + lp.rightMargin,<br>                        lp.width);<br>            &#125;<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> childHeightMeasureSpec;<br>            <span class="hljs-keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, getMeasuredHeight()<br>                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()<br>                        - lp.topMargin - lp.bottomMargin);<br>                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(<br>                        height, MeasureSpec.EXACTLY);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,<br>                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +<br>                        lp.topMargin + lp.bottomMargin,<br>                        lp.height);<br>            &#125;<br>            <span class="hljs-comment">// 这里可以发现 onMeasure() 不止会调用一次，有时候需要调用多次才能测量完成 </span><br>            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure></blockquote><h5 id="2、NestedScrollView-嵌套-Rv-复用失效"><a href="#2、NestedScrollView-嵌套-Rv-复用失效" class="headerlink" title="2、NestedScrollView 嵌套 Rv 复用失效"></a>2、NestedScrollView 嵌套 Rv 复用失效</h5><blockquote><p>接下来开始做火箭</p><p>我们来分析一下我寒假时多次提到 NestedScrollView 嵌套 Rv，导致 Rv 复用失效的问题，网上我还没有看过很详细的从源码角度来分析的文章</p><p>首先我们要想想问什么会失效？</p><p>失效说明 Rv 把全部子 View 都测量完了，那说明肯定是 <code>onMeasure()</code> 的问题，ok，那我们来 debug 一下 <code>onMeasure()</code> 的整个流程</p><h5 id="首先从-NestedScrollView-的-onMeasure-开始-debug"><a href="#首先从-NestedScrollView-的-onMeasure-开始-debug" class="headerlink" title="首先从 NestedScrollView 的 onMeasure() 开始 debug"></a>首先从 NestedScrollView 的 onMeasure() 开始 debug</h5><blockquote><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321225743926.png" alt="image-20220321225743926"></p><p>可以发现 NestedScrollView 把测量直接交给了父类 FrameLayout 处理，（你可能会疑惑，不重写 <code>onMeasure()</code> 那 NestedScrollView 是怎么实现不同于其他 View 测量的？这个问题在下面会讲解）</p><p>又由于 <code>mFillViewport</code> 为 <code>false</code>，就直接 return 了，至于 <code>mFillViewport</code> 是什么我们后面会讲解</p></blockquote><h5 id="来到-FrameLayout-的-onMeasure-实现"><a href="#来到-FrameLayout-的-onMeasure-实现" class="headerlink" title="来到 FrameLayout 的 onMeasure() 实现"></a>来到 FrameLayout 的 onMeasure() 实现</h5><blockquote><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321230004519.png" alt="image-20220321230004519"></p><p>这里只有一个 View，就是 Rv，然后 FrameLayout 调用了 <code>measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0)</code>，这个函数被 NestedScrollView 重写了，然后给出了一个 <code>MeasureSpec.UNSPECIFIED</code>，这就是 NestedScrollView 不同于其他 View 测量的原因</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321230432739.png" alt="image-20220321230432739"></p><p>仔细看红线处，这里它给出的高度竟然直接为 <code>lp.topMargin + lp.bottomMargin</code>，可能你不会意识到这个有什么问题，我们来看看 NestedScrollView 的孪生兄弟 ScrollView 对于该方法的实现</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321230936516.png" alt="image-20220321230936516"></p><p>发现不同了吗，ScrollView 有个 <code>parentHeightMeasureSpec</code> 的高度，而 NestedScrollView 只使用了 <code>lp.topMargin + lp.bottomMargin</code>，如果子 View 没得 margin 值，那不就直接给子 View 传入的高度为 0 了？</p><p>NestedScrollView 与 ScrollView 在这个方法上的不同，就是造成 Rv 复用失效的直接原因，接下来我们探究一下根本原因</p></blockquote><h5 id="来到-Rv-的-onMeasure"><a href="#来到-Rv-的-onMeasure" class="headerlink" title="来到 Rv 的 onMeasure"></a>来到 Rv 的 onMeasure</h5><blockquote><p>紧接着上面继续 debug，我们来到了 Rv 的 <code>onMeasure()</code> 实现</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321231555746.png" alt="image-20220321231555746"></p><p>可以发现这里 <code>heightSpec</code> 为 0</p></blockquote><h5 id="来到-dispatchLayoutStep2-方法"><a href="#来到-dispatchLayoutStep2-方法" class="headerlink" title="来到 dispatchLayoutStep2() 方法"></a>来到 dispatchLayoutStep2() 方法</h5><blockquote><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321231735164.png" alt="image-20220321231735164"></p><p>前面那个 <code>dispatchLayoutStrp1()</code> 因为不处于 <code>State.STEP_START</code> 而跳过了</p></blockquote><h5 id="发现-mLayout-onLayoutChildren"><a href="#发现-mLayout-onLayoutChildren" class="headerlink" title="发现 mLayout.onLayoutChildren()"></a>发现 mLayout.onLayoutChildren()</h5><blockquote><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321232502431.png" alt="image-20220321232502431"></p><p>整个 <code>dispatchLayoutChild2()</code> 一看就只有这个方法是用于布局的，debug 进去试试</p></blockquote><h5 id="探索-onLayoutChild-方法"><a href="#探索-onLayoutChild-方法" class="headerlink" title="探索 onLayoutChild() 方法"></a>探索 onLayoutChild() 方法</h5><blockquote><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321233030377.png" alt="image-20220321233030377"></p><p>前面有一堆方法，但其实 Rv 是调用这个 <code>fill()</code> 来给子 View 布局的</p></blockquote><h5 id="探索-fill"><a href="#探索-fill" class="headerlink" title="探索 fill()"></a>探索 fill()</h5><blockquote><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321233713916.png" alt="image-20220321233713916"></p><p>这个 while 很重要，就是依靠这个循环来测量子 View 的，虽然你应该看的很懵逼，但请记住这两个东西：</p><p><code>layoutState.mInfinite = true</code> 和 <code>remainingSpace = 0</code>，后面的 <code>layoutState.hasMore(state)</code> 是用于判断次数是否达到 ItemCount 的，可以不用管</p><p>这里就直接告诉你结论，就是因为这个 <code>layoutState.mInfinite = true</code> 导致它一直执行循环，然后一直到 <code>layoutState.hasMore(state) = false</code> 才结束，即把 ItemCount 个 item 都测量完了</p><p>很懵逼是不是，我们来看看如果使用 ScrollView 包裹运行到这里时会怎么样？</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321234733578.png" alt="image-20220321234733578"></p><p>看到区别了吧，使用 ScrollView 时会不一样，其中 <code>layoutState.mInfinite = false</code> 和 <code>remainingSpace = 1868</code> </p><p>如果使用 ScrollView 继续往下走</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321234928364.png" alt="image-20220321234928364"></p><p>他会在这个地方减少 <code>remainingSpace</code> 的值，最后就可以使 while 循环提前退出了</p></blockquote><p>OK，基本上根本原因找到了，但为什么那个 <code>layoutState.mInfinite = true</code> 且 <code>remainingSpace = 0</code> 呢？</p><p>继续分析</p><h5 id="为什么-layoutState-mInfinite-x3D-true"><a href="#为什么-layoutState-mInfinite-x3D-true" class="headerlink" title="为什么 layoutState.mInfinite &#x3D; true ?"></a>为什么 layoutState.mInfinite &#x3D; true ?</h5><blockquote><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321235408579.png" alt="image-20220321235408579"></p><p>点击 <code>layoutState.mInfinite</code>，我们可以发现 <code>mLayoutState.mInfinite</code> 在这里被赋值</p><p>点进去看看它赋的什么值</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321235709470.png" alt="image-20220321235709470"></p><p>第一个 <code>getMode() == View.MeasureSpec.UNSPECIFIED</code> 肯定是 <code>true</code>，因为外布局是 NestedScrollView 嘛，前面提到了它重写了 FrameLayout 的 <code>measureChildWithMargins()</code> 方法，给的子 View 的测量模式是 <code>MeasureSpec.UNSPECIFIED</code> ，第二个判断 <code>mOrientationHelper.getEnd() == 0</code>，根据 debug 可以得到值也为 <code>true</code></p><p>继续跟踪 <code>mOrientationHelper.getEnd() == 0</code> 的原因</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000124439.png" alt="image-20220322000124439"></p><p>可以发现它直接调用了 <code>mLayoutManger.getHeight()</code>，继续</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000411111.png" alt="image-20220322000411111"></p><p><code>mHeight</code> 被修改的地方如下</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000630000.png" alt="image-20220322000630000"></p><p>其中前面两个是 <code>setRecyclerView()</code> 是在 Rv 添加 Adapter 时设置的初始值，肯定不是我们要找的地方，那只能是 <code>setMeasureSpecs()</code> 了</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000826091.png" alt="image-20220322000826091"></p><p>这里有一个 <code>mHeight = 0</code> 的操作，点击方法名称看看是谁调用了它</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000941813.png" alt="image-20220322000941813"></p><p>运气真好，刚好回到了我们之前大的断点前，那只能说明就是在这里调用的，所以 <code>mHeight = 0</code>，导致前面的 <code>mOrientationHelper.getEnd() == 0</code> 为 <code>true</code>，最后导致 <code>layoutState.mInfinite</code> 为 <code>true</code> 了 </p></blockquote><h5 id="为什么-remainingSpace-x3D-0？"><a href="#为什么-remainingSpace-x3D-0？" class="headerlink" title="为什么 remainingSpace &#x3D; 0？"></a>为什么 remainingSpace &#x3D; 0？</h5><blockquote><p>如果你大胆猜测的话，应该能猜到肯定与 <code>mHeight</code> 有关系</p><p>先来到这里</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322001506870.png" alt="image-20220322001506870"></p><p>我们可以知道 <code>remainingSpace</code> 由 <code>layoutState.mAvailable + layoutState.mExtraFillSpace</code> 组成，其中通过查看注释可以知道跟 <code>layoutState.mExtraFillSpace</code> 没有关系，那就去寻找 <code>layoutState.mAvailable</code> 吧</p><p>可是 <code>layoutState.mAvailable</code> 被改变的地方有点多，不是很好定位，那我们可以试试给这个变量打上断点，重新走一下流程，接下来就是重新 debug 一遍</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322002054498.png" alt="image-20220322002054498"></p><p>一下子就找到了，不得不说 debug 确实很方便</p><p>点击去看一下 <code>mOrientationHelper.getEndAfterPadding()</code> 方法</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322002252433.png" alt="image-20220322002252433"></p><p>果然，跟最开始的猜测一样，它与 <code>mHeight</code> 有关系</p><p>那 <code>updateLayoutStateToFillEnd()</code> 是在什么时候调用的呢？</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322002424079.png" alt="image-20220322002424079"></p><p>从调用栈发现原来他在 <code>fill()</code> 方法前被调用了</p><p>OK，这下子 NestedScrollView 嵌套 Rv 使复用失效的根本原因和决定性因素都找到了</p></blockquote><h3 id="如何解决复用失效问题？"><a href="#如何解决复用失效问题？" class="headerlink" title="如何解决复用失效问题？"></a>如何解决复用失效问题？</h3><p>根据上面的流程，我们可以找到下面这几种方法：</p><h5 id="1、重写-NestedScrollView-的-measureChildWithMargins-方法"><a href="#1、重写-NestedScrollView-的-measureChildWithMargins-方法" class="headerlink" title="1、重写 NestedScrollView 的 measureChildWithMargins() 方法"></a>1、重写 NestedScrollView 的 <code>measureChildWithMargins()</code> 方法</h5><blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重写该方法的几个原因：</span><br><span class="hljs-comment"> * 1、为了在 UNSPECIFIED 模式下，Rv 也能得到 NestedScrollView 的高度</span><br><span class="hljs-comment"> * 2、NestedScrollView 与 ScrollView 在对于子 View 高度处理时在下面这个方法不一样, 导致</span><br><span class="hljs-comment"> *    NestedScrollView 中子 View 必须使用具体的高度, 设置成 wrap_content 或 match_parent</span><br><span class="hljs-comment"> *    都将无效，具体的可以去看 ScrollView 和 NestedScrollView 中对于这同一方法的源码</span><br><span class="hljs-comment"> * 3、在 NestedScrollView 中嵌套 RecyclerView 会使 RecyclerView 的懒加载失效，直接原因就与</span><br><span class="hljs-comment"> *    这个方法有关，而使用 ScrollView 就不会造成懒加载失效的情况</span><br><span class="hljs-comment"> * 4、至于为什么 NestedScrollView 与 ScrollView 在该方法不同，我猜测原因是为了兼容以前的 Android 版本，</span><br><span class="hljs-comment"> *    在 ViewGroup#getChildMeasureSpec() 方法中可以发现使用了</span><br><span class="hljs-comment"> *    一个静态变量 sUseZeroUnspecifiedMeasureSpec</span><br><span class="hljs-comment"> *    来判断 UNSPECIFIED 模式下子 View 该得到的大小，但可能设计 NestedScrollView “偷懒”了，</span><br><span class="hljs-comment"> *    没有加这个东西，具体原因不知</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">measureChildWithMargins</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    child: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    parentWidthMeasureSpec: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    widthUsed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    parentHeightMeasureSpec: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    heightUsed: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> lp = child.layoutParams <span class="hljs-keyword">as</span> MarginLayoutParams<br><br>    <span class="hljs-keyword">val</span> childWidthMeasureSpec = getChildMeasureSpec(<br>        parentWidthMeasureSpec,<br>        paddingLeft + paddingRight + lp.leftMargin + lp.rightMargin<br>                + widthUsed, lp.width<br>    )<br>    <span class="hljs-comment">// 这里的写法与 ScrollView 里面的一样</span><br>    <span class="hljs-keyword">val</span> usedTotal = paddingTop + paddingBottom + lp.topMargin + lp.bottomMargin + heightUsed<br>    <span class="hljs-keyword">val</span> childHeightMeasureSpec: <span class="hljs-built_in">Int</span> = MeasureSpec.makeMeasureSpec(<br>        max(<span class="hljs-number">0</span>, MeasureSpec.getSize(parentHeightMeasureSpec) - usedTotal),<br>        MeasureSpec.UNSPECIFIED<br>    )<br><br>    child.measure(childWidthMeasureSpec, childHeightMeasureSpec)<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="2、直接给-Rv-设置固定高度"><a href="#2、直接给-Rv-设置固定高度" class="headerlink" title="2、直接给 Rv 设置固定高度"></a>2、直接给 Rv 设置固定高度</h5><blockquote><p>这个方法就可以直接修改 <code>mHeight</code> 的值，从之前的分析中可以得到<code>layoutState.mInfinite</code> 和 <code>remainingSpace</code> 都与 <code>mHeight</code> 有关，所以修改 <code>mHeight</code> 就可以从根源上解决复用失效问题</p></blockquote><h5 id="3、使用-mFillViewport-属性，但需要-NsetedScrollView-的-layout-height-x3D-match-parent-或-确定值"><a href="#3、使用-mFillViewport-属性，但需要-NsetedScrollView-的-layout-height-x3D-match-parent-或-确定值" class="headerlink" title="3、使用 mFillViewport 属性，但需要 NsetedScrollView 的 layout_height &#x3D; match_parent 或 确定值"></a>3、使用 mFillViewport 属性，但需要 NsetedScrollView 的 layout_height &#x3D; match_parent 或 确定值</h5><blockquote><p>前面在 <code>onMeasure()</code> 提到了一个 <code>mFillViewport</code> 变量</p><p>这是它的官方解释：</p><blockquote><p>设置此 ScrollView 是否应拉伸其内容高度以填充视口</p></blockquote><p>它对应这个属性：</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322003418726.png" alt="image-20220322003418726"></p><p>但再次之前我们先看一下，设置为 <code>true</code> 后 <code>onMeasure()</code> 干了些什么东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);<br>    <span class="hljs-comment">// mFillViewport 为 true 不会被 return 了</span><br>    <span class="hljs-keyword">if</span> (!mFillViewport) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">heightMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(heightMeasureSpec);<br>    <span class="hljs-keyword">if</span> (heightMode == MeasureSpec.UNSPECIFIED) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (getChildCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getChildAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">final</span> NestedScrollView.<span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (LayoutParams) child.getLayoutParams();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">childSize</span> <span class="hljs-operator">=</span> child.getMeasuredHeight();<br>        <br>        <span class="hljs-comment">// 关键在于这里，得到自身的测量高度</span><br>        <span class="hljs-comment">// 这个测量高度是之前调用 super.onMeasure() 而设置的</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parentSpace</span> <span class="hljs-operator">=</span> getMeasuredHeight()<br>                - getPaddingTop()<br>                - getPaddingBottom()<br>                - lp.topMargin<br>                - lp.bottomMargin;<br><br>        <span class="hljs-keyword">if</span> (childSize &lt; parentSpace) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">childWidthMeasureSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(widthMeasureSpec,<br>                    getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin,<br>                    lp.width);<br>            <span class="hljs-comment">// 给子 View 的测量模式使用了 MeasureSpec.EXACTLY</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">childHeightMeasureSpec</span> <span class="hljs-operator">=</span><br>                    MeasureSpec.makeMeasureSpec(parentSpace, MeasureSpec.EXACTLY);<br>            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面代码我们可以发现，设置 <code>mFillViewport = true</code> 后 NestedScrollView 会使用 <code>MeasureSpec.EXACTLY</code> 模式再次测量子 View，高度使用的是自身的高度</p><p>而自身的高度只有在 <code>match_parent</code> 或者 确定值 时才有用，不然，如果你的 <code>layout_height</code> 为 <code>wrap_content</code>，那 <code>NestedScrollView#getMeasuredHeight()</code> 得到仍然是 Rv 全部测量时的高度，所以这时再测量还是会导致 Rv 复用失效</p><p>使用 mFillViewport 属性，但需要 NsetedScrollView 的 <strong>layout_height &#x3D; match_parent 或 确定值</strong></p><p>但一般都不会使用到这个属性来解决 Rv 复用失效问题，这里只是当个扩展来讲解</p></blockquote><h5 id="问题：如果给-Rv-外面再包一层，那复用还会失效吗？"><a href="#问题：如果给-Rv-外面再包一层，那复用还会失效吗？" class="headerlink" title="问题：如果给 Rv 外面再包一层，那复用还会失效吗？"></a>问题：如果给 Rv 外面再包一层，那复用还会失效吗？</h5><blockquote><p>答案：仍然会失效</p><p>首先，我们知道失效的决定因素是 <code>mHeight == 0 &amp;&amp; mode == MeasureSpec.UNSPECIFIED</code>，而 NestedScrollView 在子 View 没有设置 Margin 值时给子 View 传入的高度肯定是 0</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321230936516.png" alt="image-20220321230936516"></p><p>而 <code>MeasureSpec.UNSPECIFIED</code> 测量模式具有传递性，前面我们提到 <code>getChildMeasureSpec()</code> 方法（<a href="#2%E3%80%81MeasureSpecs">MeasureSpecs</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果测量模式是可任意取值，即一般对应父 View 为 ScrollView</span><br><span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>    <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 假设子 View 固定为 100dp</span><br>        resultSize = childDimension;<br>        resultMode = MeasureSpec.EXACTLY;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>        <span class="hljs-comment">// 子 View 是 match_parent</span><br>        <span class="hljs-comment">// 这个 sUseZeroUnspecifiedMeasureSpec 变量用于兼容 Android 旧版本</span><br>        resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;<br>        resultMode = MeasureSpec.UNSPECIFIED;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>        <span class="hljs-comment">// 子 View 是 wrap_content</span><br>        resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;<br>        resultMode = MeasureSpec.UNSPECIFIED;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>可以看到除了 <code>childDimension &gt;= 0</code> 外其他情况测量模式都是 <code>MeasureSpec.UNSPECIFIED</code>，所以你中间夹一层其他布局是解决不了的</p></blockquote></blockquote><h5 id="3、Dialog-根布局设置宽高失效"><a href="#3、Dialog-根布局设置宽高失效" class="headerlink" title="3、Dialog 根布局设置宽高失效"></a>3、Dialog 根布局设置宽高失效</h5><blockquote><p>这个东西之前在寒假期间讲过，但才发现当时讲的有些小问题：</p><ul><li>只有 DialogFragment 才会使外层布局的所有 <code>layout_</code> 属性失效，而 Dialog 则<strong>一般</strong>不会</li></ul><p>其实也不是一般不会，主要是 DialogFragment 和 Dialog 在一个方法使用上的不同，所以为什么我最开始给那位学弟讲的<img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322180055610.png" alt="image-20220322180055610" style="zoom: 50%;" /></p><p>原来是我以为 dialog 能设置，那 DialogFragment 也能设置了，原来 DialogFragment 设置是失效的</p><p>这里直接先讲原因：</p><p>DialogFragment 是使用 <code>setContentView(View view)</code> 来设置根布局的，而 Dialog 一般使用 <code>setContentView(int id)</code> 来设置根布局，这两个方法在底层的调用会有些不同</p><p>我们直接从 DialogFragment 开始 debug</p><p>DialogFragment 是一个 Fragment，里面夹带了一个 dialog，根据 Fragment 常见的写法，先给 <code>onCreateView()</code> 打上 debug</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326185016280.png" alt="image-20220326185016280"></p><p>debug 进来发现一堆方法，但如果不了解这些东西的话，确实很难知道它把这个返回的 View 拿来干了什么，其实当时我在给那位学弟找这个问题答案的时候找了很久，最后是从 <code>View#setLayoutParams()</code> 方法入手，在一堆调用栈中发现了答案。这里为了省时间就直接按正向流程讲一遍吧</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322180533094.png" alt="image-20220322180533094"></p><p>这里它有一个 <code>LiveData</code> 通知观察者</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322180809792.png" alt="image-20220322180809792"></p><p>DialogFragment 里面对它进行了观察，DialogFragment 是在 <code>onAttach()</code> 的时候开始进行观察的，怪不得我按正常流程走了半天也找不到问题 :( </p><p>这里的观察者被通知时调用了 <code>mDialog.setContentView(view)</code>，点击它继续往下走</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322190910124.png" alt="image-20220322190910124"></p><p>可以发现这里它直接传入了自己的 LayoutParams，这就是为什么所有 <code>layout_</code> 属性全部失效的原因</p><p>那普通的 dialog 为什么不会失效呢？</p><p>主要原因是 dialog 一般是这样写的：</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322191150701.png" alt="image-20220322191150701"></p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322191527878.png" alt="image-20220322191527878" style="zoom: 50%;" /><p>可以看到它调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;mLayoutInflater.inflate(layoutResID, mContentParent);<br></code></pre></td></tr></table></figure><p>而不是使用的 <code>setContenView(View view)</code></p><p>至于 <code>LayoutInflater</code> 会在后面进行讲解，这里你只需要知道调用了这个方法后，它会读取 xml 文件，并把 xml 中写的 <code>layout_</code> 属性保存在一个 <code>LayoutParams</code> 中供父布局使用，所以这就是 DialogFragment 的 <code>layout_</code> 属性不会失效的原因，当然，只是一般不会失效，如果你非要在 dialog 中调用 <code>setContentView(View view)</code>，那肯定也是一样会失效的</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h5 id="1、在-DialogFragment-的根布局外面再包一层-FrameLayout"><a href="#1、在-DialogFragment-的根布局外面再包一层-FrameLayout" class="headerlink" title="1、在 DialogFragment 的根布局外面再包一层 FrameLayout"></a>1、在 DialogFragment 的根布局外面再包一层 FrameLayout</h5><blockquote><p>这样包了一层后就可以让你自己的布局的 <code>layout_</code> 在 FrameLayout 下生效，FrameLayout 的 <code>layout_width</code>、<code>layout_height</code> 任意设置都可以，因为失效了，但我更推荐设置成 <code>wrap_content</code>，这样看起来逻辑要好一点</p></blockquote><h5 id="2、通过代码设置宽和高"><a href="#2、通过代码设置宽和高" class="headerlink" title="2、通过代码设置宽和高"></a>2、通过代码设置宽和高</h5><blockquote><p>可以设置根布局的宽和高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 只有在 onViewCreated() 回调里设置才有效</span><br>override fun <span class="hljs-title function_">onViewCreated</span><span class="hljs-params">(view: View, savedInstanceState: Bundle?)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onViewCreated(view, savedInstanceState)<br>    <span class="hljs-comment">// density 是 dp / px 的转换率，比如：我的手机转换率是 2.75，则 1dp 对应 2.75px</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">density</span> <span class="hljs-operator">=</span> requireContext().resources.displayMetrics.density<br>    <span class="hljs-type">val</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> view.layoutParams<br>    lp.width = (density * <span class="hljs-number">400</span>).toInt()<br>    lp.height = (density * <span class="hljs-number">300</span>).toInt()<br>    <span class="hljs-comment">// 这里只是修改了宽和高，因为 View 还没有被测量布局</span><br>    <span class="hljs-comment">// 所以可以不用调用 view.layoutParams = lp 来刷新，在其他地方使用时是要通过这种方式才能刷新的！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以设置 window 的宽和高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 只有在 onViewCreated() 回调里设置才有效</span><br>override fun <span class="hljs-title function_">onViewCreated</span><span class="hljs-params">(view: View, savedInstanceState: Bundle?)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onViewCreated(view, savedInstanceState)<br>    <span class="hljs-comment">// density 是 dp / px 的转换率，比如：我的手机转换率是 2.75，则 1dp 对应 2.75px</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">density</span> <span class="hljs-operator">=</span> requireContext().resources.displayMetrics.density<br>    dialog?.window?.setLayout(<br>        (density * <span class="hljs-number">400</span>).toInt(),<br>        (density * <span class="hljs-number">300</span>).toInt()<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 window 其实是 Android 里的 <code>PhoneWindow</code>，听名字就知道是一个管理手机窗口的类，调用这个 <code>setLayout()</code> 最后会重新给 <code>DectorView</code> 设置 <code>LayoutParams</code>，<code>DectorView</code> 是所有窗口的根布局</p></blockquote><p>上面两种解决方法我更推荐使用第一种，因为在 xml 中定义属性更好修改，不然在代码中修改宽和高，会给以后看代码的人带来疑惑</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>OK，<code>onMeasure()</code> 基本上就讲到这里了</p></blockquote><h3 id="8、onLayout"><a href="#8、onLayout" class="headerlink" title="8、onLayout()"></a>8、onLayout()</h3><blockquote><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>布局子控件</p><h3 id="涉及知识-1"><a href="#涉及知识-1" class="headerlink" title="涉及知识"></a>涉及知识</h3><ul><li><code>measureWidth</code> 与 <code>meaasureHeigth</code></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 与上面讲的 onDraw() 一样，也是一个回调，该回调的作用是由 requestLayout() 触发</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> changed 与上次布局相比，是否发生改变</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(                                </span></span><br><span class="hljs-params"><span class="hljs-function">    changed: <span class="hljs-type">Boolean</span>,                                 </span></span><br><span class="hljs-params"><span class="hljs-function">    left: <span class="hljs-type">Int</span>, top: <span class="hljs-type">Int</span>, right: <span class="hljs-type">Int</span>, bottom: <span class="hljs-type">Int</span>      </span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;                                                   <br>    <span class="hljs-keyword">super</span>.onLayout(changed, left, top, right, bottom) <br>&#125;                                                     <br></code></pre></td></tr></table></figure><h3 id="主要用法-1"><a href="#主要用法-1" class="headerlink" title="主要用法"></a>主要用法</h3><ul><li><p>遍历子 View，再调用 <code>child.layout()</code>，摆放子 View</p></li><li><p>一般是 ViewGroup 实现</p><p>之前提到了 <code>TextView</code> 作为 View 却重写了这个方法，其实它没有干什么，主要是重新设置了文字的位置和大小</p><p>为什么需要在这里重写设置呢？</p><p>原因：<code>onLayout()</code> 能拿到最终显示的宽度和高度，且一般情况下只会调用一次，所以在有特殊需要时可以在这里面来设置一些东西，比如：一些特殊的自定义 ViewGroup 始终是固定的大小，则可以不用重写 <code>onMeasure()</code>，而是在 <code>onLayout()</code> 中直接给子 View 调用 <code>measure()</code>、<code>layout()</code> 布局</p></li></ul><pre><code class=" mermaid">graph LRid1(&quot;ViewRootImpl 开始布局&quot;)--&gt;id2id2[&quot;ViewGroup#layout()&quot;]--&gt;id3id3[&quot;ViewGroup#onLayout()&quot;]--&gt;id4id4[&quot;View#layout()&quot;]--&gt;id5(&quot;View#onLayout()&quot;)</code></pre></blockquote><h4 id="1、measureWidth-measureHeight-与-width-height"><a href="#1、measureWidth-measureHeight-与-width-height" class="headerlink" title="1、measureWidth (measureHeight) 与 width (height)"></a>1、measureWidth (measureHeight) 与 width (height)</h4><blockquote><p><code>measureWidth</code> 代表测量的宽度，其实就是 <code>onMeasure()</code> 中调用 <code>setMeasuredDimension()</code> 设置的宽度</p><p><code>width</code> 代表布局后的宽度，是由 <code>layout()</code> 中摆放后通过 <code>right - left</code> 得到的</p><p>一般 <code>measureWidth</code> 只用于 <code>layout()</code> 和 <code>onLayout()</code> 中，其他地方不应该使用它</p></blockquote><h4 id="2、FrameLayout-的-onLayout-源码分析"><a href="#2、FrameLayout-的-onLayout-源码分析" class="headerlink" title="2、FrameLayout 的 onLayout() 源码分析"></a>2、FrameLayout 的 onLayout() 源码分析</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLayout</span><span class="hljs-params">(<span class="hljs-type">boolean</span> changed, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> bottom)</span> &#123;<br>    layoutChildren(left, top, right, bottom, <span class="hljs-literal">false</span> <span class="hljs-comment">/* no force left gravity */</span>);<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">layoutChildren</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> bottom, <span class="hljs-type">boolean</span> forceLeftGravity)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> getChildCount();<br>    <span class="hljs-comment">// 计算子 View 能绘制的边界</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">parentLeft</span> <span class="hljs-operator">=</span> getPaddingLeftWithForeground();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">parentRight</span> <span class="hljs-operator">=</span> right - left - getPaddingRightWithForeground();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">parentTop</span> <span class="hljs-operator">=</span> getPaddingTopWithForeground();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">parentBottom</span> <span class="hljs-operator">=</span> bottom - top - getPaddingBottomWithForeground();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getChildAt(i);<br>        <span class="hljs-comment">// 子 View 为 Gone 时不布局，在自己设计自定义 View 时建议也进行判断</span><br>        <span class="hljs-keyword">if</span> (child.getVisibility() != GONE) &#123;<br>            <span class="hljs-comment">// 取出子 View 身上的 LayoutParams</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (LayoutParams) child.getLayoutParams();<br>            <span class="hljs-comment">// 得到之前测量的宽和高</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> child.getMeasuredWidth();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> child.getMeasuredHeight();<br>            <span class="hljs-type">int</span> childLeft;<br>            <span class="hljs-type">int</span> childTop;<br>            <span class="hljs-comment">// 前面提到的 FrameLayout#LayoutParams</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">gravity</span> <span class="hljs-operator">=</span> lp.gravity;<br>            <span class="hljs-keyword">if</span> (gravity == -<span class="hljs-number">1</span>) &#123;<br>                gravity = DEFAULT_CHILD_GRAVITY;<br>            &#125;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">layoutDirection</span> <span class="hljs-operator">=</span> getLayoutDirection();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">absoluteGravity</span> <span class="hljs-operator">=</span> Gravity.getAbsoluteGravity(gravity, layoutDirection);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">verticalGravity</span> <span class="hljs-operator">=</span> gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;<br>            <span class="hljs-comment">// 下面是根据不同的 gravity 来布局，就是一些简单的计算</span><br>            <span class="hljs-keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;<br>                <span class="hljs-keyword">case</span> Gravity.CENTER_HORIZONTAL:<br>                    childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="hljs-number">2</span> +<br>                    lp.leftMargin - lp.rightMargin;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> Gravity.RIGHT:<br>                    <span class="hljs-keyword">if</span> (!forceLeftGravity) &#123;<br>                        childLeft = parentRight - width - lp.rightMargin;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                <span class="hljs-keyword">case</span> Gravity.LEFT:<br>                <span class="hljs-keyword">default</span>:<br>                    childLeft = parentLeft + lp.leftMargin;<br>            &#125;<br>            <span class="hljs-keyword">switch</span> (verticalGravity) &#123;<br>                <span class="hljs-keyword">case</span> Gravity.TOP:<br>                    childTop = parentTop + lp.topMargin;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> Gravity.CENTER_VERTICAL:<br>                    childTop = parentTop + (parentBottom - parentTop - height) / <span class="hljs-number">2</span> +<br>                    lp.topMargin - lp.bottomMargin;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> Gravity.BOTTOM:<br>                    childTop = parentBottom - height - lp.bottomMargin;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    childTop = parentTop + lp.topMargin;<br>            &#125;<br>            <span class="hljs-comment">// 最后调用 child.layout()</span><br>            child.layout(childLeft, childTop, childLeft + width, childTop + height);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="9、requestLayout"><a href="#9、requestLayout" class="headerlink" title="9、requestLayout()"></a>9、requestLayout()</h3><blockquote><p>这东西跟前面的 <code>invalidate()</code> 一样，你们只需要记住以下几点：</p><ul><li>调用后会在下一帧回调 <code>onMeasure()</code> 和 <code>onMeasure()</code> 进行重新测量和布局</li><li>如果你的 View 大小发生改变，它还会调用 <code>onDraw()</code> 进行刷新</li></ul><p>文章的话，与 <code>invalidate()</code> 的一样：<a href="https://juejin.cn/post/7017452765672636446">https://juejin.cn/post/7017452765672636446</a></p><pre><code class=" mermaid">graph TBid1(&quot;View&quot;)--&gt;id2id2[&quot;调用requestLayout()重新布局&quot;]--&gt;id3id3&#123;&quot;parent == null&quot;&#125;--不为 null--&gt;id4id4[&quot;告诉父布局有子布局要重布局&quot;]--&gt;id3--为 null--&gt;id5id5[&quot;传递到了 ViewRootImpl (一个管理布局的类)&quot;]--&gt;id6id6[&quot;ViewRootImpl 调用 mChoreographer 发送一个 post (一个专门监听屏幕刷新的类)&quot;]-.-&gt;id7id7[&quot;屏幕刷新了，回调 ViewRootImpl，开始重新走 View 测量和布局流程&quot;]--&gt;id8id8(&quot;从顶部布局最后回调到 View 的 onMeasure()、onLayout()&quot;)--&gt;id9id9&#123;&quot;如果宽高改变&quot;&#125;--true--&gt;id10(&quot;调用 onDraw() 回调&quot;)--&gt;id11id9--false--&gt;id11(&quot;结束&quot;)</code></pre></blockquote><h3 id="10、setContentView"><a href="#10、setContentView" class="headerlink" title="10、setContentView"></a>10、setContentView</h3><blockquote><p>debug 走起，最后发现它调用了</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323223301814.png" alt="image-20220323223301814"></p><p>添加布局直接交给了 <code>LayoutInflater</code> 处理，那我们讲解一下 <code>LayoutInflater</code></p></blockquote><h4 id="1、LayoutInflater"><a href="#1、LayoutInflater" class="headerlink" title="1、LayoutInflater"></a>1、LayoutInflater</h4><blockquote><p><code>LayoutInflater</code> 我们常用的就下面这个两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> View <span class="hljs-title function_">inflate</span><span class="hljs-params">(<span class="hljs-meta">@LayoutRes</span> <span class="hljs-type">int</span> resource, <span class="hljs-meta">@Nullable</span> ViewGroup root)</span> &#123;<br>    <span class="hljs-comment">// 可以看到它直接调用了下面那个三个参数的</span><br><span class="hljs-keyword">return</span> inflate(resource, root, root != <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resource 布局 id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> root 父布局</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> attachToRoot 是否直接添加到父布局，如果为 true，在解析出 View 后会直接添加到 root 中</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果 attachToRoot 为 true，这返回 root，如果为 false，则返回 xml 中的根布局</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> View <span class="hljs-title function_">inflate</span><span class="hljs-params">(<span class="hljs-meta">@LayoutRes</span> <span class="hljs-type">int</span> resource, <span class="hljs-meta">@Nullable</span> ViewGroup root, <span class="hljs-type">boolean</span> attachToRoot)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>继续往里面走，其中最主要的代码在这里：</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323224318637.png" alt="image-20220323224318637"></p><p>上面那个就是之前留下的问题（<a href="#1%E3%80%81LayoutParams">LayoutParams</a>），在 <code>root != null</code> 通过 <code>AttributeSet</code> 得到你自己的 <code>LayoutParmas</code>，然后在 <code>!attchToRoot</code> 时调用 <code>setLayoutParams()</code>，里面会调用 <code>requestLayout()</code>进行重新布局</p><p>继续往下面看：</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323230405944.png" alt="image-20220323230405944"></p><p>这里在 <code>root != null &amp;&amp; attachToRoot</code> 时调用 <code>root.addView()</code>，这就是使用 <code>attachToRoot</code> 的时候</p><p>然后在 <code>addView()</code> 里面就调用了之前重写的那两个方法：</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323230713647.png" alt="image-20220323230713647"></p><p>这就是 <code>LayoutInflater</code> 的简单分析了</p><p>之前有学弟问道 <code>LayoutInflater#inflate()</code> 与 <code>View#inflate()</code> 的区别，查看源码你就会发现其实 <code>View#inflate()</code> 就是调用的 <code>LayoutInflater#inflate()</code></p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323231300755.png" alt="image-20220323231300755"></p><p>还有学弟问过为什么 Rv 的 <code>onCreateView()</code> 使用像下面这样写不行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 其实这个 parent 就是 Rv</span><br>override fun <span class="hljs-title function_">onCreateViewHolder</span><span class="hljs-params">(parent: ViewGroup, viewType: Int)</span>: MyViewHolder &#123;<br>    <span class="hljs-keyword">return</span> MyViewHolder(<br>        <span class="hljs-comment">// 这种写法就是下面这种写法</span><br>        View.inflate(parent.context, R.layout.recycler_item, parent)<br>    )<br>&#125;<br><br>override fun <span class="hljs-title function_">onCreateViewHolder</span><span class="hljs-params">(parent: ViewGroup, viewType: Int)</span>: MyViewHolder &#123;<br>    <span class="hljs-keyword">return</span> MyViewHolder(<br>        LayoutInflater.from(parent.context).inflate(R.layout.recycler_item, parent, <span class="hljs-literal">true</span>)<br>    )<br>&#125;<br><br><span class="hljs-comment">// 上面这两种写法使用后会报错：</span><br><span class="hljs-comment">// java.lang.IllegalStateException: </span><br><span class="hljs-comment">// ViewHolder views must not be attached when created. </span><br><span class="hljs-comment">// Ensure that you are not passing &#x27;true&#x27; to the attachToRoot parameter </span><br><span class="hljs-comment">// of LayoutInflater.inflate(..., boolean attachToRoot)</span><br><span class="hljs-comment">// 意思就是只能在 ViewHolder 开始使用时才能把 View 添加到 parent 中去</span><br></code></pre></td></tr></table></figure><p>可能部分有人这样写过，发现 item 的布局无法设置大小，这个问题跟前面讲到的 dialog 根布局宽高失效有点类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">override fun <span class="hljs-title function_">onCreateViewHolder</span><span class="hljs-params">(parent: ViewGroup, viewType: Int)</span>: MyViewHolder &#123;<br>    <span class="hljs-keyword">return</span> MyViewHolder(<br>        <span class="hljs-comment">// 第二个参数传入 null</span><br>        LayoutInflater.from(parent.context).inflate(R.layout.recycler_item, <span class="hljs-literal">null</span>)<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个参数传入 null 时，按照前面分析的流程，就不会给根布局设置 <code>LayoutParams</code>，那么在 Rv <code>addView()</code>时，会调用 Rv 的 <code>generateDefaultLayoutParams()</code> ，最后调用到 <code>LayoutManger</code> 的 <code>generateDefaultLayoutParams()</code></p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323234144858.png" alt="image-20220323234144858"></p><p>如果是 <code>LinearLayoutManger</code>，就直接设置成 <code>wrap_content</code> 了，所以在 xml 中写的宽和高根本就没有去读取</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323234305639.png" alt="image-20220323234305639"></p></blockquote><h3 id="11、发布开源库"><a href="#11、发布开源库" class="headerlink" title="11、发布开源库"></a>11、发布开源库</h3><h4 id="1、创建模块"><a href="#1、创建模块" class="headerlink" title="1、创建模块"></a>1、创建模块</h4><blockquote><p>大型项目都会采用多模块开发，每个人只需要负责自己的模块，模块方面的知识我就不讲解了，这里主要是讲解如何创建自定义 View 的模块</p><p>首先 new 一个模块</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325141248013.png" alt="image-20220325141248013"></p><p>然后选着对应的模块</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325141438062.png" alt="image-20220325141438062"></p><blockquote><p>这里简单讲一下：</p><p>第一个 <code>Phone &amp; Tablet</code> 也是创建模块，其实与这个 <code>Android Library</code> 主要是在 <code>build.gradle</code> 上的细微不同</p><h5 id="1、Phone-amp-Tablet"><a href="#1、Phone-amp-Tablet" class="headerlink" title="1、Phone &amp; Tablet"></a>1、Phone &amp; Tablet</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;com.android.application&#x27;</span><br>&#125;<br><br>android &#123;<br>    defaultConfig &#123;<br>    applicationId <span class="hljs-string">&quot;com.ndhzs.myapplication&quot;</span><br>    minSdk <span class="hljs-number">21</span><br>targetSdk <span class="hljs-number">31</span><br>    versionCode <span class="hljs-number">1</span><br>    versionName <span class="hljs-string">&quot;1.0&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、Android-Library"><a href="#2、Android-Library" class="headerlink" title="2、Android Library"></a>2、Android Library</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;com.android.library&#x27;</span><br>&#125;<br><br>android &#123;<br>    defaultConfig &#123;<br>    minSdk <span class="hljs-number">21</span><br>targetSdk <span class="hljs-number">31</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不同之处主要就是上面两处，其他还有 <code>AndroidManifest.xml</code> 都是差不多的</p></blockquote><p>创建好的模块会少 res 文件夹，自己新建即可，其他地方用法就跟平常写法都一样</p><p>在你的 app 模块中使用下面这种写法就可以刚建的模块</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>implementation project(<span class="hljs-string">&#x27;:lib&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>模块下也是允许再建子模块的，模块化需要学习 gradle 相关的知识，等你们进来接手掌邮了多看几个模块就无师自通了（透漏一下新消息，目前强神还在更新整个掌邮的 gradle，已经重构为 kts 了，估计等你们进来就可以体验协程了）</p></blockquote><h4 id="2、发布到-jitPack"><a href="#2、发布到-jitPack" class="headerlink" title="2、发布到 jitPack"></a>2、发布到 jitPack</h4><blockquote><p>很多时候发布到开源库方便我们在其他项目中引用，接下来我们将讲解如何发布到 <code>jitPack</code>，为什么不发布到 <code>Maven Central</code>，因为 <code>Maven Central</code> 要申请文件，很麻烦，而 <code>jitPack</code> 直接傻瓜式操作一步到位</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 在 lib 的 build.gradle 中</span><br>plugins &#123;<br>id <span class="hljs-string">&#x27;maven-publish&#x27;</span><br>&#125;<br><br>android &#123;<br>publishing &#123;<br>singleVariant <span class="hljs-string">&quot;release&quot;</span><br>&#125;<br>&#125;<br><br>afterEvaluate &#123;<br>publishing &#123;<br>publications &#123;<br>release(MavenPublication) &#123;<br>from components.release<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意是在 lib 的 build.gradle 中，不是在 app 的 build.gradle</strong></p><blockquote><p><strong>这里是原因的讲解，不想看的话可以跳过</strong></p><p>这是我摸索出来的<strong>最新教程</strong>，如果你去那些看那些博客，全是过时教程，这里给出摸索的过程：</p><ul><li><p>发布开源库的教程先根据 <code>jitPack</code> 官网来：<a href="https://docs.jitpack.io/android/">https://docs.jitpack.io/android/</a></p></li><li><p>然后看它官网给出的源码示例：<a href="https://github.com/jitpack/android-example/blob/master/library/build.gradle">https://github.com/jitpack/android-example/blob/master/library/build.gradle</a></p></li><li><p>再参考谷歌给的示例：<a href="https://developer.android.google.cn/studio/build/maven-publish-plugin">https://developer.android.google.cn/studio/build/maven-publish-plugin</a></p></li><li><p>最后看看 gradle 官网每个方法的意思：</p><p><a href="https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:tasks">https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:tasks</a></p><p><a href="https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html#org.gradle.api.publish.maven.MavenPublication">https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html#org.gradle.api.publish.maven.MavenPublication</a></p></li></ul><p>这样基本上能实现了，但在打包时会报一个警告：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">WARNING:Software Components will <span class="hljs-keyword">not</span> be created automatically <span class="hljs-keyword">for</span> Maven publishing <span class="hljs-keyword">from</span> Android Gradle Plugin <span class="hljs-number">8.0</span>. <span class="hljs-keyword">To</span> opt-<span class="hljs-keyword">in</span> <span class="hljs-keyword">to</span> the <span class="hljs-keyword">future</span> behavior, <span class="hljs-keyword">set</span> the Gradle <span class="hljs-keyword">property</span> <br></code></pre></td></tr></table></figure><p>最后上 stackoverflow 寻找（因为其他地方找不到）：</p><p><a href="https://stackoverflow.com/questions/71365373/software-components-will-not-be-created-automatically-for-maven-publishing-from">https://stackoverflow.com/questions/71365373/software-components-will-not-be-created-automatically-for-maven-publishing-from</a></p><p>最最后在谷歌找到方法：</p><p><a href="https://developer.android.google.cn/studio/publish-library/configure-pub-variants">https://developer.android.google.cn/studio/publish-library/configure-pub-variants</a></p><p><a href="https://developer.android.google.cn/reference/tools/gradle-api/7.1/com/android/build/api/dsl/LibraryPublishing">https://developer.android.google.cn/reference/tools/gradle-api/7.1/com/android/build/api/dsl/LibraryPublishing</a></p><p>这里简单讲一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>publishing &#123;<br>         <span class="hljs-comment">// 这个是会自动创建下面 publications 中的同名方法</span><br>singleVariant <span class="hljs-string">&quot;release&quot;</span><br><br>         <span class="hljs-comment">// 比如这个就是下面那个 myRelease(MavenPublication)</span><br>         <span class="hljs-comment">// singleVariant &quot;myRelease&quot;</span><br>&#125;<br><br>    <span class="hljs-comment">// 这是官方默认自带的东西，就与对不同的包定义不同的设置</span><br>    buildTypes &#123;<br>        release &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br>afterEvaluate &#123;<br>publishing &#123;<br>publications &#123;<br>release(MavenPublication) &#123;<br>                 <span class="hljs-comment">// 这个 components.release 中的 release 是 buildTypes 中的 release</span><br>from components.release<br>&#125;<br><br>             <span class="hljs-comment">// 这里这个 myRelease 就对应于上面写的那个 singleVariant &quot;myRelease&quot;</span><br>             <span class="hljs-comment">// myRelease(MavenPublication) &#123;</span><br><span class="hljs-comment">//     from components.release</span><br><span class="hljs-comment">// &#125;</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果实在看不懂的话就直接按照刚开始给出的抄上去即可，毕竟看懂需要有一定的 gradle 基础</p></blockquote><p>然后在 github 上发一个 Releases</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325133455931.png" alt="image-20220325133455931"></p><p>Release 发布好了后，打开 <code>jitPack</code> </p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325133728477.png" alt="image-20220325133728477"></p><p>这样一个正式包就成功发布出去了，引入的话下面有教程</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325134213260.png" alt="image-20220325134213260"></p><blockquote><p>小插曲：由于 gradle 到 7.0.0 版本以后，引入改位置了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 在 settings.gradle 里</span><br>dependencyResolutionManagement &#123;<br> repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)<br> repositories &#123;<br>     google()<br>     mavenCentral()<br>     maven &#123; url = <span class="hljs-string">&quot;https://jitpack.io&quot;</span> &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>如果是自己平时开发中用到，每次都发 Releases 显得过于麻烦，<code>jitPack</code> 可以发布快照版本，何为快照，看完下面的教程你就懂了</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325135853586.png" alt="image-20220325135853586"></p><p>你会发现下面给出的引入写法没有带版本号</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325135808864.png" alt="image-20220325135808864"></p><p>这个 <code>SNAPSHOP</code> 就是快照的标识，带有快照的版本号在 build 时会自动去检查是否是最新版，以后只需要提交到 main 分支，然后发个快照版本就可以升级了</p><p>只有自己使用时更推荐发布快照</p></blockquote><h4 id="3、发布到阿里的-Maven"><a href="#3、发布到阿里的-Maven" class="headerlink" title="3、发布到阿里的 Maven"></a>3、发布到阿里的 Maven</h4><blockquote><p>就在要上课的昨天，艾神来问我怎么发布阿里的 Maven，他掉进坑里卡了一个晚上，于是我去试着解决了一下</p><p>果然够坑的，因为 gradle 升到 7.0.0 以后把一个插件给移除了，而阿里官网和其他教程都是过时的，花了一些时间才搞出来，这里就直接给最新的操作教程</p><p>首先，去阿里官网注册一下（好像是免费的）：<a href="https://packages.aliyun.com/maven">https://packages.aliyun.com/maven</a></p><p>注册过后，他会给你两个仓库：</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326231305660.png" alt="image-20220326231305660"></p><p>一个是用于发布稳定版的库，一个是发布快照版的库，上面 <code>jitPack</code> 中也介绍了快照</p><p>然后找到这个指南界面</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326231921252.png" alt="image-20220326231921252"></p><p>这里面有一些基础设置，但这教程过时了，下面我给出最新的写法：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// settings.gradle</span><br>dependencyResolutionManagement &#123;<br>    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)<br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>        <span class="hljs-comment">// 这里添加阿里 maven 的仓库地址</span><br>        maven &#123;<br>            url <span class="hljs-string">&#x27;https://maven.aliyun.com/repository/public&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 这是单独写的一个 maven.gradle</span><br><br><span class="hljs-comment">// gradle 7之前使用的 maven 插件，7之后只能使用 maven-publish 了</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;maven-publish&#x27;</span><br><span class="hljs-comment">// 这个是引用我的密码等私密文件，建议把这些单独放在一个文件夹里，并在.gitignore上添加它</span><br>apply <span class="hljs-attr">from:</span> <span class="hljs-string">&quot;$&#123;rootDir&#125;/secret.gradle&quot;</span><br><br>afterEvaluate &#123;<br>    publishing &#123;<br>        publications &#123;<br>            release(MavenPublication) &#123;<br>                from components.release<br>                <span class="hljs-comment">// 版本号，如果末尾加上 -SNAPSHOT 说明是快照版本</span><br>                version = <span class="hljs-string">&#x27;0.0.1-SNAPSHOT&#x27;</span><br>                <span class="hljs-comment">// 项目名称，通常为类库模块名称，也可以任意设置</span><br>                artifactId = <span class="hljs-string">&#x27;example&#x27;</span><br>                <span class="hljs-comment">// 唯一标识，通常为模块包名，也可以任意设置</span><br>                groupId = <span class="hljs-string">&#x27;com.985892345&#x27;</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 这下面的 aliMavenUsername、aliMavenPassword、releaseUrl、snapshotUrl</span><br>        <span class="hljs-comment">// 对应你自己的，在阿里官网那个指南里有</span><br>        repositories &#123;<br>            maven &#123;<br>                credentials &#123;<br>                    username aliMavenUsername<br>                    password aliMavenPassword<br>                &#125;<br>                url releaseUrl<br>            &#125;<br>            maven &#123;<br>                credentials &#123;<br>                    username aliMavenUsername<br>                    password aliMavenPassword<br>                &#125;<br>                url snapshotUrl<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// secret.gradle</span><br><span class="hljs-comment">// 这个没学过 gradle 的话可能看不懂，这里不会讲解，你只管这样写就可以</span><br>ext.aliMavenUsername = <span class="hljs-string">&quot;你的账号&quot;</span><br>ext.aliMavenPassword = <span class="hljs-string">&quot;你的密码&quot;</span><br>ext.releaseUrl = <span class="hljs-string">&quot;你的稳定版本发布地址&quot;</span><br>ext.snapshotUrl = <span class="hljs-string">&quot;你的快照版本发布地址&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 在你要发布的项目里的 build.gradle</span><br>apply <span class="hljs-attr">from:</span> <span class="hljs-string">&quot;maven.gradle&quot;</span><br><br>android &#123;<br>    <span class="hljs-comment">// 这个东西在之前 jitPack 讲过，这里就不再讲了</span><br>    publishing &#123;<br>        singleVariant <span class="hljs-string">&quot;release&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>通常你要发布的项目是一个 <code>library</code>，而不是一个 <code>application</code>，因为一般 <code>library</code> 才是给别人使用的，而 <code>application</code> 是一个项目的入口，通常来依赖 <code>library</code></p><p>OK，这样就配置完了，刷新一下 gradle，再点击右上角的 gradle 标志</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326234300251.png" alt="image-20220326234300251"></p><p>点击这个就可以直接运行发布到 maven 的 task</p><img src="D:/Typora/img/image-20220326234410761.png" alt="image-20220326234410761" style="zoom: 67%;" /><blockquote><p>可能你们有些人找不到这个选项，因为新版的 AS 把这个默认关闭了，我也搞不懂为啥，为了让大家使用命令行运行任务？</p><p>在这里进行设置，就能看得到了</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326234634838.png" alt="image-20220326234634838"></p></blockquote></blockquote><h3 id="12、分享一些东西"><a href="#12、分享一些东西" class="headerlink" title="12、分享一些东西"></a>12、分享一些东西</h3><h4 id="1、Material-Design-官网"><a href="#1、Material-Design-官网" class="headerlink" title="1、Material Design 官网"></a>1、Material Design 官网</h4><blockquote><p>谁想写自定义 View 啊，你想写吗？正经人写什么自定义 View。</p><p>自定义 View 确实很难，东西又多又杂，在考虑写自定义 View 之前，请先搜索一下是否有别人已经造好的轮子，有轮子直接用，他不香吗？[狗头]，Material Design 官网就包含许多官方轮子</p><p>官网链接：<a href="https://material.io/">https://material.io/</a></p><p>源码地址：<a href="https://github.com/material-components/material-components-android">https://github.com/material-components/material-components-android</a></p><p>示例下载：<a href="https://github.com/material-components/material-components-android/releases">https://github.com/material-components/material-components-android/releases</a></p><p>这里面的都算官方控件，而且有很多，如果想实现某个功能时可以去看看是否已经有实现了的，他还专门写了一个实例 app，可以下下来看看，找到想要的再去看他的源码</p></blockquote><h4 id="2、MotionLayout"><a href="#2、MotionLayout" class="headerlink" title="2、MotionLayout"></a>2、MotionLayout</h4><blockquote><p>这东西我都还没怎么深入学习，可以去看看掘金上的一些教程，这里我就不讲了 ）</p><p>官网：<a href="https://developer.android.google.cn/training/constraint-layout/motionlayout/examples?hl=zh_cn">https://developer.android.google.cn/training/constraint-layout/motionlayout/examples?hl=zh_cn</a></p></blockquote><h4 id="2、View-post-、posyDelay-、postOnAnimation"><a href="#2、View-post-、posyDelay-、postOnAnimation" class="headerlink" title="2、View#post()、posyDelay()、postOnAnimation()"></a>2、View#post()、posyDelay()、postOnAnimation()</h4><blockquote><h5 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h5><p>如何在 <code>onCreate()</code> 中得到 View 的宽和高？</p><p>哈哈，这不是有手就行？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br><span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>setContentView(com.ndhzs.lib.R.layout.layout_section7)<br>        <br><span class="hljs-keyword">val</span> view = findViewById&lt;View&gt;(com.ndhzs.lib.R.id.myView7)<br><span class="hljs-keyword">val</span> width = view.width<br><span class="hljs-keyword">val</span> height = view.height<br>&#125;<br></code></pre></td></tr></table></figure><p>然后面试官笑了笑，你就被刷了</p><p>原因：这种写法得到的宽和高结果是 0</p><p>为什么呢？</p><p>因为前面我们讲到，<code>View#width</code> 和 <code>View#height</code> 是在 <code>onLayout()</code> 中设置的，而 <code>onCreate()</code> 此时还没有开始布局，只是调用了 <code>setContentView()</code> 加载了布局，三大流程还没有开始走，真正开始走三大流程是在 <code>onResume()</code> 后，这里提供下面几种正确方法：</p><blockquote><h5 id="1、post"><a href="#1、post" class="headerlink" title="1、post()"></a>1、post()</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> view = findViewById&lt;View&gt;(com.ndhzs.lib.R.id.myView7)<br>view.post &#123;<br>    <span class="hljs-keyword">val</span> width = view.width<br>    <span class="hljs-keyword">val</span> height = view.height<br>&#125;<br></code></pre></td></tr></table></figure><p>原理：post 是用 Handler 发一个 Message，而 View 对于自带的 post 做了特殊处理，只会在 View 被测量后才开始发 Message</p><h5 id="2、doOnLayout"><a href="#2、doOnLayout" class="headerlink" title="2、doOnLayout"></a>2、doOnLayout</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> view = findViewById&lt;View&gt;(com.ndhzs.lib.R.id.myView7)<br>view.doOnLayout &#123;<br>    <span class="hljs-keyword">val</span> width = view.width<br>    <span class="hljs-keyword">val</span> height = view.height<br>&#125;<br></code></pre></td></tr></table></figure><p>原理：使用 View 的一个 <code>addOnLayoutChangeListener()</code> 方法，监听 View 的 <code>onLayout()</code> 回调</p></blockquote><h5 id="再来个面试题："><a href="#再来个面试题：" class="headerlink" title="再来个面试题："></a>再来个面试题：</h5><p>View 的 <code>post()</code> 原理是什么？<code>postDelayed()</code> 会造成内存泄漏吗？如果会该怎么处理？</p><p>答案：</p><p>1、View 的 <code>post()</code> 在没有添加到屏幕前会先保存 Runnable 在第一次 <code>performTraversals</code> 到来时执行，如果已经添加屏幕上，就直接交给 <code>mAttachInfo</code> 的 <code>mHanlder</code> 执行，至于这个 <code>mHandler</code>，是 <code>ViewRootImpl</code> 持有的一个 <code>ViewRootHandler</code> 对象</p><p>2、<code>postDelayed()</code> 会造成内存泄漏，因为它没主动删除你发送的 Runnable（其实 <code>post()</code> 理论上也会造成内存泄漏，但因为时间极短，约等于不泄漏）</p><p>3、处理的话，可以在重写 View 的 <code>onDetachedFromWindow()</code> 方法主动取消，或者封装一下成单独的一个类，使用 <code>addOnAttachStateChangeListener()</code> 专门来发 <code>postDelayed()</code></p><blockquote><p>如果面试官真的刁难你，可能还会问 <code>View#post()</code> 在不同版本上的实现 (</p><p>这个你们自己看文章吧：<a href="https://juejin.cn/post/6844903521804877832">https://juejin.cn/post/6844903521804877832</a></p><p>还有如何检测内存泄漏，这个还是得提一下，不然不提的话，可能都不会有人知道</p><p>直接使用：LeakCanary  <a href="https://github.com/square/leakcanary">https://github.com/square/leakcanary</a></p><p>用法很简单，只需一行代码即可</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>  <span class="hljs-comment">// debugImplementation because LeakCanary should only run in debug builds.</span><br>  debugImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-android:xxx&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后它会自己生成一个多余的图标，在你应用出现内存泄漏时弹窗提醒</p><p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325155039418.png" alt="image-20220325155039418"></p><p>内存泄露也是面试的点（</p></blockquote><h5 id="最后一个面试题"><a href="#最后一个面试题" class="headerlink" title="最后一个面试题"></a>最后一个面试题</h5><p><code>postOnAnimation()</code> 是什么？通常用于什么时候？</p><p>不要被 Animation 迷惑了，认为这个是用来发送动画的，如果要讲这个，我们先从官方常用的一个方法讲起，如果你经常看官方控件源码，你会发现下面这个东西常出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ViewCompat.postOnAnimation()<br></code></pre></td></tr></table></figure><p>如果你去看一遍它的注释，就很容易理解了，就是将 Runnable 在手机的下一帧执行（前面说过刷新率 60 的手机每帧相隔 16 毫秒），而这个方法内部在 SDK 16 及以上就是调用的 <code>View#postOnAnimation()</code></p><p>那这个方法的使用场景如何呢？</p><p>它常用于代替 <code>ValueAnimator</code> 动画（<code>ValueAnimator</code> 这类动画与 <code>View#postOnAnimation()</code> 内部实现是一样的），比如在 Rv 的惯性滑动中就会用到这个 <code>ViewCompat.postOnAnimation()</code>（下次事件分发时才讲）</p><p>所以你会经常看见这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">mRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// ......</span><br>ViewCompat.postOnAnimation(View.<span class="hljs-built_in">this</span>, <span class="hljs-built_in">this</span>)<br>         <span class="hljs-comment">// 平时开发可以直接使用 View.postOnAnimation(View.this, this)</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// 这样就形成了一种隐式的递归，在每次屏幕刷新时调用 run()</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="3、View-的生命周期"><a href="#3、View-的生命周期" class="headerlink" title="3、View 的生命周期"></a>3、View 的生命周期</h4><blockquote><p>View 也有什么周期，但 View 的生命周期很不完善</p><pre><code class=" mermaid">graph TBid1(&quot;构造函数（对应 onCreate()）&quot;)--&gt;id2id2[&quot;onFinishInflate()（对应 onCreate() 中的 setContentView()）&quot;]--&gt;id3id3[&quot;onAttachedToWindow()&quot;]--&gt;id4id4[&quot;onWindowVisbilityChanged()&quot;]--&gt;id5id5[&quot;onMeasure()&quot;]--&gt;id6id6[&quot;onLayout()&quot;]--&gt;id7id7[&quot;onDraw()&quot;]--&gt;id8id8[&quot;onWindowFocusChanged()&quot;]--&gt;id9id9[&quot;onWindowVisibilityChanged()&quot;]--&gt;id10id10[&quot;onDetachedFromWindow()&quot;]</code></pre><h5 id="onFinishInflate"><a href="#onFinishInflate" class="headerlink" title="onFinishInflate()"></a>onFinishInflate()</h5><p> 从 xml 中完全加载完时的回调</p><h5 id="onAttachedToWindow"><a href="#onAttachedToWindow" class="headerlink" title="onAttachedToWindow()"></a>onAttachedToWindow()</h5><p>开始显示在屏幕上时的回调</p><h5 id="onWindowVisbilityChanged"><a href="#onWindowVisbilityChanged" class="headerlink" title="onWindowVisbilityChanged()"></a>onWindowVisbilityChanged()</h5><p>窗口可见性改变的回调</p><h5 id="onWindowFocusChanged"><a href="#onWindowFocusChanged" class="headerlink" title="onWindowFocusChanged()"></a>onWindowFocusChanged()</h5><p>窗口获取焦点时的回调</p><h5 id="onDetachedFromWindow"><a href="#onDetachedFromWindow" class="headerlink" title="onDetachedFromWindow()"></a>onDetachedFromWindow()</h5><p>View 不显示在屏幕上时的回调</p><p>其他的看看这篇文章吧：<a href="https://www.jianshu.com/p/0a4cb44ce9d1">https://www.jianshu.com/p/0a4cb44ce9d1</a></p><p>可以看到其实 View 的生命周期不是很完善，甚至连自身什么时候被添加进 ViewGroup 都没有方法回调，remove 也是一样，但如果想实现 addView 和 removeView 监听的话，查看源码后发现只能使用 <code>ViewGroup#setOnHierarchyChangeListener()</code>，意思是在 View 中通过给 parent 设置监听，但这个有个缺点，就是只能设置一次监听</p></blockquote><h4 id="4、自定义-View-的一些规范"><a href="#4、自定义-View-的一些规范" class="headerlink" title="4、自定义 View 的一些规范"></a>4、自定义 View 的一些规范</h4><blockquote><ul><li>应该尽量解耦，View 里面不建议包含 <code>网络请求</code>、<code>Rxjavaj</code>、<code>EventBus</code>、<code>Lifecycle 相关组件</code> 等，这些应该是主语应用层使用的，而不是在 View 里面使用，View 里面应该尽量使用 MVC 的模式来写</li><li>可以分离一些职责出来，比如课表我就把事件和绘制通过设置监听的方式来分离，这样可以方便扩展，而不是全部塞在 View 里面</li></ul><h5 id="分离-Draw-事件"><a href="#分离-Draw-事件" class="headerlink" title="分离 Draw 事件"></a>分离 Draw 事件</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 自定义绘图的监听</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mItemDecoration = ArrayList&lt;ItemDecoration&gt;(<span class="hljs-number">5</span>)<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br>    mItemDecoration.forEach &#123;<br>        it.onDrawBelow(canvas, <span class="hljs-keyword">this</span>)<br>    &#125;<br>    <span class="hljs-keyword">super</span>.dispatchDraw(canvas)<br>    mItemDecoration.forEach &#123;<br>        it.onDrawAbove(canvas, <span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该类主要用于实现一些简单的绘图处理</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 经过我的思考，我认为不应该提供删除的方法，原因如下：</span><br><span class="hljs-comment"> * - 一般不会有需要中途删除的情况</span><br><span class="hljs-comment"> * - 很容易出现事件在遍历中就把它删除，导致出现遍历越位的错误</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 设计参考了 RV 的 ItemDecoration</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 985892345 (Guo Xiangrui)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@email</span> 2767465918<span class="hljs-doctag">@qq</span>.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/1/27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ItemDecoration</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在所有子 View 的 onDraw() 前的回调，在这里面绘图可以绘制在子 View 下方</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDrawBelow</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>, view: <span class="hljs-type">View</span>)</span></span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在所有子 View 的 onDraw() 后的回调，在这里面绘图可以绘制在子 View 上方</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDrawAbove</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>, view: <span class="hljs-type">View</span>)</span></span> &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有分离事件分发，我就留到下次课来讲了</p></blockquote><h4 id="5、布局调试软件"><a href="#5、布局调试软件" class="headerlink" title="5、布局调试软件"></a>5、布局调试软件</h4><blockquote><p>Android 调试利器 Pandora</p><p>一个很牛逼的 debug 工具，可以在手机上查看布局属性、网络请求、sp 等很多东西</p><p><a href="https://www.wanandroid.com/blog/show/2183">https://www.wanandroid.com/blog/show/2183</a></p></blockquote><h4 id="6、Rv-怎么得到某个-item-的实例"><a href="#6、Rv-怎么得到某个-item-的实例" class="headerlink" title="6、Rv 怎么得到某个 item  的实例"></a>6、Rv 怎么得到某个 item  的实例</h4><blockquote><p>这不算自定义 View 的内容，因为寒假时有很多学弟遇到了这个问题，我这里讲解一下吧</p><p>得到里面的 item 更建议使用在不需要保持状态的情况下，比如某个 item 的变动需要加载动画，那就可以使用这种方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RvAdapter</span> : <span class="hljs-type">RecyclerView.Adapter</span>&lt;<span class="hljs-type">RvAdapter.RvVH</span>&gt;() &#123;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RvVH</span>(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;<br>     <span class="hljs-keyword">val</span> mAnimationView: AnimationView = itemView.findViewById(R.id.item_animation)<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getVHolder</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>, call: <span class="hljs-type">VHolderCallback</span>)</span></span> &#123;<br>     <span class="hljs-comment">// 调用两个参数的这个刷新</span><br>     notifyItemChanged(position, call)<br> &#125;<br><br> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">     parent: <span class="hljs-type">ViewGroup</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">     viewType: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function"> )</span></span>: RvVH &#123;<br>     <span class="hljs-keyword">return</span> RvVH(<br>         LayoutInflater<br>         .from(parent.context)<br>         .inflate(R.layout.layout_item, parent, <span class="hljs-literal">false</span>)<br>     )<br> &#125;<br><br> <span class="hljs-comment">// 重写三个参数的这个方法</span><br> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">     holder: <span class="hljs-type">RvVH</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">     position: <span class="hljs-type">Int</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">     payloads: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">Any</span>&gt;</span></span><br><span class="hljs-params"><span class="hljs-function"> )</span></span> &#123;<br>     <span class="hljs-keyword">if</span> (payloads.isEmpty()) &#123;<br>         <span class="hljs-keyword">super</span>.onBindViewHolder(holder, position, payloads)<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// 这里得到 payloads 就是之前刷新传入的回调</span><br>         <span class="hljs-comment">// 因为是在下一帧才会刷新，期间可能会调用多次刷新 item，所以是一个 List</span><br>         payloads.forEach &#123;<br>             <span class="hljs-keyword">if</span> (it <span class="hljs-keyword">is</span> VHolderCallback) &#123;<br>                 it.call(holder)<br>             &#125;<br>         &#125;<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">RvVH</span>, position: <span class="hljs-type">Int</span>)</span></span> &#123;<br> &#125;<br><br> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-number">100</span><br><br> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-keyword">interface</span> VHolderCallback &#123;</span><br>     <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">call</span><span class="hljs-params">(holder: <span class="hljs-type">RvVH</span>)</span></span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方式就是调用 <code>getVHolder()</code> 就可以了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">getVHolder(<span class="hljs-number">1</span>) &#123;<br> <span class="hljs-comment">// 开始动画</span><br> it.mAnimationView.startAnim()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>这种方法在回调时不能进行延迟保存返回的 holder 对象，因为它只是目前状态下的 holder，不能保证刷新后仍是这个</p></li><li><p>这里面对 View 的设置都是暂时的，所以最开始我就说了用来调用一下动画才能使用这种方法，如果想永久保存建议：</p><ul><li>改变传入 Rv 的数据集合，</li><li>或者调用 <code>ViewHolder#setIsRecyclable(false)</code>，但要记得在之后还原，不然这个 ViewHolder 就不会被回收</li></ul></li><li><p>这种情况下会失效：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">getVHolder(<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 开始动画</span><br>    it.setIsRecyclable(<span class="hljs-literal">false</span>)<br>    it.mAnimationView.startAnim()<br>&#125;<br><span class="hljs-comment">// 后面调用这个进行普通刷新，只要出现了这个，前面的特殊刷新都会失效</span><br>notifyItemChanged(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ul><p>对于差分刷新也有一个与 payload 相关的方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这个是 ItemCallback，但与 DiffUtil.Callback 是差不多的</span><br><span class="hljs-keyword">object</span> : DiffUtil.ItemCallback&lt;ICourseVpBean&gt;() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">areItemsTheSame</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        oldItem: <span class="hljs-type">ICourseVpBean</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        newItem: <span class="hljs-type">ICourseVpBean</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> oldItem.week == newItem.week<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">areContentsTheSame</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        oldItem: <span class="hljs-type">ICourseVpBean</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        newItem: <span class="hljs-type">ICourseVpBean</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> oldItem == newItem<br>    &#125;<br><br>    <span class="hljs-comment">// 就这个方法，建议重写并不返回</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getChangePayload</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        oldItem: <span class="hljs-type">ICourseVpBean</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">        newItem: <span class="hljs-type">ICourseVpBean</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: Any &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// 只要不为 null 就可以在刷新时去掉与缓存的互换，减少性能的消耗</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="二、动画"><a href="#二、动画" class="headerlink" title="二、动画"></a>二、动画</h2><blockquote><p>动画这东西建议看《Android自定义控件开发入门与实战》和下面这网址，我这里就不进行讲解了</p><p><a href="https://qijian.blog.csdn.net/article/details/50995268">https://qijian.blog.csdn.net/article/details/50995268</a></p><p>本节课主要讲元素共享动画</p><p>因为时间关系写不了了（这课件确实把我写累了），这里给出一些网址：</p><ul><li><p><a href="https://juejin.cn/post/6844903727015395336">https://juejin.cn/post/6844903727015395336</a></p><blockquote><p>这个主要写了 activity 之间的元素共享，例子较全</p></blockquote></li><li><p><a href="https://blog.csdn.net/qq_29425853/article/details/53104919">https://blog.csdn.net/qq_29425853/article/details/53104919</a></p></li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/19/%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/10/19/%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="动画相关"><a href="#动画相关" class="headerlink" title="动画相关"></a>动画相关</h1><p>[TOC]</p><p>本文源码已上传github: <a href="https://github.com/WhiteNight123/AnimationDemo">WhiteNight123&#x2F;AnimationDemo (github.com)</a></p><h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><h3 id="为什么引入属性动画"><a href="#为什么引入属性动画" class="headerlink" title="为什么引入属性动画"></a>为什么引入属性动画</h3><p>  在Android中,动画分为两类:<strong>视图动画</strong>(<code>View Animation</code>)和<strong>属性动画</strong>(<code>Property Animation</code>).其中,<code>View Animation</code>包括<code>Tween Animation</code>(<strong>补间动画</strong>)和<code>Frame Animation</code>(<strong>逐帧动画</strong>);<code>Property Animation</code>包括<code>ValueAnimation</code>和<code>ObjectAnimator</code>.</p><p>  属性动画（<code>Property Animation</code>）是在 Android 3.0后才提供的一种全新动画模式</p><p>  首先来看一下补间动画的缺陷:</p><ul><li><p>补间动画是<strong>只能够作用在View上</strong>的。我们可以对一个Button、TextView、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，补间动画就不起作用了。</p></li><li><p>补间动画只能够实现<strong>移动、缩放、旋转和淡入淡出</strong>这四种动画操作，那如果我们想对View的背景色进行动态地改变,补间动画是不能实现的. 补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上<strong>没有任何扩展性</strong>。</p></li><li><p>补间动画只是<strong>改变了View的显示效果而已，而不会真正去改变View的属性</strong>。比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去点击一下这个按钮，点击事件是不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。</p><p>新引入的<strong>属性动画</strong>机制已经不再是针对于View来设计的了，也不限定于只能实现移动、缩放、  旋转和淡入淡出这几种动画操作，同时也不再只是一种视觉上的动画效果了。它实际上是一种不断地对<strong>值</strong>进行操作的机制，并将值赋值到指定对象的指定属性上，可以是任意对象的任意属性。</p></li></ul><p><strong>属性动画工作原理[重点]</strong></p><p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/mRjNFA2nMCEJYbz.png" alt="安卓属性动画工作原理"></p><p><a href="https://www.processon.com/view/link/62cbbd0763768906c5087f89">安卓属性动画工作原理 -查看大图</a></p><h3 id="ValueAnimator的简单使用"><a href="#ValueAnimator的简单使用" class="headerlink" title="ValueAnimator的简单使用"></a>ValueAnimator的简单使用</h3><p>  ValueAnimator这个动画是针对<strong>值</strong>的. ValueAnimator不会对控件执行任何操作,我们可以给它设定从哪个值运动到哪个值,通过监听这些值的渐变过程来自己操作控件.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 步骤1：设置动画属性的初始值 &amp; 结束值</span><br><span class="hljs-keyword">val</span> animator = ValueAnimator.ofInt(<span class="hljs-number">0</span>, <span class="hljs-number">400</span>)<br><span class="hljs-comment">// ofInt（）作用有两个</span><br><span class="hljs-comment">// 1. 创建动画实例</span><br><span class="hljs-comment">// 2. 将传入的Int参数进行平滑过渡:此处传入0和400,表示将值从0平滑过渡到400</span><br><span class="hljs-comment">// 如果传入了多个Int参数 ,如:a,b,c ,则是先从a过渡到b,再从b过渡到C，以此类推</span><br><span class="hljs-comment">// ValueAnimator.ofInt()内置了整型估值器,关于自定义估值器将在下面讲解</span><br><br><span class="hljs-comment">// 步骤2：设置动画的播放各种属性</span><br><span class="hljs-comment">// 设置动画运行的时长</span><br>animator.duration = <span class="hljs-number">500</span><br><span class="hljs-comment">// 设置动画延迟播放时间</span><br>animator.startDelay = <span class="hljs-number">200</span><br><span class="hljs-comment">// 设置动画重复播放次数</span><br><span class="hljs-comment">// 动画播放次数 = infinite时,动画无限重复</span><br>animator.repeatCount = <span class="hljs-number">0</span><br><span class="hljs-comment">// 设置重复播放动画模式</span><br><span class="hljs-comment">// ValueAnimator.RESTART(默认):正序重放</span><br><span class="hljs-comment">// ValueAnimator.REVERSE:倒序回放</span><br>animator.repeatMode = ValueAnimator.RESTART<br><span class="hljs-comment">// 设置插值器</span><br>animator.interpolator = AccelerateInterpolator()<br><span class="hljs-comment">//设置估值器,对于ofInt()和ofFloat(系统都有默认的估值器,只有ofObject才需要我们自己设置)</span><br><span class="hljs-comment">//animator.setEvaluator(IntEvaluator())</span><br><br><span class="hljs-comment">// 步骤3：将改变的值手动赋值给对象的属性值：通过动画的更新监听器</span><br><span class="hljs-comment">// 设置&#x27;值&#x27;的更新监听器,值每次改变、变化一次,该方法就会被调用一次</span><br>animator.addUpdateListener &#123; animation -&gt;<br>    <span class="hljs-comment">// 获得改变后的值</span><br>    <span class="hljs-keyword">val</span> currentValue = animation.animatedValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">Int</span><br>    <span class="hljs-comment">// 步骤4：将改变后的值赋给对象的属性值</span><br>    View.setproperty（currentValue）；<br>    <span class="hljs-comment">// 步骤5：刷新视图，即重新绘制，从而实现动画效果</span><br>    View.requestLayout();<br>&#125;<br><span class="hljs-comment">// 启动动画</span><br>animator.start()<br></code></pre></td></tr></table></figure><p>效果图</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/OWHiDkyCujQlSPA.gif" alt="demo1" style="zoom: 50%;" /><h4 id="ofInt"><a href="#ofInt" class="headerlink" title="ofInt()"></a><code>ofInt</code>()</h4><p>  首先看一下步骤1的ofInt()的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ValueAnimator <span class="hljs-title function_">ofInt</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-type">int</span>... values)</span> &#123;<br>    <span class="hljs-comment">// 创建动画对象</span><br>        <span class="hljs-type">ValueAnimator</span> <span class="hljs-variable">anim</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueAnimator</span>();<br>    <span class="hljs-comment">// 将传入的值赋值给动画对象</span><br>        anim.setIntValues(values);<br>        <span class="hljs-comment">// 返回动画</span><br>        <span class="hljs-keyword">return</span> anim;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ValueAnimator.ofInt（）</code>与<code>ValueAnimator.oFloat（）</code>仅仅只是在估值器上的区别：</p><ul><li><code>ValueAnimator.oFloat（）</code>采用默认的浮点型估值器 (<code>FloatEvaluator</code>)</li><li><code>ValueAnimator.ofInt（）</code>采用默认的整型估值器（<code>IntEvaluator</code>）</li></ul><h4 id="插值器-Interpolator"><a href="#插值器-Interpolator" class="headerlink" title="插值器(Interpolator)"></a>插值器(Interpolator)</h4><p>  估值器是设置从初始值到结束值的逻辑</p><ul><li><p>插值器(Interpolator)决定<strong>值</strong>的变化速率(匀速,加速…)</p></li><li><p>估值器(TypeEvaluator)决定<strong>值</strong>的具体变化数值</p></li></ul><p>一些常用的插值器<a name="常用的插值器"></a></p><table><thead><tr><th align="left">插值器</th><th align="left">效果</th></tr></thead><tbody><tr><td align="left">AccelerateDecelerateInterpolator</td><td align="left">在动画开始与结束的地方速率改变比较慢，在中间的时候加速</td></tr><tr><td align="left">AccelerateInterpolator</td><td align="left">在动画开始的地方速率改变比较慢，然后开始加速</td></tr><tr><td align="left">AnticipateInterpolator</td><td align="left">开始的时候向后然后向前甩</td></tr><tr><td align="left">AnticipateOvershootInterpolator</td><td align="left">开始的时候向后然后向前甩一定值后返回最后的值</td></tr><tr><td align="left">BounceInterpolator</td><td align="left">动画结束的时候弹起</td></tr><tr><td align="left">CycleInterpolator</td><td align="left">动画循环播放特定的次数，速率改变沿着正弦曲线</td></tr><tr><td align="left">DecelerateInterpolator</td><td align="left">在动画开始的地方快然后慢</td></tr><tr><td align="left">LinearInterpolator</td><td align="left">以常量速率改变</td></tr><tr><td align="left">OvershootInterpolator</td><td align="left">向前甩一定值后再回到原来位置</td></tr></tbody></table><p>  效果图:</p><table><thead><tr><th>AccelerateDecelerateInterpolator</th><th>AccelerateInterpolator</th><th>AnticipateInterpolator</th></tr></thead><tbody><tr><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/2zw9v3yabpIiCG6.gif" alt="AccelerateDecelerateInterpolator" style="zoom: 33%;" /></td><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/Bzu8V7Dsey3oKrZ.gif" alt="AccelerateInterpolator" style="zoom: 33%;" /></td><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/UHwNOTLXpsChAb8.gif" alt="AnticipateInterpolator" style="zoom: 33%;" /></td></tr></tbody></table><table><thead><tr><th>AnticipateOvershootInterpolator</th><th>BounceInterpolator</th><th>CycleInterpolator</th></tr></thead><tbody><tr><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/yBCnQiZLUIRxmwA.gif" alt="AnticipateOvershootInterpolator" style="zoom: 33%;" /></td><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/iCHNk6EpMmIARJu.gif" alt="BounceInterpolator" style="zoom: 33%;" /></td><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/bDlG15fxipUZw8d.gif" alt="CycleInterpolator" style="zoom: 33%;" /></td></tr></tbody></table><table><thead><tr><th>DecelerateInterpolator</th><th>OvershootInterpolator</th></tr></thead><tbody><tr><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/MEUAOG9qiWmwY4z.gif" alt="DecelerateInterpolator" style="zoom: 33%;" /></td><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/Tt9d5vwrnPjYlBu.gif" alt="OvershootInterpolator" style="zoom: 33%;" /></td></tr></tbody></table><p> 先来看一下系统自带的插值器是如何实现的,如LinearInterpolator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearInterpolator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseInterpolator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NativeInterpolator</span> <br>    <span class="hljs-comment">// 实现了BaseInterpolator接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinearInterpolator</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinearInterpolator</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getInterpolation</span><span class="hljs-params">(<span class="hljs-type">float</span> input)</span> &#123;<br>        <span class="hljs-comment">//直接把input返回,以当前动画进度作为动画的数值进度,这也就表示当前动画的数值进度与动画进度的时间一致,所以LinearInterpolator的数值进度是匀速增加的</span><br>        <span class="hljs-keyword">return</span> input;<br>    &#125;<br> <br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseInterpolator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interpolator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseInterpolator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stub!&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interpolator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TimeInterpolator</span> &#123;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>​    <code>LinearInterpolator</code>最终实现了<code>TimeInterpolator</code>,再看一下<code>TImeInterpolator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TimeInterpolator</span> &#123;<br>    <span class="hljs-comment">//参数var1:Float类型,取值范围0~1,表示当前动画的进度</span><br>    <span class="hljs-comment">//返回值:表示当前时间想要显示的进度,取值可以超过1,也可以小于0.超过1表示已超过目标,小于0表示小于开始位置</span><br>    <span class="hljs-type">float</span> <span class="hljs-title function_">getInterpolation</span><span class="hljs-params">(<span class="hljs-type">float</span> var1)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  :warning:注意: <strong>input</strong>参数与任何我们设定的值没有关系,只与时间有关,随着时间的推移,动画的进度也自然的增加,input参数就代表了当前动画的进度,而返回值则表示动画的的当前数值进度.</p><p>  接下来我们自定义一个插值器,从上面分析来看,我们只需实现<code>TimeInterpolator</code>接口就行</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterpolator</span> : <span class="hljs-type">Interpolator</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInterpolation</span><span class="hljs-params">(input: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - input<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  效果图:就是反转一下动画</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/FZYJeW2QntgCyED.gif" alt="MyInterpolator" style="zoom: 50%;" /><h4 id="估值器-TypeEvaluator"><a href="#估值器-TypeEvaluator" class="headerlink" title="估值器(TypeEvaluator)"></a>估值器(TypeEvaluator)</h4><p>​    Evaluator是一个转换器,把插值器得到的小数进度转换为对应的数值位置</p><p>​    先看一下<code>ofInt()</code>的估值器<code>IntEvaluator</code>怎么实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// InttEvaluator实现了TypeEvaluator接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntEvaluator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TypeEvaluator</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-comment">// 重写了evaluate方法</span><br>    <span class="hljs-comment">// 参数ftaction:动画的完成度(从插值器中返回的值)</span><br>    <span class="hljs-comment">// startValue,endValue:动画的初始值和结束值</span><br>    <span class="hljs-comment">// 返回值就是当前数值进度所对应的具体数值</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">evaluate</span><span class="hljs-params">(<span class="hljs-type">float</span> fraction, Integer startValue, Integer endValue)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startInt</span> <span class="hljs-operator">=</span> startValue;<br>        <span class="hljs-comment">// 当前的值 = 开始的值 + 显示进度 * (结束值 - 开始值)</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(startInt + fraction * (endValue - startInt));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p>  对于<code>ValueAnimator.ofObject（）</code>，没有系统默认实现，因为对<strong>对象</strong>的动画操作比较复杂，我们需自定义估值器,来告知系统如何进行从<em>初始对象</em>过渡到<em>结束对象</em>的逻辑</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 首先实现TypeEvaluator接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEvaluator</span> : <span class="hljs-type">TypeEvaluator</span>&lt;<span class="hljs-type">Int</span>&gt; &#123;<br>    <span class="hljs-comment">// 重写rvaluator方法</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">evaluate</span><span class="hljs-params">(fraction: <span class="hljs-type">Float</span>, startValue: <span class="hljs-type">Int</span>, endValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-comment">// 将正常的计算方法反转</span><br>        <span class="hljs-comment">// 当前的值 = 结束的值 - 显示进度 * (结束值 - 开始值)</span><br>        <span class="hljs-keyword">return</span> (endValue - fraction * (endValue - startValue)).toInt()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  这个与上面自定义插值器显示的效果一样</p><p>  效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/MyEvaluator.gif" alt="MyEvaluator" style="zoom: 50%;" /><p>  系统中还有一个估值器,<code>ArgbEvaluator</code>是用来实现颜色过渡转换,源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArgbEvaluator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TypeEvaluator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ArgbEvaluator</span> <span class="hljs-variable">sInstance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArgbEvaluator</span>();<br>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">evaluate</span><span class="hljs-params">(<span class="hljs-type">float</span> fraction, Object startValue, Object endValue)</span> &#123;<br>        <span class="hljs-comment">//这个就和编程基础Ⅱ里求ip地址一样</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">startInt</span> <span class="hljs-operator">=</span> (Integer) startValue;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">startA</span> <span class="hljs-operator">=</span> ((startInt &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">startR</span> <span class="hljs-operator">=</span> ((startInt &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">startG</span> <span class="hljs-operator">=</span> ((startInt &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">startB</span> <span class="hljs-operator">=</span> ( startInt        &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">endInt</span> <span class="hljs-operator">=</span> (Integer) endValue;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">endA</span> <span class="hljs-operator">=</span> ((endInt &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">endR</span> <span class="hljs-operator">=</span> ((endInt &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">endG</span> <span class="hljs-operator">=</span> ((endInt &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">endB</span> <span class="hljs-operator">=</span> ( endInt        &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br><br>        <span class="hljs-comment">// 自然界线性增长的亮度是条曲线,需要转换为LinearRGB(计算机视觉)</span><br>        <span class="hljs-comment">// 计算时用LinearRGB,显示时用sRGB</span><br>        startR = (<span class="hljs-type">float</span>) Math.pow(startR, <span class="hljs-number">2.2</span>);<br>        startG = (<span class="hljs-type">float</span>) Math.pow(startG, <span class="hljs-number">2.2</span>);<br>        startB = (<span class="hljs-type">float</span>) Math.pow(startB, <span class="hljs-number">2.2</span>);<br><br>        endR = (<span class="hljs-type">float</span>) Math.pow(endR, <span class="hljs-number">2.2</span>);<br>        endG = (<span class="hljs-type">float</span>) Math.pow(endG, <span class="hljs-number">2.2</span>);<br>        endB = (<span class="hljs-type">float</span>) Math.pow(endB, <span class="hljs-number">2.2</span>);<br>        <br>        <span class="hljs-comment">// compute the interpolated color in linear space</span><br>        <span class="hljs-comment">// 转换公式与前面IntEvaluator一致</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> startA + fraction * (endA - startA);<br>        <span class="hljs-type">float</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> startR + fraction * (endR - startR);<br>        <span class="hljs-type">float</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> startG + fraction * (endG - startG);<br>        <span class="hljs-type">float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> startB + fraction * (endB - startB);<br><br>        <span class="hljs-comment">// convert back to sRGB in the [0..255] range</span><br>        <span class="hljs-comment">// 归一化</span><br>        a = a * <span class="hljs-number">255.0f</span>;<br>        r = (<span class="hljs-type">float</span>) Math.pow(r, <span class="hljs-number">1.0</span> / <span class="hljs-number">2.2</span>) * <span class="hljs-number">255.0f</span>;<br>        g = (<span class="hljs-type">float</span>) Math.pow(g, <span class="hljs-number">1.0</span> / <span class="hljs-number">2.2</span>) * <span class="hljs-number">255.0f</span>;<br>        b = (<span class="hljs-type">float</span>) Math.pow(b, <span class="hljs-number">1.0</span> / <span class="hljs-number">2.2</span>) * <span class="hljs-number">255.0f</span>;<br><br>        <span class="hljs-keyword">return</span> Math.round(a) &lt;&lt; <span class="hljs-number">24</span> | Math.round(r) &lt;&lt; <span class="hljs-number">16</span> | Math.round(g) &lt;&lt; <span class="hljs-number">8</span> | Math.round(b);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="ofObject"><a href="#ofObject" class="headerlink" title="ofObject()"></a><code>ofObject</code>()</h4><p>  <code>ifInt()</code>和<code>ofFloat()</code>都有系统内置的估值器(<code>FloatEvaluator</code>&amp;<code>IntEvaluato</code>r),但<code>ofObject()</code>没有系统默认的实现,因此,需要我们自定义估值器(<code>TypeEvaluator</code>)来实现从初始对象过渡到结束对象的逻辑.</p><p>  先看看<code>ofObject()</code>的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 第一个参数是自定义的估值器,第二个是可变长参数 </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ValueAnimator <span class="hljs-title function_">ofObject</span><span class="hljs-params">(TypeEvaluator evaluator, Object... values)</span> &#123;<br>        <span class="hljs-type">ValueAnimator</span> <span class="hljs-variable">anim</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueAnimator</span>();<br>        anim.setObjectValues(values);<br>        anim.setEvaluator(evaluator);<br>        <span class="hljs-keyword">return</span> anim;<br>    &#125;<br></code></pre></td></tr></table></figure><p>下面看一个例子,一个抛球的动画</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 用Point记录球的位置</span><br><span class="hljs-keyword">val</span> animator = ValueAnimator.ofObject(FallingBallEvaluator(), Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), Point(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>))<br>        animator.addUpdateListener &#123; animation -&gt;<br>            <span class="hljs-keyword">val</span> mCurPoint = animation.animatedValue <span class="hljs-keyword">as</span> Point<br>            ball.layout(<br>                mCurPoint.x,<br>                mCurPoint.y,<br>                mCurPoint.x + ball.width,<br>                mCurPoint.y + ball.height<br>            )<br>        &#125;<br>        animator.duration = <span class="hljs-number">2000</span><br>        animator.start()<br>    &#125;<br><br><span class="hljs-comment">//自定义的估值器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FallingBallEvaluator</span> : <span class="hljs-type">TypeEvaluator</span>&lt;<span class="hljs-type">Point</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> point = Point()<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">evaluate</span><span class="hljs-params">(fraction: <span class="hljs-type">Float</span>, startValue: <span class="hljs-type">Point</span>, endValue: <span class="hljs-type">Point</span>)</span></span>: Point &#123;<br>        point.x = (startValue.x + fraction * (endValue.x - startValue.x)).toInt()<br>        <span class="hljs-comment">// y轴下落比x轴快</span><br>        <span class="hljs-keyword">if</span> (fraction * <span class="hljs-number">2</span> &lt;= <span class="hljs-number">1</span>) &#123;<br>            point.y = (startValue.y + fraction * <span class="hljs-number">2</span> * (endValue.y - startValue.y)).toInt()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            point.y = endValue.y<br>        &#125;<br>        <span class="hljs-keyword">return</span> point<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/ofObject.gif" alt="ofObject" style="zoom: 50%;" /><h3 id="ObjectAnimator的简单使用"><a href="#ObjectAnimator的简单使用" class="headerlink" title="ObjectAnimator的简单使用"></a>ObjectAnimator的简单使用</h3><p>  <code>ObjectAnimator</code>与 <code>ValueAnimator</code>类的区别：</p><ul><li><code>ValueAnimator</code> 类是先改变值，然后<strong>手动赋值</strong>给对象的属性从而实现动画；是<strong>间接</strong>对<strong>对象</strong>属性进行操作</li><li><code>ObjectAnimator</code> 类是先改变值，然后<strong>自动赋值</strong>给对象的属性从而实现动画；是<strong>直接</strong>对 <strong>对象</strong>属性进行操作</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//因为ObjectAnimator继承ValueAnimator,所以二者的用法很像</span><br><span class="hljs-comment">//这里ofFloat的第一参数是指定要操作哪个控件,第二个参数是这个控件的那个属性,第三个参数是可变长参数,是指这个属性值如何变化</span><br><span class="hljs-keyword">val</span> animator = ObjectAnimator.ofFloat(<span class="hljs-keyword">object</span>, property, values)<br>animator.duration = <span class="hljs-number">500</span><br>        animator.start()<br></code></pre></td></tr></table></figure><p>下面看几个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button1.setOnClickListener &#123;<br>    <span class="hljs-comment">//从0旋转到360°</span><br>    <span class="hljs-keyword">val</span> animator = ObjectAnimator.ofFloat(textView, <span class="hljs-string">&quot;rotation&quot;</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">360f</span>)<br>    animator.duration = <span class="hljs-number">1000</span><br>    animator.start()<br>&#125;<br>button2.setOnClickListener &#123;<br>    <span class="hljs-comment">//在X轴上平移300f</span><br>    <span class="hljs-keyword">val</span> curTranslationX = textView.translationX<br>    <span class="hljs-keyword">val</span> animator = ObjectAnimator.ofFloat(<br>        textView,<br>        <span class="hljs-string">&quot;translationX&quot;</span>,<br>        curTranslationX,<br>        <span class="hljs-number">300f</span>,<br>        curTranslationX<br>    )<br>    animator.duration = <span class="hljs-number">1000</span><br>    animator.start()<br>&#125;<br>button3.setOnClickListener &#123;<br>    <span class="hljs-comment">//在X轴上放大2倍再还原</span><br>    <span class="hljs-keyword">val</span> animator = ObjectAnimator.ofFloat(textView, <span class="hljs-string">&quot;scaleX&quot;</span>, <span class="hljs-number">1f</span>, <span class="hljs-number">3f</span>, <span class="hljs-number">1f</span>)<br>    animator.duration = <span class="hljs-number">1000</span><br>    animator.start()<br><br>&#125;<br>button4.setOnClickListener &#123;<br>    <span class="hljs-comment">//透明度从1到0再到1</span><br>    <span class="hljs-keyword">val</span> animator = ObjectAnimator.ofFloat(textView, <span class="hljs-string">&quot;alpha&quot;</span>, <span class="hljs-number">1f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>)<br>    animator.duration = <span class="hljs-number">1000</span><br>    animator.start()<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图:</p><table><thead><tr><th>旋转</th><th>平移</th></tr></thead><tbody><tr><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/gF1P5G4cJeTI87p.gif" alt="ObjectAnimator-旋转" style="zoom:33%;" /></td><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/dh1uGvkzgPVJi4p.gif" alt="ObjectAnimator-平移" style="zoom:33%;" /></td></tr></tbody></table><table><thead><tr><th>透明</th><th>缩放</th></tr></thead><tbody><tr><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/cr1awb7nK4MvixX.gif" alt="ObjectAnimator-透明" style="zoom: 33%;" /></td><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/RbSHJwYFsu3Lk46.gif" alt="ObjectAnimator-缩放" style="zoom:33%;" /></td></tr></tbody></table><p>常用的属性值</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>Rotation</td><td>绕Z轴旋转</td></tr><tr><td>RotationY</td><td>绕Y轴旋转</td></tr><tr><td>RotationX</td><td>绕X轴旋转</td></tr><tr><td>TranslationX</td><td>在X轴上平移</td></tr><tr><td>TranslationY</td><td>在Y轴上平移</td></tr><tr><td>ScaleX</td><td>在X轴上缩放</td></tr><tr><td>ScaleY</td><td>在Y轴上缩放</td></tr><tr><td>Alpha</td><td>透明度</td></tr></tbody></table><h4 id="自定义ObjectAnimator属性"><a href="#自定义ObjectAnimator属性" class="headerlink" title="自定义ObjectAnimator属性"></a>自定义ObjectAnimator属性</h4><p>  先理一下<code>ObjectAnimator</code>的动画设置流程:<code>OnjectAnimator</code>需要指定操作的控件对象,在动画开始后,先到控件类中去寻找设置属性所对应的<code>set()</code>函数,然后把动画中间值作为参数传给这个<code>set()</code>函数并执行它.所以我们自定义的控件中肯定存在一个<code>set()</code>函数与我们自定义属性相对应.</p><p>  还是前面那个抛球的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先从ImageView派生一个类表示球,并指定一个set函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FallingBallImageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ImageView</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FallingBallImageView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs);<br>    &#125;<br><br>    <span class="hljs-comment">//set函数对应的属性是fallingPos或FallingPos</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFallingPos</span><span class="hljs-params">(Point pos)</span> &#123;<br>        layout(pos.x, pos.y, pos.x + getWidth(), pos.y + getHeight());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//ObjectAnimation操作的控件是ball2,对应的属性是fallingPos,值从当前点运动到点(ball2.x-500, 500),其中自定义的FallingBallEvaluator和前面的一致</span><br><span class="hljs-keyword">val</span> animator = ObjectAnimator.ofObject(<br>                ball2,<br>                <span class="hljs-string">&quot;fallingPos&quot;</span>,<br>                FallingBallEvaluator(),<br>                Point(ball2.x.toInt(), <span class="hljs-number">0</span>),<br>                Point(ball2.x.toInt()-<span class="hljs-number">500</span>, <span class="hljs-number">500</span>)<br>            )<br>            animator.duration = <span class="hljs-number">1000</span><br>            animator.start()<br></code></pre></td></tr></table></figure><p>  效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/1OZoxCjlnV8YIUb.gif" alt="自定义ObjectAnimator属性" style="zoom: 50%;" /><h4 id="关于set-amp-get"><a href="#关于set-amp-get" class="headerlink" title="关于set()&amp;get()"></a>关于<code>set()</code>&amp;<code>get()</code></h4><p>  <code>ObjectAnimator</code>类自动赋给对象的属性的本质是调用该对象属性的<code>set()&amp;get()</code>方法进行赋值,所以，<code>ObjectAnimator.ofFloat(Object object, String property, float ....values)</code>的第二个参数传入值的作用是：让<code>ObjectAnimator</code>类根据传入的属性名 去寻找 该对象对应属性名的 <code>set（）&amp; get（）</code>方法，从而进行对象属性值的赋值.</p><p>  自动赋值的逻辑:</p><ul><li><p>初始化时，如果属性的初始值没有提供，则调用属性的 <code>get（）</code>进行取值,如果没有<code>get()</code>会崩溃掉</p></li><li><p>当<strong>值</strong>变化时，用对象该属性的 <code>set（）</code>方法，从而从而将新的属性值设置给对象属性。</p><p>对于属性动画，其拓展性在于：自定义对象的属性，并通过操作自定义的属性从而实现动画。</p><p>自定义属性的步骤：</p></li><li><p>为对象设置需要操作属性的set（） &amp; get（）方法</p></li><li><p>通过实现TypeEvaluator类从而定义属性变化的逻辑 </p><p>设置对象类属性的<code>set（）</code> &amp; <code>get（）</code>有两种方法：</p></li></ul><ol><li>通过继承原始类，直接给类加上该属性的 <code>get（）</code>&amp;  <code>set（）</code>,如上面的自定义<code>ObjectAnimation</code></li><li>通过包装原始动画对象，间接给对象加上该属性的 <code>get（）</code>&amp;<code>set（）</code>,如下面的例子</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 创建WrapperView类,用于包装View对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WrapperView</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mTarget: View) &#123;<br>    <span class="hljs-keyword">var</span> width: <span class="hljs-built_in">Int</span><br>    <span class="hljs-comment">// 设置set() &amp; get()方法</span><br>        <span class="hljs-keyword">get</span>() = mTarget.layoutParams.width<br>        <span class="hljs-keyword">set</span>(width) &#123;<br>            mTarget.layoutParams.width = width<br>            mTarget.requestLayout()<br>        &#125;<br>&#125;<br><br><span class="hljs-comment">// 得到包装类</span><br><span class="hljs-keyword">val</span> wrapper = WrapperView(textView)<br><span class="hljs-comment">// 直接操作包装类</span><br><span class="hljs-keyword">val</span> animator = ObjectAnimator.ofInt(wrapper, <span class="hljs-string">&quot;width&quot;</span>, <span class="hljs-number">500</span>)<br>animator.duration = <span class="hljs-number">1000</span><br>animator.start()<br></code></pre></td></tr></table></figure><p>  效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/IEWRNeXbdMpHjYx.gif" alt="ObjectAnimator-改变set&get" style="zoom: 50%;" /><h4 id="监听动画"><a href="#监听动画" class="headerlink" title="监听动画"></a>监听动画</h4><ul><li><code>Animation</code>类通过监听动画开始 &#x2F; 结束 &#x2F; 重复 &#x2F; 取消时刻来进行一系列操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AnimatorListener</span> &#123;<br>        <span class="hljs-comment">//开始时调用</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationStart</span><span class="hljs-params">(Animator animation)</span>;<br>        <span class="hljs-comment">//结束调用</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationEnd</span><span class="hljs-params">(Animator animation)</span>;<br>        <span class="hljs-comment">//取消时调用</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationCancel</span><span class="hljs-params">(Animator animation)</span>;<br>        <span class="hljs-comment">//重复时调用</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationRepeat</span><span class="hljs-params">(Animator animation)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>动画适配器AnimatorListenerAdapter</strong></p><p>  有时候我们并不需要监听动画的所有时刻,但<code>addListener(new AnimatorListener())</code>监听器是必须重写4个时刻方法，所以采用动画适配器（<code>AnimatorListenerAdapter</code>），只监听想要监听的时刻</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">animator.addListener(<span class="hljs-keyword">object</span> : AnimatorListenerAdapter() &#123;<br>            <span class="hljs-comment">// 向addListener()方法中传入适配器对象AnimatorListenerAdapter()</span><br>            <span class="hljs-comment">// 由于AnimatorListenerAdapter中已经实现好每个接口,所以这里不用全部实现</span><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAnimationStart</span><span class="hljs-params">(animation: <span class="hljs-type">Animator</span>)</span></span> &#123;<br>                <span class="hljs-comment">// 需要单独重写想要监听的方法就可以</span><br>            &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><h4 id="组合动画（AnimatorSet类）"><a href="#组合动画（AnimatorSet类）" class="headerlink" title="组合动画（AnimatorSet类）"></a>组合动画（AnimatorSet类）</h4><p>AnimatorSet提供了两个函数<code>playSequencially()</code>和<code>playTogether()</code></p><ul><li>playSequentially()表示所有动画依次播放</li><li>playTogether()表示所有动画一起播放</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一个函数是我们最常用的,传入多个Animator对象,这些动画会一起播放</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playTogether</span><span class="hljs-params">(Animator... items)</span> &#123;<br>        <span class="hljs-keyword">if</span> (items != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> play(items[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; items.length; ++i) &#123;<br>                builder.with(items[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playTogether</span><span class="hljs-params">(Collection&lt;Animator&gt; items)</span> &#123;<br>        <span class="hljs-keyword">if</span> (items != <span class="hljs-literal">null</span> &amp;&amp; items.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">for</span> (Animator anim : items) &#123;<br>                <span class="hljs-keyword">if</span> (builder == <span class="hljs-literal">null</span>) &#123;<br>                    builder = play(anim);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    builder.with(anim);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>  <br><span class="hljs-comment">//第一个函数是我们最常用的,传入多个Animator对象,这些动画会依次播放</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playSequentially</span><span class="hljs-params">(Animator... items)</span> &#123;<br>        <span class="hljs-keyword">if</span> (items != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (items.length == <span class="hljs-number">1</span>) &#123;<br>                play(items[<span class="hljs-number">0</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; items.length - <span class="hljs-number">1</span>; ++i) &#123;<br>                    play(items[i]).before(items[i + <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playSequentially</span><span class="hljs-params">(List&lt;Animator&gt; items)</span> &#123;<br>        <span class="hljs-keyword">if</span> (items != <span class="hljs-literal">null</span> &amp;&amp; items.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (items.size() == <span class="hljs-number">1</span>) &#123;<br>                play(items.get(<span class="hljs-number">0</span>));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; items.size() - <span class="hljs-number">1</span>; ++i) &#123;<br>                    play(items.get(i)).before(items.get(i + <span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  下面看一下具体的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// playSequentially()依次播放</span><br> <span class="hljs-comment">// 设置需要组合的动画效果</span><br> <span class="hljs-type">val</span> <span class="hljs-variable">tvAnimator1</span> <span class="hljs-operator">=</span> ObjectAnimator.ofInt(<br>            textView, <span class="hljs-string">&quot;textColor&quot;</span>,<br>            <span class="hljs-number">0xffff00ff</span>.toInt(), <span class="hljs-number">0xffffff00</span>.toInt(), <span class="hljs-number">0xffff00ff</span>.toInt()<br>        )<br>        <span class="hljs-type">val</span> <span class="hljs-variable">tvAnimator2</span> <span class="hljs-operator">=</span> ObjectAnimator.ofFloat(textView, <span class="hljs-string">&quot;translationY&quot;</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">300f</span>, <span class="hljs-number">0f</span>)<br>        <span class="hljs-type">val</span> <span class="hljs-variable">tvAnimator3</span> <span class="hljs-operator">=</span> ObjectAnimator.ofFloat(textView, <span class="hljs-string">&quot;rotation&quot;</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">180f</span>, <span class="hljs-number">0f</span>)<br>        <span class="hljs-comment">// 创建组合动画的对象</span><br>        <span class="hljs-type">val</span> <span class="hljs-variable">animatorSet</span> <span class="hljs-operator">=</span> AnimatorSet()<br>        <span class="hljs-comment">// 根据需求组合动画</span><br>        animatorSet.playSequentially(tvAnimator1, tvAnimator2, tvAnimator3)<br>        animatorSet.duration = <span class="hljs-number">1000</span><br>        animatorSet.start()<br>        <br><span class="hljs-comment">//playTogether()一起播放</span><br><span class="hljs-type">val</span> <span class="hljs-variable">tvAnimator1</span> <span class="hljs-operator">=</span> ObjectAnimator.ofInt(<br>            textView, <span class="hljs-string">&quot;textColor&quot;</span>,<br>            <span class="hljs-number">0xffff00ff</span>.toInt(), <span class="hljs-number">0xffffff00</span>.toInt(), <span class="hljs-number">0xffff00ff</span>.toInt()<br>        )<br>        <span class="hljs-type">val</span> <span class="hljs-variable">tvAnimator2</span> <span class="hljs-operator">=</span> ObjectAnimator.ofFloat(textView, <span class="hljs-string">&quot;translationY&quot;</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">300f</span>, <span class="hljs-number">0f</span>)<br>        <span class="hljs-type">val</span> <span class="hljs-variable">tvAnimator3</span> <span class="hljs-operator">=</span> ObjectAnimator.ofFloat(textView, <span class="hljs-string">&quot;rotation&quot;</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">180f</span>, <span class="hljs-number">0f</span>)<br>        <span class="hljs-type">val</span> <span class="hljs-variable">animatorSet</span> <span class="hljs-operator">=</span> AnimatorSet()<br>        animatorSet.playTogether(tvAnimator1, tvAnimator2, tvAnimator3)<br>        animatorSet.duration = <span class="hljs-number">1000</span><br>        animatorSet.start()<br></code></pre></td></tr></table></figure><p>效果图:</p><table><thead><tr><th>PlayTogether</th><th>PlaySequentially</th></tr></thead><tbody><tr><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/iGaWb2kcLHNBS6t.gif" alt="PlayTogether" style="zoom: 33%;" /></td><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/jRHqCGsl7rmWnpN.gif" alt="PlaySwquentially" style="zoom: 33%;" /></td></tr></tbody></table><p>  除了<code>playSequentally()</code>和<code>playTogether()</code>外,Animator还有Builder帮助我们控制动画的播放顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// 播放当前动画</span><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">play</span><span class="hljs-params">(Animator anim)</span> &#123;<br>    <span class="hljs-keyword">if</span> (anim != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Builder</span>(anim);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>    <span class="hljs-comment">// 将现有动画延迟x毫秒后执行</span><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">with</span><span class="hljs-params">(Animator anim)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNodeForAnimation(anim);<br>        mCurrentNode.addSibling(node);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将现有动画插入到传入的动画之前执行</span><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">before</span><span class="hljs-params">(Animator anim)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNodeForAnimation(anim);<br>        mCurrentNode.addChild(node);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//将现有动画插入到传入的动画之后执行</span><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">after</span><span class="hljs-params">(Animator anim)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> getNodeForAnimation(anim);<br>        mCurrentNode.addParent(node);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将现有动画延迟x毫秒后执行</span><br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">after</span><span class="hljs-params">(<span class="hljs-type">long</span> delay)</span> &#123;<br>        <span class="hljs-comment">// setup a ValueAnimator just to run the clock</span><br>        <span class="hljs-type">ValueAnimator</span> <span class="hljs-variable">anim</span> <span class="hljs-operator">=</span> ValueAnimator.ofFloat(<span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>);<br>        anim.setDuration(delay);<br>        after(anim);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>AnimatorSet可以添加监听器,对应的监听器如下,和前面的监听器一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AnimatorListener</span> &#123;<br>        <span class="hljs-comment">//开始时调用</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationStart</span><span class="hljs-params">(Animator animation)</span>;<br>        <span class="hljs-comment">//结束调用</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationEnd</span><span class="hljs-params">(Animator animation)</span>;<br>        <span class="hljs-comment">//取消时调用</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationCancel</span><span class="hljs-params">(Animator animation)</span>;<br>        <span class="hljs-comment">//重复时调用</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationRepeat</span><span class="hljs-params">(Animator animation)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>注意:</p><ul><li>AnimatorSet的监听函数只是用来监听AnimatorSet的状态,与它里面的动画无关</li><li>AnimatorSet中没有设置循环的函数,所以动画执行一次就结束了,不会执行到onAnimationRepeat()中</li><li>在AnimatorSet中设置了动画时长和插值器,会覆盖原来单个ObjectAnimator的设置,但是<code>setStartDelay()</code>函数例外,它不会覆盖单个动画的延时</li></ul><h4 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h4><p>  属性动画对比原来的视图动画有很多的优点，属性动画可以对所有的对象做动画操作，但Android开发中需要做动画最多的还是View，如果只是对一个view做好几个属性动画，属性动画的写法是比较繁琐的。所以安卓3.1补充了ViewPropertyAnimator这个类,ViewPropertyAnimator专用于操作View动画，语法更加简洁，使用更加方便。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//将textView透明度变为0,并向x轴移动50,y轴移动100,使用起来非常简单        </span><br>textView.animate().alpha(<span class="hljs-number">0f</span>).x(<span class="hljs-number">50f</span>).y(<span class="hljs-number">100f</span>)<br></code></pre></td></tr></table></figure><p>注意:</p><ul><li><p><code>animate()</code>会返回一个ViewPropertyAnimator对象,可以通过调用这个对象的函数来设置需要实现动画的属性</p></li><li><p>自动开始:我们不需要显示的调用<code>start()</code>函数.</p></li><li><p>流畅(Fluent):ViewPropertyAnimator拥有一个流畅的接口(Fluent Interface),他允许将许多个函数调用自然地串在一起,并把一个多属性的动画写成一行代码</p><p>这是一些ViewPropertyAnimator常用的函数</p><table><thead><tr><th align="left">函数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">alpha(float value)</td><td align="left">设置透明度</td></tr><tr><td align="left">alphaBy(float value)</td><td align="left">设置透明度增量</td></tr><tr><td align="left">rotation(float value)</td><td align="left">绕Z轴旋转</td></tr><tr><td align="left">rotationBy(float value)</td><td align="left">绕Z轴旋转增量</td></tr><tr><td align="left">rotationX(float value)</td><td align="left">绕X轴旋转</td></tr><tr><td align="left">rotationXBy(float value)</td><td align="left">绕X轴旋转增量</td></tr><tr><td align="left">rotationY(float value)</td><td align="left">绕Y轴旋转</td></tr><tr><td align="left">rotation</td><td align="left">绕Y轴旋转增量</td></tr><tr><td align="left">scaleX(float value)</td><td align="left">设置X轴方向的缩放大小</td></tr><tr><td align="left">scaleXBy(float value)</td><td align="left">设置X轴方向的缩放大小增量</td></tr><tr><td align="left">scaleY(float value)</td><td align="left">设置Y轴方向的缩放大小</td></tr><tr><td align="left">scaleYBy(float value)</td><td align="left">设置Y轴方向的缩放大小增量</td></tr><tr><td align="left">translationX(float value)</td><td align="left">沿X轴方向平移</td></tr><tr><td align="left">translationY(float value)</td><td align="left">沿Y轴方向平移</td></tr><tr><td align="left">translationYBy(float value)</td><td align="left">设置沿Y轴平移增量</td></tr><tr><td align="left">x(float value)</td><td align="left">相对于父容器左上角坐标在X轴方向的位置</td></tr><tr><td align="left">xBy(float value)</td><td align="left">相对于父容器左上角坐标在X轴方向的增量</td></tr><tr><td align="left">y(float value)</td><td align="left">相对于父容器左上角坐标在Y轴方向的位置</td></tr><tr><td align="left">yBy(float value)</td><td align="left">相对于父容器左上角坐标在Y轴方向的增量</td></tr><tr><td align="left">z(float value)</td><td align="left">相对于父容器左上角坐标在Z轴方向的位置</td></tr><tr><td align="left">zBy(float value)</td><td align="left">相对于父容器左上角坐标在Z轴方向的增量</td></tr></tbody></table></li></ul><h4 id="XML实现"><a href="#XML实现" class="headerlink" title="XML实现"></a>XML实现</h4><p>  属性动画一般是在代码中实现,如果需要复用的话可以写在xml中</p><p>  在res&#x2F;animator文件夹下，创建animator_translation.xml文件。XML文件有四个标签可用.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>    <span class="hljs-comment">&lt;!--相当于AnimatorSet--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">animator</span> /&gt;</span>   <span class="hljs-comment">&lt;!--相当于ValueAnimator--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">objectAnimator</span>&gt;</span>     <span class="hljs-comment">&lt;!--相当于ObjectAnimator--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">propertyValuesHolder</span> /&gt;</span>  <span class="hljs-comment">&lt;!--相当于PropertyValuesHolder--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">objectAnimator</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><code>set</code>标签对应代码的<code>AnimatorSet</code>,只有一个属性可以设置：<code>android:ordering</code>，取值：同时播放<code>together</code>、顺序播放<code>sequentially</code>。</p><p><code>animator</code>标签对应代码的<code>ValueAnimator</code>，可以设置如下属性：</p><ul><li><code>android:propertyName</code>:属性名</li><li><code>android:duration</code>:动画时长</li><li><code>android:valueType</code>:属性类型,<code>intType</code>、<code>floatType</code>、<code>colorType</code>、<code>pathType</code></li><li><code>android:valueFrom</code>:属性初始值</li><li><code>android:valueTo</code>:属性结束值</li><li><code>android:repeatCount</code>:重复次数</li><li><code>android:repeatMode</code>:重复模式</li><li><code>android:interpolator</code>:插值器。</li><li><code>android:startOffset</code>:延迟，对应<code>startOffset()</code>延迟多少毫秒执行</li></ul><p><code>objectAnimator</code>属性对应代码<code>ObjectAnimator</code>,由于继承自<code>ValueAnimator</code>，所以属性相对多了<code>android:propertyName</code>。</p><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">objectAnimator</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:propertyName</span>=<span class="hljs-string">&quot;ScaleX&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:interpolator</span>=<span class="hljs-string">&quot;@android:interpolator/linear&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:repeatCount</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:repeatMode</span>=<span class="hljs-string">&quot;restart&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:startOffset</span>=<span class="hljs-string">&quot;100&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:valueFrom</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:valueTo</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="PropertyValuesHolder与KeyFrame"><a href="#PropertyValuesHolder与KeyFrame" class="headerlink" title="PropertyValuesHolder与KeyFrame"></a>PropertyValuesHolder与KeyFrame</h4><p>  PropertyValuesHolder这个类的意义就是，保存了动画过程中所需要操作的属性和对应的值。我们通过<code>ofFloat(Object target, String propertyName, float… values)</code>构造的动画，<code>ofFloat()</code>的内部实现其实就是将传进来的参数封装成 PropertyValuesHolder实例来保存动画状态。在封装成 PropertyValuesHolder实例以后，后期的各种操作也是以 PropertyValuesHolder 为主的。</p><p>创建PropertyValuesHolder实例的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PropertyValuesHolder <span class="hljs-title function_">ofFloat</span><span class="hljs-params">(String propertyName, <span class="hljs-type">float</span>... values)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PropertyValuesHolder <span class="hljs-title function_">ofInt</span><span class="hljs-params">(String propertyName, <span class="hljs-type">int</span>... values)</span>   <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PropertyValuesHolder <span class="hljs-title function_">ofObject</span><span class="hljs-params">(String propertyName, TypeEvaluator evaluator,Object... values)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PropertyValuesHolder <span class="hljs-title function_">ofKeyframe</span><span class="hljs-params">(String propertyName, Keyframe... values)</span>  <br></code></pre></td></tr></table></figure><p>  可以看到在<code>ObjectAnimator.ofFloat</code>中只比<code>PropertyValuesHolder.ofFloat()</code>多了一个target.</p><p>将构造的PropertyValuesHolder实例设置进 ObjectAnimator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ObjectAnimator <span class="hljs-title function_">ofPropertyValuesHolder</span><span class="hljs-params">(Object target,PropertyValuesHolder... values)</span><br></code></pre></td></tr></table></figure><p>PropertyValuesHolder 的<code>ofObject()</code>的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PropertyValuesHolder <span class="hljs-title function_">ofObject</span><span class="hljs-params">(String propertyName, TypeEvaluator evaluator,Object... values)</span>  <br></code></pre></td></tr></table></figure><p><strong>Keyframe</strong></p><p>  KeyFrame主要用于自定义控制动画速率，KeyFrame直译过来就是关键帧。一个关键帧必须包含两个原素，第一时间点，第二位置。所以这个关键帧是表示的是某个物体在哪个时间点应该在哪个位置上。</p><p>  KeyFrame使用流程如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 生成 Keyframe 对象；</span><br><span class="hljs-keyword">val</span> frame0 = Keyframe.ofFloat(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>)<br>       <span class="hljs-keyword">val</span> frame1 = Keyframe.ofFloat(<span class="hljs-number">0.1f</span>, -<span class="hljs-number">45f</span>)<br>       <span class="hljs-keyword">val</span> frame2 = Keyframe.ofFloat(<span class="hljs-number">1f</span>, <span class="hljs-number">0f</span>)<br><span class="hljs-comment">// 利用 PropertyValuesHolder.ofKeyframe()生成 PropertyValuesHolder 对象</span><br>       <span class="hljs-keyword">val</span> frameHolder = PropertyValuesHolder.ofKeyframe(<span class="hljs-string">&quot;rotation&quot;</span>, frame0, frame1, frame2)<br><span class="hljs-comment">// ObjectAnimator.ofPropertyValuesHolder()生成对应的 Animator</span><br>       <span class="hljs-keyword">val</span> animator: Animator = ObjectAnimator.ofPropertyValuesHolder(textView, frameHolder)<br>       animator.duration = <span class="hljs-number">1000</span><br>       animator.start()<br></code></pre></td></tr></table></figure><p>效果图:</p><p>注意：在设置<code>ObjectAnimator.ofPropertyValuesHolder()</code>时</p><ul><li>如果去掉第 0 帧<code>Keyframe.ofFloat(0f, 0)</code>，将以传入的第一个关键帧为起始位置</li><li>如果去掉结束帧<code>Keyframe.ofFloat(1f,0)</code>，将以传入最后一个关键帧为结束位置</li><li>使用 Keyframe 来构建动画，至少要有两个或两个以上帧。</li></ul><p>KeyFrame的一些常用方法(基本和前面一样)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// fraction：表示当前的显示进度, value：表示当前应该在的位置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Keyframe <span class="hljs-title function_">ofFloat</span><span class="hljs-params">(<span class="hljs-type">float</span> fraction, <span class="hljs-type">float</span> value)</span><br><span class="hljs-comment">// 表示动画进度为0时，动画所在的数值位置为0</span><br>Keyframe.ofFloat(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 表示动画进度为 25%时，动画所在的数值位置为-20</span><br>Keyframe.ofFloat(<span class="hljs-number">0.25f</span>, -<span class="hljs-number">20f</span>)；<br><span class="hljs-comment">// 表示动画结束时，动画所在的数值位置为0</span><br>Keyframe.ofFloat(<span class="hljs-number">1f</span>,<span class="hljs-number">0</span>)；<br><span class="hljs-comment">// 设置fraction参数，即Keyframe所对应的进度</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFraction</span><span class="hljs-params">(<span class="hljs-type">float</span> fraction)</span><br><span class="hljs-comment">// 设置当前Keyframe所对应的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object value)</span><br><span class="hljs-comment">// 设置Keyframe动作期间所对应的插值器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInterpolator</span><span class="hljs-params">(TimeInterpolator interpolator)</span><br></code></pre></td></tr></table></figure><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="ValueAnimator源码解读"><a href="#ValueAnimator源码解读" class="headerlink" title="ValueAnimator源码解读"></a>ValueAnimator源码解读</h4><p>  讲完了使用,我们看看动画是怎么跑起来的,我们先分析<code>ValueAnimator</code>,<code>ObjectAnimator</code>是继承<code>ValueAnimator</code>,我们分析完<code>ValueAnimator</code>后再看看<code>ObjectAniamtor</code>多做了哪些工作</p><p>  先从<code>animator.start()</code>开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ValueAnimator</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 调用内部的start,参数playBackwards是否反向播放,一般为false</span><br>        start(<span class="hljs-literal">false</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>  进入内部的<code>start(boolean)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ValueAnimator</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">boolean</span> playBackwards)</span> &#123;<br>        <span class="hljs-keyword">if</span> (Looper.myLooper() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AndroidRuntimeException</span>(<span class="hljs-string">&quot;Animators may only be run on Looper threads&quot;</span>);<br>        &#125;<br>        mReversing = playBackwards;<br>        mSelfPulse = !mSuppressSelfPulseRequested;<br>        <span class="hljs-keyword">if</span> (playBackwards &amp;&amp; mSeekFraction != -<span class="hljs-number">1</span> &amp;&amp; mSeekFraction != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mRepeatCount == INFINITE) &#123;<br>                <span class="hljs-comment">// Calculate the fraction of the current iteration.</span><br>                <span class="hljs-type">float</span> <span class="hljs-variable">fraction</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (mSeekFraction - Math.floor(mSeekFraction));<br>                mSeekFraction = <span class="hljs-number">1</span> - fraction;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mSeekFraction = <span class="hljs-number">1</span> + mRepeatCount - mSeekFraction;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">// 开始标志</span><br>        mStarted = <span class="hljs-literal">true</span>;<br>        mPaused = <span class="hljs-literal">false</span>;<br>        mRunning = <span class="hljs-literal">false</span>;<br>        mAnimationEndRequested = <span class="hljs-literal">false</span>;<br>        mLastFrameTime = -<span class="hljs-number">1</span>;<br>        mFirstFrameTime = -<span class="hljs-number">1</span>;<br>        mStartTime = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 注册animation回调</span><br>        addAnimationCallback(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">if</span> (mStartDelay == <span class="hljs-number">0</span> || mSeekFraction &gt;= <span class="hljs-number">0</span> || mReversing) &#123;<br>            <span class="hljs-comment">// 开始动画</span><br>            startAnimation();<br>            <span class="hljs-keyword">if</span> (mSeekFraction == -<span class="hljs-number">1</span>) &#123;<br>                setCurrentPlayTime(<span class="hljs-number">0</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                setCurrentFraction(mSeekFraction);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  都是一些变量初始化,有两个方法<code>addAnimationCallback(0);</code>,<code>startAnimation()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ValueAnimator</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startAnimation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) &#123;<br>            Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, getNameForTrace(),<br>                    System.identityHashCode(<span class="hljs-built_in">this</span>));<br>        &#125;<br><br>        mAnimationEndRequested = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 进行一些初始化</span><br>        initAnimation();<br>        mRunning = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (mSeekFraction &gt;= <span class="hljs-number">0</span>) &#123;<br>            mOverallFraction = mSeekFraction;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mOverallFraction = <span class="hljs-number">0f</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mListeners != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 通知动画开始</span><br>            notifyStartListeners();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  里面调用了两个方法<code>initAnimation()</code>和<code>notifyStartListeners()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"> <span class="hljs-comment">// ValueAnimation</span><br> <span class="hljs-comment">// 一些初始化操作</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">initAnimation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!mInitialized) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">numValues</span> <span class="hljs-operator">=</span> mValues.length;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numValues; ++i) &#123;<br>                mValues[i].init();<br>            &#125;<br>            mInitialized = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyStartListeners</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (mListeners != <span class="hljs-literal">null</span> &amp;&amp; !mStartListenersCalled) &#123;<br>            ArrayList&lt;AnimatorListener&gt; tmpListeners =<br>                    (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">numListeners</span> <span class="hljs-operator">=</span> tmpListeners.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;<br>                <span class="hljs-comment">// 回调listener 接口</span><br>                tmpListeners.get(i).onAnimationStart(<span class="hljs-built_in">this</span>, mReversing);<br>            &#125;<br>        &#125;<br>        mStartListenersCalled = <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  都是一些初始化的操作,没有开始动画,我们回头看看<code>addAnimationCallback()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ValueAnimator</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAnimationCallback</span><span class="hljs-params">(<span class="hljs-type">long</span> delay)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!mSelfPulse) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// AnimationHandler 一个处理动画的类</span><br>        getAnimationHandler().addAnimationFrameCallback(<span class="hljs-built_in">this</span>, delay);<br>    &#125;<br></code></pre></td></tr></table></figure><p>  看到这里调用了<code>AnimationHandler</code>,一个处理动画的单例类,并且把<code>this</code>传了进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AnimationHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAnimationFrameCallback</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AnimationFrameCallback callback, <span class="hljs-type">long</span> delay)</span> &#123;<br>        <span class="hljs-comment">// mAnimationFrameCallback 是ArrayList列表,储存了AnimationFrameCallback 对象</span><br>        <span class="hljs-comment">// 当mAnimationFrameCallback=0时,第一次执行动画</span><br>        <span class="hljs-keyword">if</span> (mAnimationCallbacks.size() == <span class="hljs-number">0</span>) &#123;<br>            getProvider().postFrameCallback(mFrameCallback);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!mAnimationCallbacks.contains(callback)) &#123;<br>            mAnimationCallbacks.add(callback);<br>        &#125;<br>    <span class="hljs-comment">// delay是setStartDelay()设置的延迟执行</span><br>        <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span>) &#123;<br>            mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当<code>mAnimationFrameCallback=0</code>时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AnimationHandler</span><br><span class="hljs-keyword">private</span> AnimationFrameCallbackProvider <span class="hljs-title function_">getProvider</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (mProvider == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 直接new一个</span><br>            mProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFrameCallbackProvider</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> mProvider;<br>    &#125;<br><br><span class="hljs-comment">// AnimationHandler MyFrameCallbackProvider</span><br><span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postFrameCallback</span><span class="hljs-params">(Choreographer.FrameCallback callback)</span> &#123;<br>            <span class="hljs-comment">// Choreographer 负责刷新注册监听以及提供回调接口供底层调用</span><br>            mChoreographer.postFrameCallback(callback);<br>        &#125;<br><br><br><span class="hljs-comment">// Choreographer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postFrameCallback</span><span class="hljs-params">(FrameCallback callback)</span> &#123;<br>        postFrameCallbackDelayed(callback, <span class="hljs-number">0</span>);<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postFrameCallbackDelayed</span><span class="hljs-params">(FrameCallback callback, <span class="hljs-type">long</span> delayMillis)</span> &#123;<br>        <span class="hljs-keyword">if</span> (callback == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;callback must not be null&quot;</span>);<br>        &#125;<br>    <span class="hljs-comment">// 内部调用了 postCallbackDelayedInternal()</span><br>        postCallbackDelayedInternal(CALLBACK_ANIMATION,<br>                callback, FRAME_CALLBACK_TOKEN, delayMillis);<br>    &#125;<br></code></pre></td></tr></table></figure><p>  <code>Choreographer</code>内部有几个队列，上面方法的第一个参数 <code>CALLBACK_ANIMATION</code>就是用于区分这些队列的，而每个队列里可以存放 <code>FrameCallback</code>对象，也可以存放 Runnable 对象。Animation 动画原理上就是通过 ViewRootImpl 生成一个 <code>doTraversal()</code> 的 Runnable 对象（其实也就是遍历 View 树的工作）存放到 Choreographer 的队列里的。而这些队列里的工作，都是用于在接收到屏幕刷新信号时取出来执行的。但有一个关键点，Choreographer 要能够接收到屏幕刷新信号的事件，是需要先调用 Choreographer 的 <code>scheduleVsyncLocked()</code> 方法来向底层注册监听下一个屏幕刷新信号事件的。  </p><p>  **小结:**当<code>ValueAnimator</code>调用了<code>start()</code>方法之后，首先会对一些变量进行初始化工作并通知动画开始了，然后<code>ValueAnimator</code>实现了 <code>AnimationFrameCallback</code>接口，并通过<code>AnimationHander</code>将自身 this 作为参数传到<code>mAnimationCallbacks</code>列表里缓存起来。而<code>AnimationHandler</code>在<code>mAnimationCallbacks</code>列表大小为 0 时会通过内部类<code>MyFrameCallbackProvider</code>将一个<code>mFrameCallback</code>工作缓存到<code>Choreographer</code>的待执行队列里，并向底层注册监听下一个屏幕刷新信号事件。</p><p>  当接收到屏幕刷新信号之后，mFrameCallback 又继续做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AnimationHandler</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Choreographer.<span class="hljs-type">FrameCallback</span> <span class="hljs-variable">mFrameCallback</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Choreographer</span>.FrameCallback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFrame</span><span class="hljs-params">(<span class="hljs-type">long</span> frameTimeNanos)</span> &#123;<br>            <span class="hljs-comment">// 处理动画相关工作</span><br>            doAnimationFrame(getProvider().getFrameTime());<br>            <span class="hljs-keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 继续向底层注册下一个屏幕刷新事件,因为动画是持续的过程,每一帧都会处理一个动画进度,需要在动画结束前注册监听下一个信号事件</span><br>                getProvider().postFrameCallback(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><p>  当第一个属性动画调用了 <code>start()</code> 时，由于 mAnimationCallbacks 列表此时大小为 0，所以直接由 <code>addAnimationFrameCallback()</code> 方法内部间接的向底层注册下一个屏幕刷新信号事件，然后将该动画加入到列表里。而当接收到屏幕刷新信号时，mFrameCallback 的 <code>doFrame()</code> 会被回调，该方法内部做了两件事，一是去处理当前帧的动画，二则是根据列表的大小是否不为 0 来决定继续向底层注册监听下一个屏幕刷新信号事件，如此反复，直至列表大小为 0。</p><p>  接下来跟着<code>doAnimationFrame()</code>看看属性动画是怎么执行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AnimationHandler</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAnimationFrame</span><span class="hljs-params">(<span class="hljs-type">long</span> frameTime)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> mAnimationCallbacks.size();<br>    <span class="hljs-comment">// 循环遍历列表,取出每一个ValueAnimator</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-comment">// ValueAnimator实现了AnimationFrameCallback接口,并且在调用Start()方法后通过AnimationHandler将this缓存到这个列表里</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">AnimationFrameCallback</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> mAnimationCallbacks.get(i);<br>            <span class="hljs-keyword">if</span> (callback == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 判断是否到了执行时间</span><br>            <span class="hljs-keyword">if</span> (isCallbackDue(callback, currentTime)) &#123;<br>                <span class="hljs-comment">// 处理动画逻辑</span><br>                callback.doAnimationFrame(frameTime);<br>                <span class="hljs-keyword">if</span> (mCommitCallbacks.contains(callback)) &#123;<br>                    getProvider().postCommitCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                            commitAnimationFrame(callback, getProvider().getFrameTime());<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 处理已经结束的动画,清理列表</span><br>        cleanUpList();<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们先看看<code>cleanUpList()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AnimationHandler</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanUpList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (mListDirty) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> mAnimationCallbacks.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-comment">// 就是把null的对象移除掉</span><br>                <span class="hljs-keyword">if</span> (mAnimationCallbacks.get(i) == <span class="hljs-literal">null</span>) &#123;<br>                    mAnimationCallbacks.remove(i);<br>                &#125;<br>            &#125;<br>            mListDirty = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  再看看处理动画逻辑<code>doAnimationFrame()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ValueAnimator </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doAnimationFrame</span><span class="hljs-params">(<span class="hljs-type">long</span> frameTime)</span> &#123;<br>        <span class="hljs-keyword">if</span> (mStartTime &lt; <span class="hljs-number">0</span>) &#123;<br>            mStartTime = mReversing<br>                    ? frameTime<br>                    : frameTime + (<span class="hljs-type">long</span>) (mStartDelay * resolveDurationScale());<br>        &#125;<br><br>        <span class="hljs-comment">// Handle pause/resume</span><br>        <span class="hljs-keyword">if</span> (mPaused) &#123;<br>            mPauseTime = frameTime;<br>            removeAnimationCallback();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mResumed) &#123;<br>            mResumed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (mPauseTime &gt; <span class="hljs-number">0</span>) &#123;<br>                mStartTime += (frameTime - mPauseTime);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!mRunning) &#123;<br>            <span class="hljs-keyword">if</span> (mStartTime &gt; frameTime &amp;&amp; mSeekFraction == -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mRunning = <span class="hljs-literal">true</span>;<br>                startAnimation();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (mLastFrameTime &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// mSeekFraction从某个位置开始</span><br>            <span class="hljs-keyword">if</span> (mSeekFraction &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">seekTime</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) (getScaledDuration() * mSeekFraction);<br>                <span class="hljs-comment">// mStartTime 第一帧的时间戳</span><br>                mStartTime = frameTime - seekTime;<br>                mSeekFraction = -<span class="hljs-number">1</span>;<br>            &#125;<br>            mStartTimeCommitted = <span class="hljs-literal">false</span>; <span class="hljs-comment">// allow start time to be compensated for jank</span><br>        &#125;<br>        mLastFrameTime = frameTime;<br> <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> Math.max(frameTime, mStartTime);<br>        <span class="hljs-comment">// 根据当前时间计算帧的动画进度(核心)</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">finished</span> <span class="hljs-operator">=</span> animateBasedOnTime(currentTime);<br><br>        <span class="hljs-keyword">if</span> (finished) &#123;<br>            <span class="hljs-comment">// 将当前动画从mAniamtionCallbacks 中移除</span><br>            endAnimation();<br>        &#125;<br>        <span class="hljs-keyword">return</span> finished;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  先分析<code>endAnimation()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ValueAnimator</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endAnimation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (mAnimationEndRequested) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 调用AniamtionHandler 的removeCallback()</span><br>        removeAnimationCallback();<br><br>        mAnimationEndRequested = <span class="hljs-literal">true</span>;<br>        mPaused = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">notify</span> <span class="hljs-operator">=</span> (mStarted || mRunning) &amp;&amp; mListeners != <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (notify &amp;&amp; !mRunning) &#123;<br>            notifyStartListeners();<br>        &#125;<br>        mRunning = <span class="hljs-literal">false</span>;<br>        mStarted = <span class="hljs-literal">false</span>;<br>        mStartListenersCalled = <span class="hljs-literal">false</span>;<br>        mLastFrameTime = -<span class="hljs-number">1</span>;<br>        mFirstFrameTime = -<span class="hljs-number">1</span>;<br>        mStartTime = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (notify &amp;&amp; mListeners != <span class="hljs-literal">null</span>) &#123;<br>            ArrayList&lt;AnimatorListener&gt; tmpListeners =<br>                    (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">numListeners</span> <span class="hljs-operator">=</span> tmpListeners.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;<br>                <span class="hljs-comment">// 通知动画结束</span><br>                tmpListeners.get(i).onAnimationEnd(<span class="hljs-built_in">this</span>, mReversing);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// mReversing needs to be reset *after* notifying the listeners for the end callbacks.</span><br>        mReversing = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) &#123;<br>            Trace.asyncTraceEnd(Trace.TRACE_TAG_VIEW, getNameForTrace(),<br>                    System.identityHashCode(<span class="hljs-built_in">this</span>));<br>        &#125;<br>    &#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAnimationCallback</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!mSelfPulse) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        getAnimationHandler().removeCallback(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br><span class="hljs-comment">// AnimarionHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeCallback</span><span class="hljs-params">(AnimationFrameCallback callback)</span> &#123;<br>        mCommitCallbacks.remove(callback);<br>        mDelayedCallbackStartTime.remove(callback);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> mAnimationCallbacks.indexOf(callback);<br>        <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 把结束的动画赋值为空</span><br>            mAnimationCallbacks.set(id, <span class="hljs-literal">null</span>);<br>            mListDirty = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  如果动画结束，那么它会将其自身在 AnimationCallbacks 列表里的引用赋值为 null，然后移出列表的工作就交由 AnimationHandler 去做。</p><p>  接下来看看处理动画第一帧的工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">if</span> (mStartTime &lt; <span class="hljs-number">0</span>) &#123;<br>            mStartTime = mReversing<br>                    ? frameTime<br>                    : frameTime + (<span class="hljs-type">long</span>) (mStartDelay * resolveDurationScale());<br>        &#125;<br><span class="hljs-keyword">if</span> (mLastFrameTime &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// mSeekFraction从某个位置开始</span><br>            <span class="hljs-keyword">if</span> (mSeekFraction &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">seekTime</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) (getScaledDuration() * mSeekFraction);<br>                <span class="hljs-comment">// mStartTime 第一帧的时间戳</span><br>                mStartTime = frameTime - seekTime;<br>                mSeekFraction = -<span class="hljs-number">1</span>;<br>            &#125;<br>            mStartTimeCommitted = <span class="hljs-literal">false</span>; <span class="hljs-comment">// allow start time to be compensated for jank</span><br>        &#125;<br></code></pre></td></tr></table></figure><p>  记录动画第一帧的时间了，mStartTime 变量就是表示第一帧的时间戳， mSeekFraction 变量，可以任意选择从某个进度开始播放。可以通过 <code>setCurrentPlayTime()</code>设置。</p><p>小结:</p><ul><li><p>ValueAnimator 属性动画调用了 start() 之后，会先去进行一些初始化工作，包括变量的初始化、通知动画开始事件；</p></li><li><p>然后通过 AnimationHandler 将其自身 this 添加到 mAnimationCallbacks 队列里，AnimationHandller 是一个单例类，为所有的属性动画服务，列表里存放着所有正在进行或准备开始的属性动画；</p></li><li><p>如果当前存在要运行的动画，那么 AnimationHandler 会去通过 Choreographer 向底层注册监听下一个屏幕刷新信号，当接收到信号时，它的 mFrameCallback 会开始进行工作，工作的内容包括遍历列表来分别处理每个属性动画在当前帧的行为，处理完列表中的所有动画后，如果列表还不为 0，那么它又会通过 Choreographer 再去向底层注册监听下一个屏幕刷新信号事件，如此反复，直至所有的动画都结束。</p></li><li><p>AnimationHandler 遍历列表处理动画是在 doAnimationFrame() 中进行，而具体每个动画的处理逻辑则是在各自 ValueAnimator 的 doAnimationFrame() 中进行，各个动画如果处理完自身的工作后发现动画已经结束了，那么会将其在列表中的引用赋值为空，AnimationHandler 最后会去将列表中所有为 null 的都移除掉，来清理资源。</p></li><li><p>每个动画 ValueAnimator 在处理自身的动画行为时，首先，如果当前是动画的第一帧，那么会根据是否有”跳过片头”（setCurrentPlayTime()）来记录当前动画第一帧的时间 mStartTime 应该是什么。</p><p>接下来分析<code>animateBasedOnTime()</code>,根据当前时间计算并实现当前帧的动画工作.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ValueAnimator</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">animateBasedOnTime</span><span class="hljs-params">(<span class="hljs-type">long</span> currentTime)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">done</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (mRunning) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">scaledDuration</span> <span class="hljs-operator">=</span> getScaledDuration();<br>            <span class="hljs-comment">// 根据当前时间以及动画第一帧时间和动画持续时长来计算当前进度</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">fraction</span> <span class="hljs-operator">=</span> scaledDuration &gt; <span class="hljs-number">0</span> ?<br>                    (<span class="hljs-type">float</span>)(currentTime - mStartTime) / scaledDuration : <span class="hljs-number">1f</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">lastFraction</span> <span class="hljs-operator">=</span> mOverallFraction;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">newIteration</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) fraction &gt; (<span class="hljs-type">int</span>) lastFraction;<br>            <span class="hljs-comment">// 根据mRepeatCount处理动画是否重新开始</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">lastIterationFinished</span> <span class="hljs-operator">=</span> (fraction &gt;= mRepeatCount + <span class="hljs-number">1</span>) &amp;&amp;<br>                    (mRepeatCount != INFINITE);<br>            <span class="hljs-keyword">if</span> (scaledDuration == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 0 duration animator, ignore the repeat count and skip to the end</span><br>                done = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newIteration &amp;&amp; !lastIterationFinished) &#123;<br>                <span class="hljs-comment">// Time to repeat</span><br>                <span class="hljs-keyword">if</span> (mListeners != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">numListeners</span> <span class="hljs-operator">=</span> mListeners.size();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;<br>                        mListeners.get(i).onAnimationRepeat(<span class="hljs-built_in">this</span>);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastIterationFinished) &#123;<br>                done = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 确保动画进度取值在0-1之间,(因为属性动画有setRepeatCount()方法,会导致进度超过1.</span><br>            mOverallFraction = clampFraction(fraction);<br>            <span class="hljs-type">float</span> <span class="hljs-variable">currentIterationFraction</span> <span class="hljs-operator">=</span> getCurrentIterationFraction(<br>                    mOverallFraction, mReversing);<br>            <span class="hljs-comment">// 应用动画</span><br>            animateValue(currentIterationFraction);<br>        &#125;<br>        <span class="hljs-keyword">return</span> done;<br>    &#125;<br></code></pre></td></tr></table></figure><p>进入<code>animateValue()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ValueAnimator</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">animateValue</span><span class="hljs-params">(<span class="hljs-type">float</span> fraction)</span> &#123;<br>        <span class="hljs-comment">// 根据插值器计算当前真正的动画进度</span><br>        fraction = mInterpolator.getInterpolation(fraction);<br>        mCurrentFraction = fraction;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numValues</span> <span class="hljs-operator">=</span> mValues.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numValues; ++i) &#123;<br>            <span class="hljs-comment">// 根据动画进度计算出实际的数值</span><br>            <span class="hljs-comment">// mValues 是 PropertyValuesHolder 类型数组</span><br>            mValues[i].calculateValue(fraction);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mUpdateListeners != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">numListeners</span> <span class="hljs-operator">=</span> mUpdateListeners.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;<br>                <span class="hljs-comment">// 通知动画进度的回调</span><br>                mUpdateListeners.get(i).onAnimationUpdate(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  <code>PropertyValuesHolder</code>就是一个存放属性和值的容器,而每次动画的过程中都会从这个容器中取值或者设置值  </p><p>看看<code>calculateValue()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// PropertyValuesHolder</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">calculateValue</span><span class="hljs-params">(<span class="hljs-type">float</span> fraction)</span> &#123;<br>        <span class="hljs-comment">// 通过KeyFrames计算</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> mKeyframes.getValue(fraction);<br>        mAnimatedValue = mConverter == <span class="hljs-literal">null</span> ? value : mConverter.convert(value);<br>    &#125;<br><br><span class="hljs-comment">// KeyFrames 是一个接口,找一下他的实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Keyframes</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    Object <span class="hljs-title function_">getValue</span><span class="hljs-params">(<span class="hljs-type">float</span> fraction)</span>;<br>&#125;<br><br><span class="hljs-comment">// PropertyValuesHolder</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFloatValues</span><span class="hljs-params">(<span class="hljs-type">float</span>... values)</span> &#123;<br>        mValueType = <span class="hljs-type">float</span>.class;<br>        mKeyframes = KeyframeSet.ofFloat(values);<br>    &#125;<br></code></pre></td></tr></table></figure><p>其实 <code>ValueAnimator.ofInt()</code> 内部会根据相应的方法来创建 mKeyframes 对象，也就是说，在实例化属性动画时，这些 mKeyframes 也顺便被实例化了。</p><p><a name="KeyframeSet的ofInt()"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// KeyframeSet</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> KeyframeSet <span class="hljs-title function_">ofInt</span><span class="hljs-params">(<span class="hljs-type">int</span>... values)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numKeyframes</span> <span class="hljs-operator">=</span> values.length;<br>        IntKeyframe keyframes[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntKeyframe</span>[Math.max(numKeyframes,<span class="hljs-number">2</span>)];<br>        <span class="hljs-keyword">if</span> (numKeyframes == <span class="hljs-number">1</span>) &#123;<br>            keyframes[<span class="hljs-number">0</span>] = (IntKeyframe) Keyframe.ofInt(<span class="hljs-number">0f</span>);<br>            keyframes[<span class="hljs-number">1</span>] = (IntKeyframe) Keyframe.ofInt(<span class="hljs-number">1f</span>, values[<span class="hljs-number">0</span>]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            keyframes[<span class="hljs-number">0</span>] = (IntKeyframe) Keyframe.ofInt(<span class="hljs-number">0f</span>, values[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; numKeyframes; ++i) &#123;<br>                <span class="hljs-comment">// 创建关键帧时,第一个参数是关键帧在整个区间之间的位置,第二个参数就是它的值是多少</span><br>                keyframes[i] =<br>                        (IntKeyframe) Keyframe.ofInt((<span class="hljs-type">float</span>) i / (numKeyframes - <span class="hljs-number">1</span>), values[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 创建了IntKeyframeSet 对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntKeyframeSet</span>(keyframes);<br>    &#125;<br></code></pre></td></tr></table></figure><p>  动画在处理当前帧的工作时，会去计算当前帧的动画进度，然后根据这个 0-1 区间的进度，映射到我们需要的数值，而这个映射之后的数值就是通过 mKeyframes 的 <code>getValue()</code> 里取到的，mKeyframes 是一个 KeyframeSet 对象，在创建属性动画时也顺带被创建了，而创建属性动画时，我们会传入一个我们想要的数值，如 <code>ValueAnimator.ofInt(100)</code> 就表示我们想要的动画变化范围是 0-100，那么这个 100 在内部也会被传给 <code>KeyframeSet.ofInt(100)</code>，然后就是进入到上面代码块里的创建工作了。</p><p>  <code>KeyframeSet.ofInt()</code> 最后是创建了一个 IntKeyframeSet 对象,我们看看这个类的<code>getValue()</code>是怎么实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// IntKeyframeSet</span><br> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">(<span class="hljs-type">float</span> fraction)</span> &#123;<br>        <span class="hljs-keyword">return</span> getIntValue(fraction);<br>    &#125;<br><br><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIntValue</span><span class="hljs-params">(<span class="hljs-type">float</span> fraction)</span> &#123;<br>        <span class="hljs-comment">// 处理第一帧</span><br>        <span class="hljs-keyword">if</span> (fraction &lt;= <span class="hljs-number">0f</span>) &#123;<br>            <span class="hljs-comment">// 获取第一帧和第二帧</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IntKeyframe</span> <span class="hljs-variable">prevKeyframe</span> <span class="hljs-operator">=</span> (IntKeyframe) mKeyframes.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IntKeyframe</span> <span class="hljs-variable">nextKeyframe</span> <span class="hljs-operator">=</span> (IntKeyframe) mKeyframes.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">prevValue</span> <span class="hljs-operator">=</span> prevKeyframe.getIntValue();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextValue</span> <span class="hljs-operator">=</span> nextKeyframe.getIntValue();<br>            <span class="hljs-type">float</span> <span class="hljs-variable">prevFraction</span> <span class="hljs-operator">=</span> prevKeyframe.getFraction();<br>            <span class="hljs-type">float</span> <span class="hljs-variable">nextFraction</span> <span class="hljs-operator">=</span> nextKeyframe.getFraction();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">TimeInterpolator</span> <span class="hljs-variable">interpolator</span> <span class="hljs-operator">=</span> nextKeyframe.getInterpolator();<br>            <span class="hljs-keyword">if</span> (interpolator != <span class="hljs-literal">null</span>) &#123;<br>                fraction = interpolator.getInterpolation(fraction);<br>            &#125;<br>            <span class="hljs-comment">// 将动画进度转换成第一帧和第二帧之间的进度</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">intervalFraction</span> <span class="hljs-operator">=</span> (fraction - prevFraction) / (nextFraction - prevFraction);<br>            <span class="hljs-keyword">return</span> mEvaluator == <span class="hljs-literal">null</span> ?<br>                    prevValue + (<span class="hljs-type">int</span>)(intervalFraction * (nextValue - prevValue)) :<br>                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).<br>                            intValue();<br>        &#125;<br>        <span class="hljs-comment">// 处理最后一帧</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fraction &gt;= <span class="hljs-number">1f</span>) &#123;<br>            <span class="hljs-comment">// 取出倒数第一帧跟倒数第二帧的信息</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IntKeyframe</span> <span class="hljs-variable">prevKeyframe</span> <span class="hljs-operator">=</span> (IntKeyframe) mKeyframes.get(mNumKeyframes - <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IntKeyframe</span> <span class="hljs-variable">nextKeyframe</span> <span class="hljs-operator">=</span> (IntKeyframe) mKeyframes.get(mNumKeyframes - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">prevValue</span> <span class="hljs-operator">=</span> prevKeyframe.getIntValue();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextValue</span> <span class="hljs-operator">=</span> nextKeyframe.getIntValue();<br>            <span class="hljs-type">float</span> <span class="hljs-variable">prevFraction</span> <span class="hljs-operator">=</span> prevKeyframe.getFraction();<br>            <span class="hljs-type">float</span> <span class="hljs-variable">nextFraction</span> <span class="hljs-operator">=</span> nextKeyframe.getFraction();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">TimeInterpolator</span> <span class="hljs-variable">interpolator</span> <span class="hljs-operator">=</span> nextKeyframe.getInterpolator();<br>            <span class="hljs-keyword">if</span> (interpolator != <span class="hljs-literal">null</span>) &#123;<br>                fraction = interpolator.getInterpolation(fraction);<br>            &#125;<br>            <span class="hljs-comment">// 将进度换算到这两针之间的进度</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">intervalFraction</span> <span class="hljs-operator">=</span> (fraction - prevFraction) / (nextFraction - prevFraction);<br>            <span class="hljs-keyword">return</span> mEvaluator == <span class="hljs-literal">null</span> ?<br>                    prevValue + (<span class="hljs-type">int</span>)(intervalFraction * (nextValue - prevValue)) :<br>                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();<br>        &#125;<br>        <span class="hljs-comment">// 处理中间帧</span><br>        <span class="hljs-type">IntKeyframe</span> <span class="hljs-variable">prevKeyframe</span> <span class="hljs-operator">=</span> (IntKeyframe) mKeyframes.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 遍历每一帧,判断当前的动画进度和这一帧的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; mNumKeyframes; ++i) &#123;<br>            <span class="hljs-type">IntKeyframe</span> <span class="hljs-variable">nextKeyframe</span> <span class="hljs-operator">=</span> (IntKeyframe) mKeyframes.get(i);<br>            <span class="hljs-keyword">if</span> (fraction &lt; nextKeyframe.getFraction()) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">TimeInterpolator</span> <span class="hljs-variable">interpolator</span> <span class="hljs-operator">=</span> nextKeyframe.getInterpolator();<br>                <span class="hljs-type">float</span> <span class="hljs-variable">intervalFraction</span> <span class="hljs-operator">=</span> (fraction - prevKeyframe.getFraction()) /<br>                    (nextKeyframe.getFraction() - prevKeyframe.getFraction());<br>                <span class="hljs-type">int</span> <span class="hljs-variable">prevValue</span> <span class="hljs-operator">=</span> prevKeyframe.getIntValue();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextValue</span> <span class="hljs-operator">=</span> nextKeyframe.getIntValue();<br>                <span class="hljs-comment">// Apply interpolator on the proportional duration.</span><br>                <span class="hljs-keyword">if</span> (interpolator != <span class="hljs-literal">null</span>) &#123;<br>                    intervalFraction = interpolator.getInterpolation(intervalFraction);<br>                &#125;<br>                <span class="hljs-keyword">return</span> mEvaluator == <span class="hljs-literal">null</span> ?<br>                        prevValue + (<span class="hljs-type">int</span>)(intervalFraction * (nextValue - prevValue)) :<br>                        ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).<br>                                intValue();<br>            &#125;<br>            prevKeyframe = nextKeyframe;<br>        &#125;<br>        <span class="hljs-comment">// shouldn&#x27;t get here</span><br>        <span class="hljs-keyword">return</span> ((Number)mKeyframes.get(mNumKeyframes - <span class="hljs-number">1</span>).getValue()).intValue();<br>    &#125;<br></code></pre></td></tr></table></figure><p>  当关键帧只有两帧时，比如 <code>ValueAnimator.ofInt(100)</code>， 内部其实就是只创建了两个关键帧，一个是起点 0，一个是结束点 100。那么，在这种只有两帧的情况下，将 0-1 的动画进度值转换成我们需要的 0-100 区间内的值，系统的处理很简单，如果没有设置估值器，那么就直接是按比例来转换，比如进度为 0.5，那按比例转换就是 (100 - 0) * 0.5 &#x3D; 50。</p><p>  在处理第一帧的工作时，只需要将第二帧当成是最后一帧，那么第一帧和第二帧这样也就可以看成是只有两帧的场景了吧。但是参数 fraction 动画进度是以实际第一帧到最后一帧计算出来的，所以需要先对它进行转换，换算出它在第一帧到第二帧之间的进度，接下去的逻辑也就跟处理两帧时的逻辑是一样的了。同理, 在处理最后一帧时，只需要取出倒数第一帧跟倒数第二帧的信息，然后将进度换算到这两针之间的进度。</p><p>  处理中间帧比较复杂,系统从第一帧开始，按顺序遍历每一帧，然后去判断当前的动画进度跟这一帧保存的位置信息来找出当前进度是否就是落在某两个关键帧之间。然后按照两帧的情况处理</p><p>  小结:</p><ul><li>当接收到屏幕刷新信号后，AnimationHandler 会去遍历列表，将所有待执行的属性动画都取出来去计算当前帧的动画行为。</li><li>每个动画在处理当前帧的动画逻辑时，首先会先根据当前时间和动画第一帧时间以及动画的持续时长来初步计算出当前帧时动画所处的进度，然后会将这个进度值等价转换到 0-1 区间之内。</li><li>接着，插值器会将这个经过初步计算之后的进度值根据设定的规则计算出实际的动画进度值，取值也是在 0-1 区间内。</li><li>计算出当前帧动画的实际进度之后，会将这个进度值交给关键帧机制，来换算出我们需要的值，比如 ValueAnimator.ofInt(0, 100) 表示我们需要的值变化范围是从 0-100，那么插值器计算出的进度值是 0-1 之间的，接下去就需要借助关键帧机制来映射到 0-100 之间。</li><li>关键帧的数量是由 ValueAnimator.ofInt(0, 1, 2, 3) 参数的数量来决定的，比如这个就有四个关键帧，第一帧和最后一帧是必须的，所以最少会有两个关键帧，如果参数只有一个，那么第一帧默认为 0，最后一帧就是参数的值。当调用了这个 ofInt() 方法时，关键帧组也就被创建了。</li><li>当只有两个关键帧时，映射的规则是，如果没有设置估值器，那么就等比例映射，比如动画进度为 0.5，需要的值变化区间是 0-100，那么等比例映射后的值就是 50，那么我们在 onAnimationUpdate 的回调中通过 animation.getAnimatedValue() 获取到的值 50 就是这么来的。</li><li>当关键帧超过两个时，需要先找到当前动画进度是落于哪两个关键帧之间，然后将这个进度值先映射到这两个关键帧之间的取值，接着就可以将这两个关键帧看成是第一帧和最后一帧，那么就可以按照只有两个关键帧的情况下的映射规则来进行计算了。</li><li>而进度值映射到两个关键帧之间的取值，这就需要知道每个关键帧在整个关键帧组中的位置信息，或者说权重。而这个位置信息是在创建每个关键帧时就传进来的。onInt() 的规则是所有关键帧按等比例来分配权重。</li></ul><p>到这里我们就分析完<code>ValueAnimator</code>了</p><p>我们再来看一下ValueAnimator的时序图</p><p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/A6eql3FxIhgyS8H.png" alt="ValueAnimator原理时序图"></p><p><a href="https://www.processon.com/view/link/62e1d8d6f346fb0760d091d5">ValueAnimation时序图 -查看大图</a></p><h4 id="ObjectAnimator源码解读"><a href="#ObjectAnimator源码解读" class="headerlink" title="ObjectAnimator源码解读"></a>ObjectAnimator源码解读</h4><p>  我们先从<code>ObjectAnimator.ofInt()</code>开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ObjectAnimator</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ObjectAnimator <span class="hljs-title function_">ofInt</span><span class="hljs-params">(Object target, String propertyName, <span class="hljs-type">int</span>... values)</span> &#123;<br>        <span class="hljs-comment">// 创建ObjectAnimator对象,设置属性动画的目标target和作用于target的属性名propertyName</span><br>        <span class="hljs-type">ObjectAnimator</span> <span class="hljs-variable">anim</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectAnimator</span>(target, propertyName);<br>        anim.setIntValues(values);<br>        <span class="hljs-keyword">return</span> anim;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  看一下<code>ObjectAnimator</code>的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ObjectAnimator</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ObjectAnimator</span><span class="hljs-params">(Object target, String propertyName)</span> &#123;<br>        <span class="hljs-comment">// 设置目标View</span><br>        setTarget(target);<br>        <span class="hljs-comment">// 设置属性名称</span><br>        setPropertyName(propertyName);<br>    &#125;<br><br><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTarget</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object target)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">oldTarget</span> <span class="hljs-operator">=</span> getTarget();<br>        <span class="hljs-comment">// 当oldTarget不等于target，且已经调用了start()方法使得mStarted标志位为true时,先取消掉动画</span><br>        <span class="hljs-keyword">if</span> (oldTarget != target) &#123;<br>            <span class="hljs-keyword">if</span> (isStarted()) &#123;<br>                cancel();<br>            &#125;<br>            <span class="hljs-comment">// 这是一个软引用,这样ObjectAnimator就不会持有View的引用，不会影响Activity的正常回收，从而不会引起Activity内存泄漏。</span><br>            mTarget = target == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;Object&gt;(target);<br>            <span class="hljs-comment">// 记录未初始化,ValueAnimator的初始化标志位</span><br>            mInitialized = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPropertyName</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String propertyName)</span> &#123;<br>        <span class="hljs-comment">// mValues是一个数组，用于保存PropertyValuesHolder</span><br>        <span class="hljs-keyword">if</span> (mValues != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">PropertyValuesHolder</span> <span class="hljs-variable">valuesHolder</span> <span class="hljs-operator">=</span> mValues[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">String</span> <span class="hljs-variable">oldName</span> <span class="hljs-operator">=</span> valuesHolder.getPropertyName();<br>            <span class="hljs-comment">// 更新第一个PropertyValuesHolder的PropertyName</span><br>            valuesHolder.setPropertyName(propertyName);<br>            <span class="hljs-comment">// mValues和mValuesMap都是存储PropertyValueHolder的属性</span><br>            mValuesMap.remove(oldName);<br>            mValuesMap.put(propertyName, valuesHolder);<br>        &#125;<br>        mPropertyName = propertyName;<br>        <span class="hljs-comment">// 记录尚未初始化,ValueAnimator的标志位</span><br>        mInitialized = <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>回到<code>ObjectAnimator.OfInt()</code>方法,查看<code>ObjectAnimator.setIntValues()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ObjectAnimator</span><br> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIntValues</span><span class="hljs-params">(<span class="hljs-type">int</span>... values)</span> &#123;<br>        <span class="hljs-comment">// 第一次调用时，values为null</span><br>        <span class="hljs-keyword">if</span> (mValues == <span class="hljs-literal">null</span> || mValues.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 我们设置了mPropertyName，在这里mProperty为null</span><br>            <span class="hljs-keyword">if</span> (mProperty != <span class="hljs-literal">null</span>) &#123;<br>                setValues(PropertyValuesHolder.ofInt(mProperty, values));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                setValues(PropertyValuesHolder.ofInt(mPropertyName, values));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">super</span>.setIntValues(values);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  进入<code>PropertyValuesHolder.ofInt(mPropertyName, values)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PropertyValuesHolder</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PropertyValuesHolder <span class="hljs-title function_">ofInt</span><span class="hljs-params">(String propertyName, <span class="hljs-type">int</span>... values)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntPropertyValuesHolder</span>(propertyName, values);<br>    &#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">IntPropertyValuesHolder</span><span class="hljs-params">(String propertyName, <span class="hljs-type">int</span>... values)</span> &#123;<br>            <span class="hljs-built_in">super</span>(propertyName);<br>            <span class="hljs-comment">// 调用IntPropertyValuesHolder.setIntValues方法</span><br>            setIntValues(values);<br>        &#125;<br><br><span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIntValues</span><span class="hljs-params">(<span class="hljs-type">int</span>... values)</span> &#123;<br>            <span class="hljs-comment">// 调用PropertyValuesHolder.setIntValues方法</span><br>            <span class="hljs-built_in">super</span>.setIntValues(values);<br>            mIntKeyframes = (Keyframes.IntKeyframes) mKeyframes;<br>        &#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIntValues</span><span class="hljs-params">(<span class="hljs-type">int</span>... values)</span> &#123;<br>        <span class="hljs-comment">// 记录mValueType值，便于使用反射方式遍历获取目标target对应的set和get方法</span><br>        mValueType = <span class="hljs-type">int</span>.class;<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>ObjectAnimator.ofFloat</code>的过程就结束了，</p><p>小结:</p><p>  ofInt()会创建<code>ObjecctAnimator</code>对象,并设置动画目标target和属性名propertyName,然后调用<code>PropertyValuesHolder.ofInt()</code>进行初始化</p><p>下面我们来看ObjectAnimator 的 <code>start()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ObjectAnimator</span><br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 取消当前的动画</span><br>        AnimationHandler.getInstance().autoCancelBasedOn(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (DBG) &#123;<br>            Log.d(LOG_TAG, <span class="hljs-string">&quot;Anim target, duration: &quot;</span> + getTarget() + <span class="hljs-string">&quot;, &quot;</span> + getDuration());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mValues.length; ++i) &#123;<br>                <span class="hljs-type">PropertyValuesHolder</span> <span class="hljs-variable">pvh</span> <span class="hljs-operator">=</span> mValues[i];<br>                Log.d(LOG_TAG, <span class="hljs-string">&quot;   Values[&quot;</span> + i + <span class="hljs-string">&quot;]: &quot;</span> +<br>                    pvh.getPropertyName() + <span class="hljs-string">&quot;, &quot;</span> + pvh.mKeyframes.getValue(<span class="hljs-number">0</span>) + <span class="hljs-string">&quot;, &quot;</span> +<br>                    pvh.mKeyframes.getValue(<span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 调用了ValueAnimator的start()</span><br>        <span class="hljs-built_in">super</span>.start();<br>    &#125;<br></code></pre></td></tr></table></figure><p>  我们跟进<code>ValueAnimator.start()</code>-&gt;<code>ValueAnimator.setCurrent()</code>-&gt;<code>initAnimator</code></p><p>我们先看看<code>ObjectAnimator.initAnimation()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ObjectAnimator</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">initAnimation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 第一次执行时，mInitialized为false,初始化后该标志位置为true</span><br>        <span class="hljs-keyword">if</span> (!mInitialized) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> getTarget();<br>            <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">numValues</span> <span class="hljs-operator">=</span> mValues.length;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numValues; ++i) &#123;<br>                    <span class="hljs-comment">// 执行PropertyValuesHolder的setupSetterAndGetter()方法</span><br>                    mValues[i].setupSetterAndGetter(target);<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">super</span>.initAnimation();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p> 分析<code>PropertyValuesHolder.setupSetterAndGetter()</code>,主要是初始化反射方法mSetter和mGetter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PropertyValuesHolder</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setupSetterAndGetter</span><span class="hljs-params">(Object target)</span> &#123;<br>     <span class="hljs-comment">// 如果我们设置了mPropertyName,mProperty为null</span><br>        <span class="hljs-keyword">if</span> (mProperty != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">testValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                List&lt;Keyframe&gt; keyframes = mKeyframes.getKeyframes();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">keyframeCount</span> <span class="hljs-operator">=</span> keyframes == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : keyframes.size();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; keyframeCount; i++) &#123;<br>                    <span class="hljs-type">Keyframe</span> <span class="hljs-variable">kf</span> <span class="hljs-operator">=</span> keyframes.get(i);<br>                    <span class="hljs-keyword">if</span> (!kf.hasValue() || kf.valueWasSetOnStart()) &#123;<br>                        <span class="hljs-keyword">if</span> (testValue == <span class="hljs-literal">null</span>) &#123;<br>                            testValue = convertBack(mProperty.get(target));<br>                        &#125;<br>                        kf.setValue(testValue);<br>                        kf.setValueWasSetOnStart(<span class="hljs-literal">true</span>);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassCastException e) &#123;<br>                Log.w(<span class="hljs-string">&quot;PropertyValuesHolder&quot;</span>,<span class="hljs-string">&quot;No such property (&quot;</span> + mProperty.getName() +<br>                        <span class="hljs-string">&quot;) on target object &quot;</span> + target + <span class="hljs-string">&quot;. Trying reflection instead&quot;</span>);<br>                mProperty = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// We can&#x27;t just say &#x27;else&#x27; here because the catch statement sets mProperty to null.</span><br>         <span class="hljs-comment">// mProperty为空，判断get和set方法是否存在</span><br>        <span class="hljs-keyword">if</span> (mProperty == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">targetClass</span> <span class="hljs-operator">=</span> target.getClass();<br>            <span class="hljs-keyword">if</span> (mSetter == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 查找目标属性的set方法，初始化mSetter方法</span><br>                setupSetter(targetClass);<br>            &#125;<br>            List&lt;Keyframe&gt; keyframes = mKeyframes.getKeyframes();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">keyframeCount</span> <span class="hljs-operator">=</span> keyframes == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : keyframes.size();<br>            <span class="hljs-comment">// 遍历关键帧集合</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; keyframeCount; i++) &#123;<br>                <span class="hljs-type">Keyframe</span> <span class="hljs-variable">kf</span> <span class="hljs-operator">=</span> keyframes.get(i);<br>                <span class="hljs-keyword">if</span> (!kf.hasValue() || kf.valueWasSetOnStart()) &#123;<br>                    <span class="hljs-keyword">if</span> (mGetter == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">// 查找目标属性的get方法，初始化mGetter方法</span><br>                        setupGetter(targetClass);<br>                        <span class="hljs-comment">// mGetter为null时，直接return</span><br>                        <span class="hljs-keyword">if</span> (mGetter == <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-comment">// Already logged the error - just return to avoid NPE</span><br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 通过mGetter反射获取属性值</span><br>                        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> convertBack(mGetter.invoke(target));<br>                        <span class="hljs-comment">// 初始化关键帧Keyframe的mValue值</span><br>                        kf.setValue(value);<br>                        <span class="hljs-comment">// 设置Keyframe标志位为true，表示已经初始化mValue</span><br>                        kf.setValueWasSetOnStart(<span class="hljs-literal">true</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>                        Log.e(<span class="hljs-string">&quot;PropertyValuesHolder&quot;</span>, e.toString());<br>                    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                        Log.e(<span class="hljs-string">&quot;PropertyValuesHolder&quot;</span>, e.toString());<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>  setupSetter</code>和<code>setupGetter</code>方法都调用了<code>setupSetterOrGetter()</code>接着分析<code>setupSetterOrGetter()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PropertyValuesHolder</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setupSetter</span><span class="hljs-params">(Class targetClass)</span> &#123;<br>        Class&lt;?&gt; propertyType = mConverter == <span class="hljs-literal">null</span> ? mValueType : mConverter.getTargetType();<br>        mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, <span class="hljs-string">&quot;set&quot;</span>, propertyType);<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setupGetter</span><span class="hljs-params">(Class targetClass)</span> &#123;<br>        mGetter = setupSetterOrGetter(targetClass, sGetterPropertyMap, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-literal">null</span>);<br>    &#125;<br><br><br><br><span class="hljs-comment">// 参数prefix值为“set”或者“get”,在这里valueType为int.class</span><br>    <span class="hljs-keyword">private</span> Method <span class="hljs-title function_">setupSetterOrGetter</span><span class="hljs-params">(Class targetClass,</span><br><span class="hljs-params">            HashMap&lt;Class, HashMap&lt;String, Method&gt;&gt; propertyMapMap,</span><br><span class="hljs-params">            String prefix, Class valueType)</span> &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">setterOrGetter</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 进行同步判断</span><br>        <span class="hljs-keyword">synchronized</span>(propertyMapMap) &#123;<br>            <span class="hljs-comment">// 根据targetClass获取HashMap，这个propertyMap是以mPropertyName为key，set或者get方法作为value</span><br>            HashMap&lt;String, Method&gt; propertyMap = propertyMapMap.get(targetClass);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">wasInMap</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (propertyMap != <span class="hljs-literal">null</span>) &#123;<br>                wasInMap = propertyMap.containsKey(mPropertyName);<br>                <span class="hljs-keyword">if</span> (wasInMap) &#123;<br>                    setterOrGetter = propertyMap.get(mPropertyName);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 第一次初始化，wasInMap为false</span><br>            <span class="hljs-keyword">if</span> (!wasInMap) &#123;<br>                <span class="hljs-comment">// 初始化setterOrGetter</span><br>                setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);<br>                <span class="hljs-keyword">if</span> (propertyMap == <span class="hljs-literal">null</span>) &#123;<br>                    propertyMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Method&gt;();<br>                    propertyMapMap.put(targetClass, propertyMap);<br>                &#125;<br>                propertyMap.put(mPropertyName, setterOrGetter);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> setterOrGetter;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在<code>setupSetterOrGetter</code>方法中调用到了<code>getPropertyFunction</code>函数来初始化mSetter或者mGetter参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PropertyValuesHolder</span><br><span class="hljs-keyword">private</span> Method <span class="hljs-title function_">getPropertyFunction</span><span class="hljs-params">(Class targetClass, String prefix, Class valueType)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> faster implementation...</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">returnVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 通过prefix和mPropertyName拼接出方法名，如setAlpha或者getAlpha</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> getMethodName(prefix, mPropertyName);<br>        Class args[] = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (valueType == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                returnVal = targetClass.getMethod(methodName, args);<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>                <span class="hljs-comment">// Swallow the error, log it later</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">1</span>];<br>            Class typeVariants[];<br>            <span class="hljs-keyword">if</span> (valueType.equals(Float.class)) &#123;<br>                typeVariants = FLOAT_VARIANTS;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueType.equals(Integer.class)) &#123;<br>                typeVariants = INTEGER_VARIANTS;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueType.equals(Double.class)) &#123;<br>                typeVariants = DOUBLE_VARIANTS;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                typeVariants = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">1</span>];<br>                typeVariants[<span class="hljs-number">0</span>] = valueType;<br>            &#125;<br>            <span class="hljs-comment">// FLOAT_VARIANTS,遍历含有float.class、Float.class、double.class、Double.class等参数的方法</span><br>            <span class="hljs-comment">// 只要是相关的基本类型，都会遍历反射查找set或者get方法</span><br>            <span class="hljs-keyword">for</span> (Class typeVariant : typeVariants) &#123;<br>                args[<span class="hljs-number">0</span>] = typeVariant;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 反射获取方法，成功则直接返回</span><br>                    returnVal = targetClass.getMethod(methodName, args);<br>                    <span class="hljs-keyword">if</span> (mConverter == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">// change the value type to suit</span><br>                        mValueType = typeVariant;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> returnVal;<br>                &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>                    <span class="hljs-comment">// Swallow the error and keep trying other variants</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// If we got here, then no appropriate function was found</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (returnVal == <span class="hljs-literal">null</span>) &#123;<br>            Log.w(<span class="hljs-string">&quot;PropertyValuesHolder&quot;</span>, <span class="hljs-string">&quot;Method &quot;</span> +<br>                    getMethodName(prefix, mPropertyName) + <span class="hljs-string">&quot;() with type &quot;</span> + valueType +<br>                    <span class="hljs-string">&quot; not found on target class &quot;</span> + targetClass);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> returnVal;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  到这里ObjectAnimator的<code>initAnimation()</code>方法已经完成,接下来我们回到<code>ValueAnimator.setCurrentFraction(float fraction)</code>方法，最后调用了<code>ObjectAnimator.animateValue(float fraction)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ObjectAnimator</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">animateValue</span><span class="hljs-params">(<span class="hljs-type">float</span> fraction)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> getTarget();<br>        <span class="hljs-comment">// mTarget是一个软引用，判断target是否已经被回收</span><br>        <span class="hljs-keyword">if</span> (mTarget != <span class="hljs-literal">null</span> &amp;&amp; target == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// We lost the target reference, cancel and clean up. Note: we allow null target if the</span><br>            <span class="hljs-comment">/// target has never been set.</span><br>            cancel();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 这里调用父类ValueAnimator的animateValue来计算数值</span><br>        <span class="hljs-built_in">super</span>.animateValue(fraction);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numValues</span> <span class="hljs-operator">=</span> mValues.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numValues; ++i) &#123;<br>            <span class="hljs-comment">// 反射修改每一个属性值，这里修改完这一轮动画就结束了</span><br>            mValues[i].setAnimatedValue(target);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>  我们看看<code>PropertyValuesHolder.setAnimatedValue()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// IntPropertyValuesHolder</span><br><span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAnimatedValue</span><span class="hljs-params">(Object target)</span> &#123;<br>            <span class="hljs-comment">// 我们传进来的是mPropertyName</span><br>            <span class="hljs-keyword">if</span> (mIntProperty != <span class="hljs-literal">null</span>) &#123;<br>                mIntProperty.setValue(target, mIntAnimatedValue);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mProperty != <span class="hljs-literal">null</span>) &#123;<br>                mProperty.set(target, mIntAnimatedValue);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mJniSetter != <span class="hljs-number">0</span>) &#123;<br>                nCallIntMethod(target, mJniSetter, mIntAnimatedValue);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 终于到了，反射修改属性值就在这里执行的</span><br>            <span class="hljs-keyword">if</span> (mSetter != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    mTmpValueArray[<span class="hljs-number">0</span>] = mIntAnimatedValue;<br>                    mSetter.invoke(target, mTmpValueArray);<br>                &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>                    Log.e(<span class="hljs-string">&quot;PropertyValuesHolder&quot;</span>, e.toString());<br>                &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                    Log.e(<span class="hljs-string">&quot;PropertyValuesHolder&quot;</span>, e.toString());<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>  到这里我们把<code>setCurrentPlayTime()</code>分析完,<code>ObjectAnimator</code>也就分析完了,其他的细节和<code>ValueAnimator</code>一样.</p><h2 id="转场动画"><a href="#转场动画" class="headerlink" title="转场动画"></a>转场动画</h2><p>  看完了属性动画后,我们再来看看转场动画</p><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>在 Android 5.0 之后，我们可以使用 Transition 为我们带来的转场动画。</p><table><thead><tr><th align="left">Explode</th><th align="left">Slide</th><th align="left">Fade</th></tr></thead><tbody><tr><td align="left">从中心移入或移出</td><td align="left">从边缘移入或移出</td><td align="left">调整透明度产生渐变</td></tr><tr><td align="left"><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/Transition-Explode.gif" alt="Transition-Explode" style="zoom: 33%;" /></td><td align="left"><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/Transition-Slide.gif" alt="Transition-Slide" style="zoom: 33%;" /></td><td align="left"><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/Transition-Fade.gif" alt="Transition-Fade" style="zoom: 33%;" /></td></tr></tbody></table><p>这三个类都继承于 Transition ，所有有一些属性都是共同的。 常用属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置动画的时间。</span><br>transition.setDuration();<br><span class="hljs-comment">// 设置插值器</span><br>transition.setInterpolator();<br><span class="hljs-comment">// 设置动画开始时间，延迟n毫秒播放。</span><br>transition.setStartDelay();<br><span class="hljs-comment">// 设置动画的运行路径</span><br>transition.setPathMotion();<br><span class="hljs-comment">// 改变动画 出现/消失 的模式。Visibility.MODE_IN:进入；Visibility.MODE_OUT：退出。</span><br>transition.setMode();<br><span class="hljs-comment">// 设置动画的监听事件</span><br>transition.addListener()<br></code></pre></td></tr></table></figure><p>插值器,与前面一致,<a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8F%92%E5%80%BC%E5%99%A8">常见的插值器</a></p><h4 id="Transition的时机"><a href="#Transition的时机" class="headerlink" title="Transition的时机"></a>Transition的时机</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//总共有四个过程</span><br><span class="hljs-comment">//退出 -&gt; 进入  -&gt; 返回   -&gt; 重新进入</span><br><span class="hljs-comment">//Exit -&gt; Enter -&gt; Return -&gt; Reenter</span><br><span class="hljs-comment">//界面1</span><br>android:windowExitTransition      <span class="hljs-comment">//启动新 Activity ，此页面退出的动画</span><br>android:windowReenterTransition   <span class="hljs-comment">//重新进入的动画。即第二次进入，可以和首次进入不一样。</span><br><span class="hljs-comment">//界面2</span><br>android:windowEnterTransition     <span class="hljs-comment">//首次进入显示的动画</span><br>android:windowReturnTransition    <span class="hljs-comment">//finishAfterTransition()退出时，此页面退出的动画.</span><br></code></pre></td></tr></table></figure><ul><li>首先打开页面A ：页面A -&gt; Enter 首次进入</li><li>从 A 打开 B ：页面A -&gt; Exit 退出 页面B -&gt; Enter 首次进入</li><li>从 B 返回 A ：页面B -&gt; Return 返回 页面A -&gt; Reenter 重新进入</li></ul><table><thead><tr><th align="left">方法</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">windowContentTransitions</td><td align="left">允许使用transitions</td></tr><tr><td align="left">windowAllowEnterTransitionOverlap</td><td align="left">是否覆盖执行，其实可以理解成前后两个页面是同步执行还是顺序执行</td></tr><tr><td align="left">windowAllowReturnTransitionOverlap</td><td align="left">与上面相同。即上一个设置了退出动画，这个设置了进入动画，两者是否同时执行。</td></tr><tr><td align="left">windowContentTransitionManager</td><td align="left">引用TransitionManager XML资源，定义不同窗口内容之间的所需转换。</td></tr><tr><td align="left">windowEnterTransition</td><td align="left">首次进入显示的动画</td></tr><tr><td align="left">windowExitTransition</td><td align="left">启动新 Activity ，此页面退出的动画</td></tr><tr><td align="left">windowReenterTransition</td><td align="left">重新进入的动画。即第二次进入，可以和首次进入不一样。</td></tr><tr><td align="left">windowReturnTransition</td><td align="left">调用 finishAfterTransition() 退出时，此页面退出的动画</td></tr><tr><td align="left">windowSharedElementsUseOverlay</td><td align="left">指示共享元素在转换期间是否应使用叠加层。</td></tr><tr><td align="left">windowSharedElementEnterTransition</td><td align="left">首次进入显示的动画</td></tr><tr><td align="left">windowSharedElementExitTransition</td><td align="left">启动新 Activity ，此页面退出的动画</td></tr><tr><td align="left">windowSharedElementReenterTransition</td><td align="left">重新进入的动画。即第二次进入，可以和首次进入不一样。</td></tr><tr><td align="left">windowSharedElementReturnTransition</td><td align="left">调用 finishAfterTransition() 退出时，此页面退出的动画</td></tr></tbody></table><h4 id="跳转页面"><a href="#跳转页面" class="headerlink" title="跳转页面"></a>跳转页面</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//页面1 (Activity默认了一个从右到左的Slide动画)</span><br><span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, MainActivity2::<span class="hljs-keyword">class</span>.java)<br>        startActivity(intent)<br><br><span class="hljs-comment">//页面2可以什么也不写</span><br><span class="hljs-comment">// 如果定义了 return transition ，将使用定义的动画过渡</span><br>        window.returnTransition = Fade()<br><span class="hljs-comment">// 如果没有定义returnTransition，将使用 反转进入 的动画</span><br>    finishAfterTransition();<br></code></pre></td></tr></table></figure><p><strong>Shared Elements Transition 共享元素</strong></p><p>携带需要共享的 View 进行跳转, 也就是在跳转的参数中，增加了要共享的 View控件。</p><ol><li><p>先在 layout 布局里面给需要共享的元素加上transitionName：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:transitionName=&quot;image&quot;<br></code></pre></td></tr></table></figure></li><li><p>然后开始设置跳转页面，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, MainActivity2::<span class="hljs-keyword">class</span>.java)<br>        <span class="hljs-keyword">val</span> transitionActivityOptions =<br>            ActivityOptionsCompat.makeSceneTransitionAnimation(<span class="hljs-keyword">this</span>, Pair(textView, <span class="hljs-string">&quot;translation1&quot;</span>))<br>        startActivity(intent, transitionActivityOptions.toBundle())<br></code></pre></td></tr></table></figure></li></ol><p>和普通Transition区别是增加了<code>Pair.create()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair.create（<br>   View view,      <span class="hljs-comment">// 本页面要共享的 View</span><br>   String resId    <span class="hljs-comment">// 设置的transitionName</span><br>）<br></code></pre></td></tr></table></figure><p>效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/Activity-%E5%85%B1%E4%BA%AB%E5%85%83%E7%B4%A0.gif" alt="Activity-共享元素" style="zoom: 50%;" /><p>  fragment与fragment之间地动画</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//在fragment1中</span><br><span class="hljs-keyword">val</span> fragment2 = Fragment2()<br>            <span class="hljs-keyword">this</span>.exitTransition = Explode()<br>            fragment2.enterTransition = Slide()<br>            requireActivity().supportFragmentManager.beginTransaction()<br>                .addSharedElement(textView, <span class="hljs-string">&quot;translation2&quot;</span>)<br>                .replace(R.id.constraintLayout3, fragment2).addToBackStack(<span class="hljs-literal">null</span>).commit()<br><br><span class="hljs-comment">//在fragment2中</span><br>sharedElementEnterTransition = TransitionInflater.from(getContext())<br>            .inflateTransition(android.R.transition.move);<br></code></pre></td></tr></table></figure><p>  可以设置一些界面切换的效果,和Transition用法一致</p><p>效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/wE2KrFdqeT8z4BO.gif" alt="fragment-共享元素" style="zoom: 50%;" /><p>  注意:有时从<code>RecyclerView</code>界面进入到详情页，由于详情页加载延迟，可能出现没有效果。例如<code>ImageView</code>从网络加载图片，可能A界面到B界面没效果，B回到A界面有效果。</p><p>例如:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/Shared_Transition_no_Postpone.gif" alt="Shared_Transition_no_Postpone" style="zoom: 50%;" /><p>  解决步骤：</p><ul><li><p>在<code>setContentView</code>后添加代码<code>postponeEnterTransition()</code>，延迟加载过渡动画。</p></li><li><p>在共享元素视图加载完毕，或者图片加载完毕后调用代码<code>startPostponedEnterTransition()</code>,开始加载过渡动画。</p></li></ul><p>效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/Shared_transition_no_exit_retreen.gif" alt="Shared_transition_no_exit_retreen" style="zoom: 50%;" /><p>当Activity A 调用 Activity B ，发生的事件流如下：</p><p>1）Activity A调用startActivity()，ActivityB被创建，测量，同时初始化为半透明的窗口和透明的背景颜色。</p><p>2）framework重新分配每个共享元素在B中的位置与大小，使其跟A中一模一样。之后，B的进入变换（enter transition）捕获到共享元素在B中的初始状态。</p><p>3）framework重新分配每个共享元素在B中的位置与大小，使其跟B中的最终状态一致。之后，B的进入变换（enter transition）捕获到共享元素在B中的结束状态。</p><p>4）B的进入变换（enter transition）比较共享元素的初始和结束状态，同时基于前后状态的区别创建一个Animator(属性动画对象)。</p><p>5）framework 命令A隐藏其共享元素，动画开始运行。随着动画的进行，framework 逐渐将B的activity窗口显示出来，当动画完成，B的窗口才完全可见。</p><h4 id="TransitionManager-控制动画"><a href="#TransitionManager-控制动画" class="headerlink" title="TransitionManager 控制动画"></a>TransitionManager 控制动画</h4><p>  Activity切换过渡动画指在两个Activity之间，而布局变化过渡动画，是指同个Activity之间View的变化过渡动画。</p><p>  具体步骤: 需要我们自己创建起始和结束场景，利用现有的过渡效果来达到两个场景的切换 (起始场景和结束场景需要用相同根元素) 。默认情况下，当前界面就是起始场景。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第一步创建scene2--&gt;</span><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/constraintLayout2&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity2&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textView2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Red_Rock&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/purple_200&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;60dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textStyle</span>=<span class="hljs-string">&quot;bold&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:transitionName</span>=<span class="hljs-string">&quot;translation1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/ball3&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;50dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;50dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;128dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/purple_200&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/drawable&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/ball4&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;50dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;50dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/teal_200&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/drawable&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">&quot;@+id/ball3&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/ball5&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;50dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;50dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/black&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/drawable&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">&quot;@+id/ball4&quot;</span> /&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button11&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;8dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;旋转&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toStartOf</span>=<span class="hljs-string">&quot;@+id/button12&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button12&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;8dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;平移&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toStartOf</span>=<span class="hljs-string">&quot;@+id/button14&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@+id/button11&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button13&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;8dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;缩放&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@+id/button14&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button14&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;8dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;透明&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toStartOf</span>=<span class="hljs-string">&quot;@+id/button13&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@+id/button12&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 第二步调用 Scene.getSceneForLayout() 保存每个Layout；</span><br><span class="hljs-keyword">val</span> scene = Scene.getSceneForLayout(constraintLayout, R.xml.scene2, <span class="hljs-keyword">this</span>)<br><span class="hljs-comment">// 第三步调用 TransitionManager.go(scene1, new ChangeBounds()) 切换。</span><br><span class="hljs-comment">// 参数1表示结束场景, 参数2表示过渡效果</span><br>TransitionManager.go(scene, ChangeBounds())<br></code></pre></td></tr></table></figure><p>效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/TransitionManager-%E5%8A%A8%E7%94%BB.gif" alt="TransitionManager-动画" style="zoom: 50%;" /><p><strong>过渡动画</strong></p><p>  系统支持将任何扩展Visibility类的过渡作为进入或退出过渡，内置继承自Visibility的类有<code>Explode</code>、<code>Slide</code>、<code>Fade</code>；支持共享元素过渡的有： </p><ul><li>changeScroll 为目标视图滑动添加动画效果</li><li>changeBounds 为目标视图布局边界的变化添加动画效果</li><li>changeClipBounds 为目标视图裁剪边界的变化添加动画效果</li><li>changeTransform  为目标视图缩放和旋转方面的变化添加动画效果</li><li>changeImageTransform  为目标图片尺寸和缩放方面的变化添加动画效果</li></ul><p> 默认转场动画会对所有的子View进行遍历加载动画, 但是如果<strong>添加目标</strong>则不会进行遍历所有子View, 或者也可以排除特定View.</p><p>对于目标有三个操作:</p><ul><li><p>添加(<code>addTarget</code>):默认会进行遍历所有的视图加载动画, 但是如果使用了添加就不会遍历所有, 只会让指定的视图进行动画</p></li><li><p>排除(<code>excludeTarget()</code>):如果使用排除方法, 依旧会进行遍历视图对象, 不过会排除你指定的视图</p></li><li><p>删除(<code>removeTarget()</code>):删除目标是在动画已经遍历视图完成以后还想对目标集合进行变更, 就可以删除指定的视图</p><p>添加&#x2F;排除和删除目标支持的参数类型: <code>视图对象(View)</code>,<code>过渡名(TransitionNames)</code>,<code>字节码(Class)</code>,<code>ID</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 视图动画</span><br>Transition <span class="hljs-title function_">addTarget</span> <span class="hljs-params">(View target)</span><br><span class="hljs-comment">// 过渡名</span><br>Transition <span class="hljs-title function_">addTarget</span> <span class="hljs-params">(String targetName)</span><br><span class="hljs-comment">// 字节码</span><br>Transition <span class="hljs-title function_">addTarget</span> <span class="hljs-params">(Class targetType)</span><br><span class="hljs-comment">// Id</span><br>Transition <span class="hljs-title function_">addTarget</span> <span class="hljs-params">(<span class="hljs-type">int</span> targetId)</span><br></code></pre></td></tr></table></figure><h4 id="自定义Translation"><a href="#自定义Translation" class="headerlink" title="自定义Translation"></a>自定义Translation</h4><p>  当现有的过渡效果不满足日常需求时，可以通过继承<code>Transition</code>，定制自己的动画特效。</p><p>子类继承<code>Transition</code>类，并重写其三个方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTransition</span> : <span class="hljs-type">Transition</span>() &#123;<br>   <span class="hljs-comment">// 捕获动画的起始值</span><br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">captureStartValues</span><span class="hljs-params">(transitionValues: <span class="hljs-type">TransitionValues</span>?)</span></span> &#123;&#125;<br>   <span class="hljs-comment">// 捕获动画的结束值</span><br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">captureEndValues</span><span class="hljs-params">(transitionValues: <span class="hljs-type">TransitionValues</span>?)</span></span> &#123;&#125;<br><br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createAnimator</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">       sceneRoot: <span class="hljs-type">ViewGroup</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">       startValues: <span class="hljs-type">TransitionValues</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">       endValues: <span class="hljs-type">TransitionValues</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">   )</span></span>: Animator &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.createAnimator(sceneRoot, startValues, endValues)<br>   &#125;<br>   <br>&#125;<br><br><span class="hljs-comment">// 来看看TransitionValues这个类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransitionValues</span> &#123;<br>    <span class="hljs-comment">// 捕获的View</span><br>    <span class="hljs-keyword">public</span> View view;<br>    <span class="hljs-comment">// 存放我们收集的信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; values = new ArrayMap&lt;String, Object&gt;();<br><br>    <span class="hljs-keyword">final</span> ArrayList&lt;Transition&gt; targetedTransitions = new ArrayList&lt;Transition&gt;();<br></code></pre></td></tr></table></figure><p><code>captureStartValues()</code>与<code>captureEndValues()</code>方法是必须实现的，和结束值，而<code>createAnimator()</code>方法，是用来创建自定义的动画。</p><p>参数<code>TransitionValues</code>可以理解是用来存储View的一些属性值，参数<code>sceneRoot</code>为根视图。</p><p>先看效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/%E8%87%AA%E5%AE%9A%E4%B9%89Transition.gif" alt="自定义Transition" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTransition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Transition</span> &#123;<br>    <span class="hljs-comment">// 收集高度和宽度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TOP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;top&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">HEIGHT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;height&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">captureStartValues</span><span class="hljs-params">(TransitionValues transitionValues)</span> &#123;<br>        <span class="hljs-comment">// 拿到我们的目标view</span><br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> transitionValues.view;<br>        <span class="hljs-type">Rect</span> <span class="hljs-variable">rect</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rect</span>();<br>        <span class="hljs-comment">// 拿到它的父布局上下左右的距离</span><br>        view.getHitRect(rect);<br>        <span class="hljs-comment">// 保存到values</span><br>        transitionValues.values.put(TOP, rect.top);<br>        transitionValues.values.put(HEIGHT, view.getHeight());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">captureEndValues</span><span class="hljs-params">(TransitionValues transitionValues)</span> &#123;<br>        <span class="hljs-comment">// 和上面同理</span><br>        transitionValues.values.put(TOP, <span class="hljs-number">0</span>);<br>        transitionValues.values.put(HEIGHT, transitionValues.view.getHeight());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Animator <span class="hljs-title function_">createAnimator</span><span class="hljs-params">(ViewGroup sceneRoot, TransitionValues startValues, TransitionValues endValues)</span> &#123;<br>        <span class="hljs-keyword">if</span> (startValues == <span class="hljs-literal">null</span> || endValues == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">endView</span> <span class="hljs-operator">=</span> endValues.view;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">startTop</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) startValues.values.get(TOP);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">startHeight</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) startValues.values.get(HEIGHT);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">endTop</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) endValues.values.get(TOP);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">endHeight</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) endValues.values.get(HEIGHT);<br>        <span class="hljs-comment">// 首先把view的高度设置为前一个界面上view的高度是为了防止在移动的过程中view的高度是他自身的高度的.</span><br>        endView.setTranslationY(startTop);<br>        endView.getLayoutParams().height = startHeight;<br>        endView.requestLayout();<br>        <span class="hljs-comment">// 移动动画</span><br>        <span class="hljs-type">ValueAnimator</span> <span class="hljs-variable">positionAnimator</span> <span class="hljs-operator">=</span> ValueAnimator.ofInt(startTop, endTop);<br>        positionAnimator.setDuration(<span class="hljs-number">200</span>);<br>        positionAnimator.setInterpolator(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearInterpolator</span>());<br>        positionAnimator.addUpdateListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) positionAnimator.getAnimatedValue();<br>                endView.setTranslationY(current);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 展开动画</span><br>        <span class="hljs-type">ValueAnimator</span> <span class="hljs-variable">sizeAnimator</span> <span class="hljs-operator">=</span> ValueAnimator.ofInt(startHeight, endHeight);<br>        sizeAnimator.setDuration(<span class="hljs-number">200</span>);<br>        sizeAnimator.setInterpolator(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearInterpolator</span>());<br>        sizeAnimator.addUpdateListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator valueAnimator)</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) valueAnimator.getAnimatedValue();<br>                endView.getLayoutParams().height = current;<br>                endView.requestLayout();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 动画集合</span><br>        <span class="hljs-type">AnimatorSet</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnimatorSet</span>();<br>        set.play(sizeAnimator).after(positionAnimator);<br>        <span class="hljs-keyword">return</span> set;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  下面是跳转代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">    <span class="hljs-comment">// 界面1中</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, msg: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, MainActivity5::<span class="hljs-keyword">class</span>.java)<br>        intent.putExtra(<span class="hljs-string">&quot;msg&quot;</span>, msg)<br>        <span class="hljs-keyword">val</span> pair1 = Pair.create(view, view.transitionName)<br>        <span class="hljs-comment">// 和前面的操作一样</span><br>        <span class="hljs-keyword">val</span> compat =<br>            ActivityOptionsCompat.makeSceneTransitionAnimation(<span class="hljs-keyword">this</span>, pair1)<br>        ActivityCompat.startActivity(<span class="hljs-keyword">this</span>, intent, compat.toBundle())<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 界面2中</span><br><span class="hljs-keyword">val</span> textView = findViewById&lt;TextView&gt;(R.id.textView5)<br>        textView.text = intent.getStringExtra(<span class="hljs-string">&quot;msg&quot;</span>)<br>        <span class="hljs-keyword">val</span> transition = MyTransition()<br>        <span class="hljs-comment">// 这个target就是我们设置的transitionName</span><br>        transition.addTarget(<span class="hljs-string">&quot;transition2&quot;</span>)<br>        <span class="hljs-comment">// 设置成我们自定义的Transition</span><br>        window.sharedElementEnterTransition = transition<br></code></pre></td></tr></table></figure><p>  这里有一个NavigationBar会有闪烁问题,原因是共享元素动画是在整个窗口的view上执行的,解决方法就是将导航栏作为动画的一部分,然后在界面2中延迟动画,有两个方法来延迟动画执行: <code>postponeEnterTransition()</code>和<code>startPostponedEnterTransition()</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 界面1</span><br><span class="hljs-keyword">val</span> decor = window.decorView<br>        decor.viewTreeObserver.addOnPreDrawListener(<span class="hljs-keyword">object</span> : ViewTreeObserver.OnPreDrawListener &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPreDraw</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>                decor.viewTreeObserver.removeOnPreDrawListener(<span class="hljs-keyword">this</span>)<br>                <span class="hljs-comment">// 从根布局获得statusBar和navigationBar实例</span><br>                statusBar = decor.findViewById&lt;View&gt;(android.R.id.statusBarBackground)<br>                navigationBar = findViewById&lt;View&gt;(android.R.id.navigationBarBackground)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;)<br>    <span class="hljs-keyword">val</span> intent = Intent(<span class="hljs-keyword">this</span>, MainActivity5::<span class="hljs-keyword">class</span>.java)<br>    intent.putExtra(<span class="hljs-string">&quot;msg&quot;</span>, msg)<br>    <span class="hljs-keyword">val</span> pair1 = Pair.create(view, view.transitionName)<br>    <span class="hljs-comment">// 给statusBar和navigationBar加上动画</span><br>    <span class="hljs-keyword">val</span> pair2 = Pair.create(statusBar, Window.STATUS_BAR_BACKGROUND_TRANSITION_NAME)<br>    <span class="hljs-keyword">val</span> pair3 = Pair.create(navigationBar, Window.NAVIGATION_BAR_BACKGROUND_TRANSITION_NAME)<br>    <span class="hljs-keyword">val</span> compat =<br>        ActivityOptionsCompat.makeSceneTransitionAnimation(<span class="hljs-keyword">this</span>, pair1,pair2,pair3 )<br>    ActivityCompat.startActivity(<span class="hljs-keyword">this</span>, intent, compat.toBundle())<br><br><span class="hljs-comment">//界面2</span><br><span class="hljs-keyword">val</span> textView = findViewById&lt;TextView&gt;(R.id.textView5)<br>        textView.text = intent.getStringExtra(<span class="hljs-string">&quot;msg&quot;</span>)<br>        postponeEnterTransition()<br>        <span class="hljs-keyword">val</span> decorView = window.decorView<br>        window.decorView.viewTreeObserver.addOnPreDrawListener(<span class="hljs-keyword">object</span> :<br>            ViewTreeObserver.OnPreDrawListener &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPreDraw</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>                decorView.viewTreeObserver.removeOnPreDrawListener(<span class="hljs-keyword">this</span>)<br>                supportStartPostponedEnterTransition()<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;)<br>        <span class="hljs-keyword">val</span> transition = MyTransition()<br>        transition.addTarget(<span class="hljs-string">&quot;transition2&quot;</span>)<br>        window.sharedElementEnterTransition = transition<br></code></pre></td></tr></table></figure><h4 id="Transition源码"><a href="#Transition源码" class="headerlink" title="Transition源码"></a>Transition源码</h4><p>  这个有点多,我就贴个链接,想了解的自己看一下</p><p><a href="https://juejin.cn/post/6844903488040747015">Android Transition源码分析 - 掘金</a></p><h3 id="Material-Motion"><a href="#Material-Motion" class="headerlink" title="Material Motion"></a>Material Motion</h3><p>​    <strong>Material Design YYDS</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">&#x27;com.google.android.material:material:1.6.0&#x27;</span><br></code></pre></td></tr></table></figure><p>  <code>MaterialContainerTransform</code> 是一个共享元素动画，但和传统的Android共享元素动画不同，它不是围绕单一的共享内容(如图像)设计的。这里的共享元素指的是开始视图或ViewGroup容器将其大小和形状转换为结束视图或ViewGroup容器的大小和形状，可以理解为开始和结束容器视图是容器转换的“共享元素”。并且可以用在 Fragments, Activities 或者 Views.</p><p>material-motion-android 是MDC-Android库中的一组过渡模式; 其中主要包含四种过渡模式:</p><ul><li><strong>ContainerTransform</strong> : 包含 container 的UI元素之间的转换 在两个不同的UI元素之间创建可见连接, 使一个UI元素无缝过渡到另一个UI元素.</li><li><strong>SharedAxis</strong> : 具有空间或导航关系的UI元素之间的过渡; 在X,Y或Z轴上使用共享变换来加强元素之间的关系.</li><li><strong>FadeThrough</strong> : 在彼此之间没有密切关系的UI元素之间进行过渡; 使用顺序淡入和淡入, 以及传入元素的比例.</li><li><strong>Fade</strong> : 用于在屏幕范围内进入或退出的UI元素.</li></ul><p>一些常用函数</p><ul><li><strong>fadeMode</strong></li></ul><p>设置淡入淡出模式，用于将开始视图的内容与结束视图的内容切换。 有四种淡入淡出模式：</p><p><code>FADE_MODE_IN</code> ：淡入传入内容，而不更改传出内容的不透明度。 这是默认模式。</p><p><code>FADE_MODE_OUT</code> ：淡出输出内容而不更改输入内容的不透明度。</p><p><code>FADE_MODE_CROSS</code> ：淡入淡出传入的内容。</p><p><code>FADE_MODE_THROUGH</code> ： <code>FADE_MODE_THROUGH</code>淡出输出内容并淡入输入内容。</p><ul><li><strong>fitMode</strong></li></ul><p>共有三个选项：</p><p><code>FIT_MODE_HEIGHT</code> ：在缩放动画期间，将传入内容调整为传出内容的高度。</p><p><code>FIT_MODE_WIDTH</code> ：在缩放动画过程中，使传入内容适合传出内容的宽度。</p><p><code>FIT_MODE_AUTO</code> ：自动使用FIT_MODE_HEIGHT或FIT_MODE_WIDTH。</p><ul><li><strong>containerColor</strong></li></ul><p>设置变形容器的背景颜色。 此颜色绘制在开始视图和结束视图下方。 当一个或两个都不具有纯色背景时，这非常有用。 这也可以用来设置过渡的颜色，以增强从一种视图到另一种视图的转化。</p><ul><li><strong>scrimColor</strong></li></ul><p>设置要在drawingView范围内的变形容器下绘制的颜色。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">buildContainerTransform</span><span class="hljs-params">()</span></span> =<br>        MaterialContainerTransform().apply &#123;<br>            startView =findViewById(R.id.floatingActionBar1)<br>            endView =findViewById(R.id.materialCardView1)<br>            duration = <span class="hljs-number">300</span><br>            scrimColor = Color.TRANSPARENT<br>            containerColor =<br>                requireContext().themeColor(com.google.android.material.R.attr.colorSurface)<br>            addTarget(binding.coordinator)<br>            pathMotion = MaterialArcMotion()<br>            fadeMode = MaterialContainerTransform.FADE_MODE_IN<br>            interpolator = FastOutSlowInInterpolator()<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="MaterialContainerTransform"><a href="#MaterialContainerTransform" class="headerlink" title="MaterialContainerTransform"></a>MaterialContainerTransform</h4><p>MDC-Android 库中的容器转换称为 <code>MaterialContainerTransform</code>。默认情况下，这个 <code>Transition</code> 子类会作为共享元素过渡运行，当带有 <code>transitionName</code> 标记时，Android 过渡系统可以选择两个采用不同布局的视图。</p><p>首先在两个fragment中设置共享view的translationName</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:transitionName=&quot;transitionName&quot;<br></code></pre></td></tr></table></figure><p>  在fragment3中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 设置退出和重进入动画</span><br>exitTransition = MaterialElevationScale(<span class="hljs-literal">false</span>).apply &#123;<br>    duration = <span class="hljs-number">300</span><br>&#125;<br>reenterTransition = MaterialElevationScale(<span class="hljs-literal">true</span>).apply &#123;<br>    duration = <span class="hljs-number">300</span><br>&#125;<br><span class="hljs-keyword">val</span> fragment4 = Fragment4()<br><span class="hljs-keyword">val</span> bundle = Bundle()<br>bundle.putString(<span class="hljs-string">&quot;param1&quot;</span>, msg)<br>bundle.putString(<span class="hljs-string">&quot;param2&quot;</span>, view.transitionName)<br>fragment4.arguments = bundle<br>requireActivity().supportFragmentManager.beginTransaction()<br>    .addSharedElement(view, view.transitionName)<br>    .replace(R.id.constraintLayout4, fragment4).addToBackStack(<span class="hljs-literal">null</span>).commit()<br></code></pre></td></tr></table></figure><p>设置延迟动画</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">postponeEnterTransition()<br>view.doOnPreDraw &#123; startPostponedEnterTransition() &#125;<br></code></pre></td></tr></table></figure><p>在fragment4中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">sharedElementEnterTransition = MaterialContainerTransform().apply &#123;<br>    duration = <span class="hljs-number">500</span><br>    scrimColor = Color.TRANSPARENT<br>    setAllContainerColors(<br>        requireContext().obtainStyledAttributes(intArrayOf(com.google.android.material.R.attr.colorSurface))<br>            .use &#123;<br>                it.getColor(<span class="hljs-number">0</span>, Color.MAGENTA)<br>            &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>为确保将 <code>MaterialElevationScale</code> 过渡应用到整个主屏幕在根布局下标记过渡组</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:transitionGroup=&quot;true&quot;<br></code></pre></td></tr></table></figure><p>效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/Shared_transition_final.gif" alt="Shared_transition_final" style="zoom: 50%;" /><h4 id="MaterialElevationScale"><a href="#MaterialElevationScale" class="headerlink" title="MaterialElevationScale"></a>MaterialElevationScale</h4><p>在fragment5中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">enterTransition = MaterialContainerTransform().apply &#123;<br>    startView = requireActivity().findViewById(R.id.floatingActionBar1)<br>    endView = requireView().findViewById(R.id.materialCardView1)<br>    duration = <span class="hljs-number">300</span><br>    scrimColor = Color.TRANSPARENT<br>    containerColor =<br>        requireContext().themeColor(com.google.android.material.R.attr.colorSurface)<br>    startContainerColor =<br>        requireContext().themeColor(com.google.android.material.R.attr.colorSecondary)<br>    endContainerColor =<br>        requireContext().themeColor(com.google.android.material.R.attr.colorSurface)<br>&#125;<br>returnTransition = Slide().apply &#123;<br>    duration = <span class="hljs-number">300</span><br>    addTarget(R.id.materialCardView1)<br>&#125;<br></code></pre></td></tr></table></figure><p>在fragment3中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">exitTransition = MaterialElevationScale(<span class="hljs-literal">false</span>).apply &#123;<br>    duration = <span class="hljs-number">300</span><br>&#125;<br>reenterTransition = MaterialElevationScale(<span class="hljs-literal">true</span>).apply &#123;<br>    duration = <span class="hljs-number">300</span><br>&#125;<br><span class="hljs-keyword">val</span> fragment5 = Fragment5()<br>requireActivity().supportFragmentManager.beginTransaction()<br>    .replace(R.id.constraintLayout4, fragment5).addToBackStack(<span class="hljs-literal">null</span>).commit()<br></code></pre></td></tr></table></figure><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/MaterialElevationScale.gif" alt="MaterialElevationScale" style="zoom: 50%;" /><h4 id="MaterialSharedAxis"><a href="#MaterialSharedAxis" class="headerlink" title="MaterialSharedAxis"></a>MaterialSharedAxis</h4><p>  在fragment3</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 离开时放大过渡</span><br>exitTransition = MaterialSharedAxis(MaterialSharedAxis.Z, <span class="hljs-literal">true</span>).apply &#123;<br>    duration = <span class="hljs-number">300</span><br>&#125;<br><span class="hljs-comment">// 重新返回时缩小过渡</span><br>reenterTransition = MaterialSharedAxis(MaterialSharedAxis.Z, <span class="hljs-literal">false</span>).apply &#123;<br>    duration = <span class="hljs-number">300</span><br>&#125;<br><span class="hljs-keyword">val</span> fragment6 = Fragment6()<br>requireActivity().supportFragmentManager.beginTransaction()<br>    .replace(R.id.constraintLayout4, fragment6).addToBackStack(<span class="hljs-literal">null</span>).commit()<br></code></pre></td></tr></table></figure><p>在fragment6</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 进入时放大过渡</span><br>enterTransition = MaterialSharedAxis(MaterialSharedAxis.Z, <span class="hljs-literal">true</span>).apply &#123;<br>    duration = <span class="hljs-number">300</span><br>&#125;<br><span class="hljs-comment">// 返回时缩小过渡</span><br>returnTransition = MaterialSharedAxis(MaterialSharedAxis.Z, <span class="hljs-literal">false</span>).apply &#123;<br>    duration = <span class="hljs-number">300</span><br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>MaterialSharedAxis.X</th><th>MaterialSharedAxis.Y</th><th>MaterialSharedAxis.Z</th></tr></thead><tbody><tr><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/MaterialSharedAxis-X.gif" alt="MaterialSharedAxis-X" style="zoom: 30%;" /></td><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/MaterialSharedAxis-Y.gif" alt="MaterialSharedAxis-Y" style="zoom: 30%;" /></td><td><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/MaterialSharedAxis-Z.gif" alt="MaterialSharedAxis-Z" style="zoom: 30%;" /></td></tr></tbody></table><h4 id="MaterialFadeThrough"><a href="#MaterialFadeThrough" class="headerlink" title="MaterialFadeThrough"></a>MaterialFadeThrough</h4><p>在fragment3</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">exitTransition = MaterialFadeThrough().apply &#123;<br>                duration = <span class="hljs-number">300</span><br>            &#125;<br>            <span class="hljs-keyword">val</span> fragment7 = Fragment7()<br>            requireActivity().supportFragmentManager.beginTransaction()<br>                .replace(R.id.constraintLayout4, fragment7).addToBackStack(<span class="hljs-literal">null</span>).commit()<br></code></pre></td></tr></table></figure><p>在fragment7</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">enterTransition = MaterialFadeThrough().apply &#123;<br>    duration = <span class="hljs-number">300</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/MaterialFadeThrough.gif" alt="MaterialFadeThrough" style="zoom: 50%;" /><h4 id="View的MaterialContainerTransform"><a href="#View的MaterialContainerTransform" class="headerlink" title="View的MaterialContainerTransform"></a>View的MaterialContainerTransform</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 展开动画</span><br><span class="hljs-keyword">val</span> transform = MaterialContainerTransform().apply &#123;<br>            startView = chip<br>            endView = materialCardView2<br>            scrimColor = Color.TRANSPARENT<br>            endElevation = <span class="hljs-number">3f</span><br>            addTarget(materialCardView2)<br>        &#125;<br>        TransitionManager.beginDelayedTransition(constraintLayout, transform)<br><span class="hljs-comment">// 收缩动画</span><br><span class="hljs-keyword">val</span> transform = MaterialContainerTransform().apply &#123;<br>            startView = materialCardView2<br>            endView = chip<br>            scrimColor = Color.TRANSPARENT<br>            startElevation = <span class="hljs-number">3f</span><br>            addTarget(chip)<br>        &#125;<br>        TransitionManager.beginDelayedTransition(constraintLayout, transform)<br></code></pre></td></tr></table></figure><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/View-MaterialContainerTransform.gif" alt="View-MaterialContainerTransform" style="zoom: 50%;" /><h3 id="其他的一些动画"><a href="#其他的一些动画" class="headerlink" title="其他的一些动画"></a>其他的一些动画</h3><h4 id="RecyclerView入场动画"><a href="#RecyclerView入场动画" class="headerlink" title="RecyclerView入场动画"></a>RecyclerView入场动画</h4><p>在xml里设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">translate</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fromXDelta</span>=<span class="hljs-string">&quot;-50%p&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:toXDelta</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">alpha</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fromAlpha</span>=<span class="hljs-string">&quot;0.0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:toAlpha</span>=<span class="hljs-string">&quot;1.0&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在初始化recyclerView时</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">recyclerView.layoutAnimation = <span class="hljs-comment">// 入场动画</span><br>            LayoutAnimationController(<br>                AnimationUtils.loadAnimation(<br>                    context,<br>                    R.anim.recycler_view_fade_in<br>                )<br>            )<br></code></pre></td></tr></table></figure><p>效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/ehwoWQDFGOZb8kz.gif" alt="RecyclerView-入场动画" style="zoom: 50%;" /><h4 id="ViewPager2的切换动画"><a href="#ViewPager2的切换动画" class="headerlink" title="ViewPager2的切换动画"></a>ViewPager2的切换动画</h4><p>先继承viewPager2.PageTransformer</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MAX_ROTATION = <span class="hljs-number">90f</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> MIN_SCALE = <span class="hljs-number">0.9f</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareBoxTransformer</span> : <span class="hljs-type">ViewPager2.PageTransformer</span> &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transformPage</span><span class="hljs-params">(page: <span class="hljs-type">View</span>, position: <span class="hljs-type">Float</span>)</span></span> &#123;<br>        page.apply &#123;<br>            pivotY = height / <span class="hljs-number">2f</span><br>            <span class="hljs-keyword">when</span> &#123;<br>                position &lt; -<span class="hljs-number">1</span> -&gt; &#123;<br>                    <span class="hljs-comment">// This page is way off-screen to the left.</span><br>                    rotationY = -MAX_ROTATION<br>                    pivotX = width.toFloat()<br>                &#125;<br>                position &lt;= <span class="hljs-number">1</span> -&gt; &#123;<br>                    rotationY = position * MAX_ROTATION<br>                    <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span>) &#123;<br>                        pivotX = width.toFloat()<br>                        <span class="hljs-keyword">val</span> scale =<br>                            MIN_SCALE + <span class="hljs-number">4f</span> * (<span class="hljs-number">1f</span> - MIN_SCALE) * (position + <span class="hljs-number">0.5f</span>) * (position + <span class="hljs-number">0.5f</span>)<br>                        scaleX = scale<br>                        scaleY = scale<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        pivotX = <span class="hljs-number">0f</span><br>                        <span class="hljs-keyword">val</span> scale =<br>                            MIN_SCALE + <span class="hljs-number">4f</span> * (<span class="hljs-number">1f</span> - MIN_SCALE) * (position - <span class="hljs-number">0.5f</span>) * (position - <span class="hljs-number">0.5f</span>)<br>                        scaleX = scale<br>                        scaleY = scale<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> -&gt; &#123;<br>                    <span class="hljs-comment">// This page is way off-screen to the right.</span><br>                    rotationY = MAX_ROTATION<br>                    pivotX = <span class="hljs-number">0f</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/BpNo46EwZGQaCqr.webp" alt="img" style="zoom: 67%;" /><table><thead><tr><th></th><th>前一个view的position变化</th><th>当前view的position变化</th><th>后一个view的position变化</th></tr></thead><tbody><tr><td>当前view右滑时</td><td>-1 —-&gt; 0</td><td>0——–&gt;1</td><td>1 —-&gt; +∞</td></tr><tr><td>当前view左滑时</td><td>-∞ —-&gt; -1</td><td>0 —–&gt; -1</td><td>1 ——-&gt;0</td></tr></tbody></table><p>  参数page是ViewPager持有的页面(包括cureent page)的rootView，position是page相对于基准参考点的偏移量，滑动过程中可标识page的偏移程度，周期为1。根据基准参考点及page页面宽度归一化的描述，在SCROLL_STATE_IDLE状态下，current page的position为0，上一页的position为-1.0，下一页的position为1.0，依此类推。</p><p>然后在viewPager2中设置</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mViewPager2.setPageTransformer(SquareBoxTransformer())<br></code></pre></td></tr></table></figure><p>效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/ViewPager2-%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB.gif" alt="ViewPager2-切换动画" style="zoom: 50%;" /><h4 id="自动为布局更新添加动画"><a href="#自动为布局更新添加动画" class="headerlink" title="自动为布局更新添加动画"></a>自动为布局更新添加动画</h4><p>在 Activity 的布局 XML 文件中，针对您要启用动画的布局，将 <code>android:animateLayoutChanges</code> 属性设置为 <code>true</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/container&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">android:animateLayoutChanges</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">...</span></span><br><span class="hljs-tag">   /&gt;</span><br></code></pre></td></tr></table></figure><p>在activity中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> containerView: ViewGroup<br>   ...<br>   <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addItem</span><span class="hljs-params">()</span></span> &#123;<br>       <span class="hljs-keyword">val</span> newView: View = ...<br><br>       containerView.addView(newView, <span class="hljs-number">0</span>)<br>   &#125;<br></code></pre></td></tr></table></figure><p>效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/%E5%B8%83%E5%B1%80%E6%9B%B4%E6%96%B0%E5%8A%A8%E7%94%BB.gif" alt="布局更新动画" style="zoom: 50%;" /><h2 id="Compose动画-补充"><a href="#Compose动画-补充" class="headerlink" title="Compose动画[补充]"></a>Compose动画[补充]</h2><h3 id="为简单的值变化添加动画效果"><a href="#为简单的值变化添加动画效果" class="headerlink" title="为简单的值变化添加动画效果"></a>为简单的值变化添加动画效果</h3><blockquote><p>切换标签页，内容的背景颜色会发生变化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> backgroundColor = <span class="hljs-keyword">if</span> (tabPage == TabPage.Home) Purple100 <span class="hljs-keyword">else</span> Green300<br></code></pre></td></tr></table></figure><p>如果需要为简单值变化添加动画效果，可以使用 <code>animate*AsState</code> .这里使用<code>animateColorAsState</code>可组合向，创建动画值。</p><p>注意:返回的值是 <code>State&lt;T&gt;</code> 对象，可以使用包含 <code>by</code> 声明的本地委托属性，将该值视为普通变量。<code>Compose</code>中都会把State<T>对象使用by委托属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> backgroundColor <span class="hljs-keyword">by</span> animateColorAsState(<span class="hljs-keyword">if</span> (tabPage == TabPage.Home) Purple100 <span class="hljs-keyword">else</span> Green300)<br></code></pre></td></tr></table></figure><p>效果图:颜色变化</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/XqHFONVlIwhcURk.gif" alt="Compose-animateColorAsState" width="250dp" /></blockquote><h3 id="为可见性添加动画效果"><a href="#为可见性添加动画效果" class="headerlink" title="为可见性添加动画效果"></a>为可见性添加动画效果</h3><blockquote><p>使用 <code>if</code> 语句显示或隐藏”Edit”的文本。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (extended) &#123;<br>Text(<br>  text = stringResource(R.string.edit),<br>  modifier = Modifier<br>      .padding(start = <span class="hljs-number">8.</span>dp, top = <span class="hljs-number">3.</span>dp)<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>为可见性变化添加动画，将 <code>if</code> 替换为 <code>AnimatedVisibility</code> 可组合项。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">AnimatedVisibility(extended) &#123;<br>Text(<br>  text = stringResource(R.string.edit),<br>  modifier = Modifier<br>      .padding(start = <span class="hljs-number">8.</span>dp, top = <span class="hljs-number">3.</span>dp)<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图:FAB的展开</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/WzescPJXxM7lGrI.gif" alt="Compose-AnimatedVisibility" style="zoom:33%;" /><p>默认情况下，<code>AnimatedVisibility</code> 会以淡入和展开的方式显示元素，以淡出和缩小的方式隐藏元素。</p></blockquote><blockquote><p>接下来自定义可见性动画，从而让元素从顶部滑入，然后滑出到顶部。</p><p>将<code>enter</code> 和 <code>exit</code> 参数添加到 <code>AnimatedVisibility</code> 可组合项中。</p><p><code>enter</code> 参数是 <code>EnterTransition</code> 的实例。使用 <code>slideInVertically</code> 函数创建 <code>EnterTransition</code>。<code>initialOffsetY</code> 参数是返回初始位置的 lambda。lambda 会收到一个表示元素高度的参数，只需返回其负值即可。使用 <code>slideInVertically</code> 时，滑入后的目标偏移量始终为 <code>0</code>（像素）。可使用 lambda 函数将 <code>initialOffsetY</code> 指定为绝对值或元素全高度的百分比。</p><p><code>animationSpec</code> 是指定动画值应如何随时间变化。这里，用 <code>tween</code> 函数创建, 时长为 150 毫秒，加&#x2F;减速选项为 <code>LinearOutSlowInEasing</code>。</p><p>同理，可以对 <code>exit</code> 参数使用 <code>slideOutVertically</code> 函数。<code>slideOutVertically</code> 假定初始偏移量为 0，只需指定 <code>targetOffsetY</code>。使 <code>tween</code> 函数，但时长为 250 毫秒，加&#x2F;减速选项为 <code>FastOutLinearInEasing</code>。</p><p>生成的代码应如下所示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin">AnimatedVisibility(<br>visible = shown,<br>enter = slideInVertically(<br>  <span class="hljs-comment">// Enters by sliding down from offset -fullHeight to 0.</span><br>  initialOffsetY = &#123; fullHeight -&gt; -fullHeight &#125;,<br>  animationSpec = tween(durationMillis = <span class="hljs-number">150</span>, easing = LinearOutSlowInEasing)<br>),<br>exit = slideOutVertically(<br>  <span class="hljs-comment">// Exits by sliding up from offset 0 to -fullHeight.</span><br>  targetOffsetY = &#123; fullHeight -&gt; -fullHeight &#125;,<br>  animationSpec = tween(durationMillis = <span class="hljs-number">250</span>, easing = FastOutLinearInEasing)<br>)<br>) &#123;<br>Surface(<br>  modifier = Modifier.fillMaxWidth(),<br>  color = MaterialTheme.colors.secondary,<br>  elevation = <span class="hljs-number">4.</span>dp<br>) &#123;<br>  Text(<br>      text = stringResource(R.string.edit_message),<br>      modifier = Modifier.padding(<span class="hljs-number">16.</span>dp)<br>  )<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图:消息现在是从顶部滑入和滑出。</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/uoXHKFhv7nsBc9V.gif" alt="Compose-AnimatedVisibility-Custom" style="zoom:33%;" /></blockquote><h3 id="为内容大小添加动画效果"><a href="#为内容大小添加动画效果" class="headerlink" title="为内容大小添加动画效果"></a>为内容大小添加动画效果</h3><blockquote><p>当正文显示或隐藏时，包含文本的卡片会展开或缩小。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Column(<br>modifier = Modifier<br>  .fillMaxWidth()<br>  .padding(<span class="hljs-number">16.</span>dp)<br>) &#123;<br><span class="hljs-comment">// ... the title and the body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此处的这个 <code>Column</code> 可组合项会在内容发生变化时更改其大小。添加 <code>animateContentSize</code> 修饰符，为其大小变化添加动画效果。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Column(<br>modifier = Modifier<br>  .fillMaxWidth()<br>  .padding(<span class="hljs-number">16.</span>dp)<br>  .animateContentSize()<br>) &#123;<br><span class="hljs-comment">// ... the title and the body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/mvVMbNucZqQY1Wd.gif" alt="Compose-animateContentSize" style="zoom:33%;" /></blockquote><h3 id="多值动画"><a href="#多值动画" class="headerlink" title="多值动画"></a>多值动画</h3><blockquote><p>我们自定义了标签页指示器。它是当前所选标签页上显示的一个矩形。</p><p>如需同时为多个值添加动画效果，可使用 <code>Transition</code>。<code>Transition</code> 可使用 <code>updateTransition</code> 函数创建。将当前所选标签页的索引作为 <code>targetState</code> 参数传递。</p><p>每个动画值都可以使用 <code>Transition</code> 的 <code>animate*</code> 扩展函数进行声明。这里使用 <code>animateDp</code> 和 <code>animateColor</code>。它们会接受一个 lambda 块，可以为每个状态指定目标值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> transition = updateTransition(tabPage)<br><span class="hljs-keyword">val</span> indicatorLeft <span class="hljs-keyword">by</span> transition.animateDp &#123; page -&gt;<br>tabPositions[page.ordinal].left<br>&#125;<br><span class="hljs-keyword">val</span> indicatorRight <span class="hljs-keyword">by</span> transition.animateDp &#123; page -&gt;<br>tabPositions[page.ordinal].right<br>&#125;<br><span class="hljs-keyword">val</span> color <span class="hljs-keyword">by</span> transition.animateColor &#123; page -&gt;<br><span class="hljs-keyword">if</span> (page == TabPage.Home) Purple700 <span class="hljs-keyword">else</span> Green800<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图: 点击标签页会更改 <code>tabPage</code> 状态的值，这时与 <code>transition</code> 关联的所有动画值会开始以动画方式切换至为目标状态指定的值。</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/xt2P8iQW5mXjfwv.gif" alt="Compose-Transition-多值动画1" style="zoom:33%;" /><p>此外，可以指定 <code>transitionSpec</code> 参数来自定义动画行为。例如可以让靠近目标页面的一边比另一边移动得更快来实现指示器的弹性效果。可以在 <code>transitionSpec</code>中使用 <code>isTransitioningTo</code> infix 函数来确定状态变化的方向。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> transition = updateTransition(<br>tabPage,<br>label = <span class="hljs-string">&quot;Tab indicator&quot;</span><br>)<br><span class="hljs-keyword">val</span> indicatorLeft <span class="hljs-keyword">by</span> transition.animateDp(<br>transitionSpec = &#123;<br>  <span class="hljs-keyword">if</span> (TabPage.Home isTransitioningTo TabPage.Work) &#123;<br>      <span class="hljs-comment">// Indicator moves to the right.</span><br>      <span class="hljs-comment">// The left edge moves slower than the right edge.</span><br>      spring(stiffness = Spring.StiffnessVeryLow)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Indicator moves to the left.</span><br>      <span class="hljs-comment">// The left edge moves faster than the right edge.</span><br>      spring(stiffness = Spring.StiffnessMedium)<br>  &#125;<br>&#125;,<br>label = <span class="hljs-string">&quot;Indicator left&quot;</span><br>) &#123; page -&gt;<br>tabPositions[page.ordinal].left<br>&#125;<br><span class="hljs-keyword">val</span> indicatorRight <span class="hljs-keyword">by</span> transition.animateDp(<br>transitionSpec = &#123;<br>  <span class="hljs-keyword">if</span> (TabPage.Home isTransitioningTo TabPage.Work) &#123;<br>      <span class="hljs-comment">// Indicator moves to the right</span><br>      <span class="hljs-comment">// The right edge moves faster than the left edge.</span><br>      spring(stiffness = Spring.StiffnessMedium)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Indicator moves to the left.</span><br>      <span class="hljs-comment">// The right edge moves slower than the left edge.</span><br>      spring(stiffness = Spring.StiffnessVeryLow)<br>  &#125;<br>&#125;,<br>label = <span class="hljs-string">&quot;Indicator right&quot;</span><br>) &#123; page -&gt;<br>tabPositions[page.ordinal].right<br>&#125;<br><span class="hljs-keyword">val</span> color <span class="hljs-keyword">by</span> transition.animateColor(<br>label = <span class="hljs-string">&quot;Border color&quot;</span><br>) &#123; page -&gt;<br><span class="hljs-keyword">if</span> (page == TabPage.Home) Purple700 <span class="hljs-keyword">else</span> Green800<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/TGzJo72are9R63b.gif" alt="Compose-Transition-多值动画2" style="zoom:33%;" /><p>Android Studio 支持在 Compose 预览中检查过渡效果。如需使用<strong>动画预览</strong>，请在预览中点击可组合项右上角的“Start interactive mode”图标，以开始交互模式。</p></blockquote><h3 id="重复动画"><a href="#重复动画" class="headerlink" title="重复动画"></a>重复动画</h3><blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> alpha = <span class="hljs-number">1f</span><br></code></pre></td></tr></table></figure><p><code>InfiniteTransition</code>可以实现重复动画,先使用 <code>rememberInfiniteTransition</code> 函数。然后，可以使用 <code>InfiniteTransition</code> 的一个 <code>animate*</code> 扩展函数声明每个动画值变化。这里为 Alpha 值添加动画效果，<code>initialValue</code> 参数应为 <code>0f</code>，而 <code>targetValue</code> 应为 <code>1f</code>。然后为动画指定 <code>InfiniteRepeatableSpec</code>,使其重复。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> infiniteTransition = rememberInfiniteTransition()<br><span class="hljs-keyword">val</span> alpha <span class="hljs-keyword">by</span> infiniteTransition.animateFloat(<br>initialValue = <span class="hljs-number">0f</span>,<br>targetValue = <span class="hljs-number">1f</span>,<br>animationSpec = infiniteRepeatable(<br>animation = keyframes &#123;<br>    durationMillis = <span class="hljs-number">1000</span><br>      <span class="hljs-number">0.7f</span> at <span class="hljs-number">500</span><br>  &#125;,<br>  repeatMode = RepeatMode.Reverse<br>)<br>)<br></code></pre></td></tr></table></figure><p>效果图:</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/aCVpfHsGh9w4QOZ.gif" alt="Compose-InfiniteTransition" style="zoom:33%;" /></blockquote><h3 id="手势动画"><a href="#手势动画" class="headerlink" title="手势动画"></a>手势动画</h3><blockquote><p>将动画值与来自触摸事件的值同步。</p><p>创建一个修饰符，以使触摸时元素可滑动。当元素被快速滑动到屏幕边缘时，调用 <code>onDismissed</code> 回调，移除该元素。</p><p><code>Animatable</code>可表示滑动元素的水平偏移量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> offsetX = remember &#123; Animatable(<span class="hljs-number">0f</span>) &#125; /<br>pointerInput &#123;<br><span class="hljs-comment">// Used to calculate a settling position of a fling animation.</span><br><span class="hljs-keyword">val</span> decay = splineBasedDecay&lt;<span class="hljs-built_in">Float</span>&gt;(<span class="hljs-keyword">this</span>)<br><span class="hljs-comment">// Wrap in a coroutine scope to use suspend functions for touch events and animation.</span><br>coroutineScope &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>如果动画当前正在运行，应将其拦截。可以通过调用 Animatable的stop() 来实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Wait for a touch down event.</span><br><span class="hljs-keyword">val</span> pointerId = awaitPointerEventScope &#123; awaitFirstDown().id &#125;<br>offsetX.stop() <br><span class="hljs-comment">// Prepare for drag events and record velocity of a fling.</span><br><span class="hljs-keyword">val</span> velocityTracker = VelocityTracker()<br><span class="hljs-comment">// Wait for drag events.</span><br>awaitPointerEventScope &#123;<br></code></pre></td></tr></table></figure><p>不断接收到拖动事件。必须将触摸事件的位置同步到动画值中。使用Animatable的snapTo。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">horizontalDrag(pointerId) &#123; change -&gt;<br><span class="hljs-comment">// Add these 4 lines</span><br><span class="hljs-keyword">val</span> horizontalDragOffset = offsetX.value + change.positionChange().x<br>launch &#123;<br>  offsetX.snapTo(horizontalDragOffset)<br>&#125;<br><span class="hljs-comment">// Record the velocity of the drag.</span><br>velocityTracker.addPosition(change.uptimeMillis, change.position)<br><span class="hljs-comment">// Consume the gesture event, not passed to external</span><br>change.consumePositionChange()<br>&#125;<br></code></pre></td></tr></table></figure><p>计算快速滑动操作的最终位置，确定是要将元素滑回原始位置，还是滑开元素</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Dragging finished. Calculate the velocity of the fling.</span><br><span class="hljs-keyword">val</span> velocity = velocityTracker.calculateVelocity().x<br><span class="hljs-comment">// Add this line</span><br><span class="hljs-keyword">val</span> targetOffsetX = decay.calculateTargetValue(offsetX.value, velocity)<br></code></pre></td></tr></table></figure><p>为 <code>Animatable</code> 设置值的上下界限，使到达界限时立即停止。使用 <code>pointerInput</code> 修饰符，可以通过 <code>size</code> 属性访问元素的大小,获取界限。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">offsetX.updateBounds(<br>lowerBound = -size.width.toFloat(),<br>upperBound = size.width.toFloat()<br>)<br></code></pre></td></tr></table></figure><p>首先来比较之前计算的快速滑动操作的最终位置以及元素的大小。如果最终位置低于该大小，则表示快速滑动的速度不够。使用 <code>animateTo</code> 将值的动画效果设置回 0f。否则，可以使用 <code>animateDecay</code> 来开始播放快速滑动动画。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">launch &#123;<br><span class="hljs-keyword">if</span> (targetOffsetX.absoluteValue &lt;= size.width) &#123;<br>  <span class="hljs-comment">// Not enough velocity; Slide back.</span><br>  offsetX.animateTo(targetValue = <span class="hljs-number">0f</span>, initialVelocity = velocity)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// Enough velocity to slide away the element to the edge.</span><br>  offsetX.animateDecay(velocity, decay)<br>  <span class="hljs-comment">// The element was swiped away.</span><br>  onDismissed()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后对元素应用偏移。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">.offset &#123; IntOffset(offsetX.value.roundToInt(), <span class="hljs-number">0</span>) &#125;<br></code></pre></td></tr></table></figure><p>最终代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Modifier.<span class="hljs-title">swipeToDismiss</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">onDismissed: () -&gt; <span class="hljs-type">Unit</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Modifier = composed &#123;<br><span class="hljs-comment">// This `Animatable` stores the horizontal offset for the element.</span><br><span class="hljs-keyword">val</span> offsetX = remember &#123; Animatable(<span class="hljs-number">0f</span>) &#125;<br>pointerInput(<span class="hljs-built_in">Unit</span>) &#123;<br>  <span class="hljs-comment">// Used to calculate a settling position of a fling animation.</span><br>  <span class="hljs-keyword">val</span> decay = splineBasedDecay&lt;<span class="hljs-built_in">Float</span>&gt;(<span class="hljs-keyword">this</span>)<br>  <span class="hljs-comment">// Wrap in a coroutine scope to use suspend functions for touch events and animation.</span><br>  coroutineScope &#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>          <span class="hljs-comment">// Wait for a touch down event.</span><br>          <span class="hljs-keyword">val</span> pointerId = awaitPointerEventScope &#123; awaitFirstDown().id &#125;<br>          <span class="hljs-comment">// Interrupt any ongoing animation.</span><br>          offsetX.stop()<br>          <span class="hljs-comment">// Prepare for drag events and record velocity of a fling.</span><br>          <span class="hljs-keyword">val</span> velocityTracker = VelocityTracker()<br>          <span class="hljs-comment">// Wait for drag events.</span><br>          awaitPointerEventScope &#123;<br>              horizontalDrag(pointerId) &#123; change -&gt;<br>                  <span class="hljs-comment">// Record the position after offset</span><br>                  <span class="hljs-keyword">val</span> horizontalDragOffset = offsetX.value + change.positionChange().x<br>                  launch &#123;<br>                      <span class="hljs-comment">// Overwrite the `Animatable` value while the element is dragged.</span><br>                      offsetX.snapTo(horizontalDragOffset)<br>                  &#125;<br>                  <span class="hljs-comment">// Record the velocity of the drag.</span><br>                  velocityTracker.addPosition(change.uptimeMillis, change.position)<br>                  <span class="hljs-comment">// Consume the gesture event, not passed to external</span><br>                  change.consumePositionChange()<br>              &#125;<br>          &#125;<br>          <span class="hljs-comment">// Dragging finished. Calculate the velocity of the fling.</span><br>          <span class="hljs-keyword">val</span> velocity = velocityTracker.calculateVelocity().x<br>          <span class="hljs-comment">// Calculate where the element eventually settles after the fling animation.</span><br>          <span class="hljs-keyword">val</span> targetOffsetX = decay.calculateTargetValue(offsetX.value, velocity)<br>          <span class="hljs-comment">// The animation should end as soon as it reaches these bounds.</span><br>          offsetX.updateBounds(<br>              lowerBound = -size.width.toFloat(),<br>              upperBound = size.width.toFloat()<br>          )<br>          launch &#123;<br>              <span class="hljs-keyword">if</span> (targetOffsetX.absoluteValue &lt;= size.width) &#123;<br>                  <span class="hljs-comment">// Not enough velocity; Slide back to the default position.</span><br>                  offsetX.animateTo(targetValue = <span class="hljs-number">0f</span>, initialVelocity = velocity)<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-comment">// Enough velocity to slide away the element to the edge.</span><br>                  offsetX.animateDecay(velocity, decay)<br>                  <span class="hljs-comment">// The element was swiped away.</span><br>                  onDismissed()<br>              &#125;<br>          &#125;<br>      &#125;<br>  &#125;<br>&#125;<br>  <span class="hljs-comment">// Apply the horizontal offset to the element.</span><br>  .offset &#123; IntOffset(offsetX.value.roundToInt(), <span class="hljs-number">0</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图:滑动删除</p><img src="https://typora-1256766878.cos.ap-chongqing.myqcloud.com/img/ADLPQNUysHxIpz1.png" alt="Compose-Animatable-手势动画" style="zoom:25%;" /></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><ul><li>使用<code>animateContentSize</code> 和 <code>AnimatedVisibility</code> 构建几种常见的动画模式。</li><li>使用 <code>animate*AsState</code> 为单个值添加动画效果</li><li>使用 <code>updateTransition</code> 为多个值添加动画效果</li><li>使用 <code>infiniteTransition</code> 为多个值无限期地添加动画效果 </li><li>使用 <code>Animatable</code> 构建了与触摸手势相结合的自定义动画。</li></ul></blockquote><p>参考文章:</p><ul><li><a href="https://developer.android.google.cn/codelabs/jetpack-compose-animation?continue=https://developer.android.google.cn/courses/pathways/compose%23codelab-https://developer.android.com/codelabs/jetpack-compose-animation#8">Jetpack Compose 动画 </a></li><li>[Anroid自定义控件开发入门与实战-启舰]</li></ul><p>本文源码已上传github: <a href="https://github.com/WhiteNight123/AnimationDemo">WhiteNight123&#x2F;AnimationDemo (github.com)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/19/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <url>/2022/10/19/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h1><p>由于时间原因，再加上事件分发的难度，本节课不会深入讲解底层实现，我会把整个事件的传递抽离出来，用更形象的东西来表示</p><p>但在学习前，我们先了解一下关于事件分发的基础知识</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>这里先展示 <code>ViewGroup</code> 与 <code>View</code> 在事件分发上的区别</p><h3 id="三个方法"><a href="#三个方法" class="headerlink" title="三个方法"></a>三个方法</h3><h4 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewGroup1</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context,<br>    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>,<br>    defStyleRes: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : FrameLayout(context, attrs, defStyleAttr, defStyleRes) &#123;<br>    <br>    <span class="hljs-comment">// dispatch 有分发的意思，所以这个函数作用是分发事件，为一个 View 事件的起点</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(ev: <span class="hljs-type">MotionEvent</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.dispatchTouchEvent(ev)<br>    &#125;<br>    <br>    <span class="hljs-comment">// intercept 有拦截的意思，所以这个函数作用是拦截事件，为一次 View 事件的决定点</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(ev: <span class="hljs-type">MotionEvent</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onInterceptTouchEvent(ev)<br>    &#125;<br><br>    <span class="hljs-comment">// 这里就是处理事件的地方</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(event: <span class="hljs-type">MotionEvent</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(event)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyView1</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context,<br>    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>,<br>    defStyleRes: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : View(context, attrs, defStyleAttr, defStyleRes) &#123;<br><br>    <span class="hljs-comment">// 与 ViewGroup 一样</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(event: <span class="hljs-type">MotionEvent</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.dispatchTouchEvent(event)<br>    &#125;<br><br>    <span class="hljs-comment">// 与 ViewGroup 一样</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(event: <span class="hljs-type">MotionEvent</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(event)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，<code>VieGroup</code> 比 <code>View</code> 多了一个 <code>onInterceptTouchEvent()</code> 方法，另外两个方法基本上时一样的</p><h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><p>其实 activity 也有这几个方法，但与 <code>View</code> 相同，没有 <code>onInterceptTouchEvent()</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(ev: <span class="hljs-type">MotionEvent</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.dispatchTouchEvent(ev)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(event: <span class="hljs-type">MotionEvent</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(event)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Down事件的流程图"><a href="#Down事件的流程图" class="headerlink" title="Down事件的流程图"></a>Down事件的流程图</h4><p>这三个方法的执行顺序<strong>在 <code>Down</code> 事件</strong>下为<strong>（一定要注意，下面这张图只表示 <code>Down</code> 事件，即手指刚触摸时）</strong></p><pre><code class=" mermaid">flowchart TBsubgraph activityid000(&quot;dispatchTouchEvent&quot;)id999(&quot;onTouchEvent&quot;)endid000(&quot;dispatchTouchEvent&quot;)--&gt;id1subgraph ViewGroup1id1[&quot;dispatchTouchEvent&quot;]--&gt;id2id2&#123;&quot;onIntercept&quot;&#125;--拦截--&gt;id3id3[&quot;onTouchEvent&quot;]--&gt;over0((over))endid2&#123;&quot;onIntercept&quot;&#125;--不拦截--&gt;id4subgraph ViewGroup2id4(&quot;dispatchTouchEvent&quot;)--&gt;id5id5&#123;&quot;onIntercept&quot;&#125;--拦截--&gt;id6id6[&quot;onTouchEvent&quot;]--&gt;over1((over))endid5&#123;&quot;onIntercept&quot;&#125;--不拦截--&gt;id7subgraph Viewid7(&quot;dispatchTouchEvent&quot;)--&gt;id8id8&#123;&quot;onTouchEvent&quot;&#125;id8--true--&gt;over2((over))endsubgraph ViewGroup2id8--false--&gt;id9id9&#123;&quot;onTouchEvent&quot;&#125;--true--&gt;over3((over))endsubgraph ViewGroup1id9--false--&gt;id10id10&#123;&quot;onTouchEvent&quot;&#125;--true--&gt;over4((over))endid10--false--&gt;id999</code></pre><p>上面这张图反映了事件分发的一般规律<strong>（记住这里是 <code>Down</code> 事件的事件传递）</strong></p><p>可能你会发现我对于 <code>onTouchEvent</code> 写了两遍，即使用了方括号又使用了菱形表示，其实这个是故意这样设计的，在<code>onInterceptTouchEvent()</code> 拦截后调用 <code>onTouchEvent()</code> 就直接结束了，而如果不存在 <code>onInterceptTouchEvent()</code> 拦截，就会从下面层层向上回调 <code>onTouchEvent()</code></p><p>这样设计看起来就像一个 U字形 一样</p><h3 id="四种事件"><a href="#四种事件" class="headerlink" title="四种事件"></a>四种事件</h3><p>事件分发中常用的有四个事件（这里暂时只讨论单指触摸）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">MotionEvent.ACTION_DOWN    <span class="hljs-comment">// 手指刚触摸</span><br>MotionEvent.ACTION_MOVE    <span class="hljs-comment">// 手指移动</span><br>MotionEvent.ACTION_UP      <span class="hljs-comment">// 手指抬起</span><br>MotionEvent.ACTION_CANCEL  <span class="hljs-comment">// 事件被提前拦截，只会收到一次</span><br></code></pre></td></tr></table></figure><p>使用的话很简单，固定写法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(event: <span class="hljs-type">MotionEvent</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-comment">// 这个 action 就是得到当前回调时的事件</span><br>    <span class="hljs-keyword">when</span> (event.action) &#123;<br>        MotionEvent.ACTION_DOWN -&gt; &#123;&#125;<br>        MotionEvent.ACTION_MOVE -&gt; &#123;&#125;<br>        MotionEvent.ACTION_UP -&gt; &#123;&#125;<br>        MotionEvent.ACTION_CANCEL -&gt; &#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(event)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>多指触摸的话也就多了几个事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">MotionEvent.ACTION_DOWN            <span class="hljs-comment">// 第一根手指触摸</span><br>MotionEvent.ACTION_POINTER_DOWN    <span class="hljs-comment">// 其他手指触摸</span><br>MotionEvent.ACTION_MOVE            <span class="hljs-comment">// 手指移动（任意一个手指的移动）</span><br>MotionEvent.ACTION_POINTER_UP      <span class="hljs-comment">// 某一根手指抬起</span><br>MotionEvent.ACTION_UP              <span class="hljs-comment">// 最后一根手指抬起</span><br>MotionEvent.ACTION_CANCEL          <span class="hljs-comment">// 事件被前面的拦截</span><br></code></pre></td></tr></table></figure><p>使用与单指触摸大同小异</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(event: <span class="hljs-type">MotionEvent</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br> <span class="hljs-comment">// 这个要换成 actionMasked 才能得到多指触摸事件</span><br> <span class="hljs-keyword">when</span> (event.actionMasked) &#123;<br>     MotionEvent.ACTION_DOWN -&gt; &#123;&#125;<br>     MotionEvent.ACTION_POINTER_DOWN -&gt; &#123;&#125;<br>     MotionEvent.ACTION_MOVE -&gt; &#123;&#125;<br>     MotionEvent.ACTION_POINTER_UP -&gt; &#123;&#125;<br>     MotionEvent.ACTION_UP -&gt; &#123;&#125;<br>     MotionEvent.ACTION_CANCEL -&gt; &#123;&#125;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(event)<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="一些规律"><a href="#一些规律" class="headerlink" title="一些规律"></a>一些规律</h3><ul><li><code>Down</code> 事件用于寻找谁来处理这次事件，然后之后的所有事件都会直接传递给它（期间仍会经过它的父 View），而不会再走 U字形</li><li><code>onInterceptTouchEvent()</code> 只有一次返回 true 的机会，返回 true 后就不会再被调用</li><li>父 View 通过 <code>onInterceptTouchEvent()</code> 返回 true 后，子 View 除了收到一次 <code>Cancel</code> 外，就再也不会收到任何事件</li></ul><p>光听规律你可能会听不懂，接下来我把整个事件分发装换成与生活相关的东西</p><h2 id="事件分发-gt-公司"><a href="#事件分发-gt-公司" class="headerlink" title="事件分发 -&gt; 公司"></a>事件分发 -&gt; 公司</h2><h3 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h3><ul><li>Activity：公司老总</li><li>外层布局：资深程序员 A</li><li>里层布局：中级程序员 B</li><li>底层布局：入门程序员 C</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><code>dispatchTouchEvent</code>：接受到上级需求</li><li><code>onInterceptTouchEvent</code>：是否自己想接手需求</li><li><code>onTouchEvent</code>：自己处理需求</li><li><code>requestDisallowInterceptTouchEvent</code>：签订了合同，防止被公司突然辞退</li></ul><p>对于这个 <code>requestDisallowInterceptTouchEvent</code> 方法可以阻止上层布局调用 <code>onInterceptTouchEvent</code> 方法来拦截事件，看完下面整个流程你就能理解它的作用了</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li><code>Down</code>：衡量需求难度，如果合适就可以接手（决定了需求谁来处理）</li><li><code>Move</code>：上级询问进度（如果进度太慢，可以召回需求自己做）</li><li><code>Up</code>：上级验收成果（这个时候你不一定就做完了需求，因为可能还有动画的执行）</li><li><code>Cancel</code>：辞退事件（因为太菜而被公司辞退）</li></ul><p>因为 Up 事件的调用栈与 Move事件的调用栈基本一致，所以后面不会单独写 Up 事件</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><blockquote><p>为了方便展示，图中 <code>dispatch</code> 表示 <code>dispatchTouchEvent</code>，<code>onIntercept</code> 表示 <code>onInterceptTouchEvent</code>，<code>onTouch</code> 表示 <code>onToushEvent</code></p></blockquote><p>某公司接到一个外包，公司决定让程序员 A 来做这个需求</p><h4 id="先衡量这个这个需求（对应-Down）"><a href="#先衡量这个这个需求（对应-Down）" class="headerlink" title="先衡量这个这个需求（对应 Down）"></a>先衡量这个这个需求（对应 <code>Down</code>）</h4><pre><code class=" mermaid">flowchart TBsubgraph 公司老总id000(&quot;接到一个外包（dispatch）&quot;)id999(&quot;没人做，公司摆烂（onTouch）&quot;)endid000--&gt;id1subgraph 程序员 Aid1(&quot;接受到上级需求（dispatch）&quot;)--&gt;id2id2[&quot;因为太忙不能接手（onIntercept）&quot;]id10[&quot;都没人做，还是直接跑路吧（onTouch）&quot;]endid2--false--&gt;id3subgraph 程序员 Bid3[&quot;接受到上级(程序员 A)需求（dispatch）&quot;]--&gt;id4id4[&quot;因为太麻烦不想接手（onIntercept）&quot;]id8[&quot;我靠，太难了，我做不了（onTouch）&quot;]endid4--false--&gt;id5subgraph 程序员 Cid5[&quot;接受到上级(程序员 B)需求（dispatch）&quot;]--&gt;id6id6[&quot;后面没人了，只能自己硬着头皮做（对应 View 没有 onIntercept 方法）&quot;]--&gt;id7id7[&quot;我没空，别来找我（onTouch）&quot;]endid7--false--&gt;id8id8--false--&gt;id10id10--false--&gt;id999</code></pre><blockquote><p>该图与之前给的 <code>Down</code> 事件的流程图基本一致</p></blockquote><h4 id="上级询问进度（对应-Move）"><a href="#上级询问进度（对应-Move）" class="headerlink" title="上级询问进度（对应 Move）"></a>上级询问进度（对应 <code>Move</code>）</h4><p>上级公司询问接外包的公司，因为没人做需求，所以直接摆烂</p><pre><code class=" mermaid">flowchart TBsubgraph 公司老总id000(&quot;上级询问进度（dispatch）&quot;)--&gt;id999id999(&quot;回复的正在做，但公司在摆烂（onTouch）&quot;)end</code></pre><h4 id="上级验收成果（对应-Up）"><a href="#上级验收成果（对应-Up）" class="headerlink" title="上级验收成果（对应 Up）"></a>上级验收成果（对应 <code>Up</code>）</h4><p>ddl 到了，上级验收成果，调用栈与 <code>Move</code> 事件基本一致</p><pre><code class=" mermaid">flowchart TBsubgraph 公司老总id000(&quot;上级验收成果（dispatch）&quot;)--&gt;id999id999(&quot;外包公司已卷钱跑路（onTouch）&quot;)end</code></pre><h3 id="示例2-Down中拦截"><a href="#示例2-Down中拦截" class="headerlink" title="示例2-Down中拦截"></a>示例2-Down中拦截</h3><p>这次找了一个好一点的公司</p><h4 id="先衡量这个这个需求（对应-Down）-1"><a href="#先衡量这个这个需求（对应-Down）-1" class="headerlink" title="先衡量这个这个需求（对应 Down）"></a>先衡量这个这个需求（对应 <code>Down</code>）</h4><pre><code class=" mermaid">flowchart TBsubgraph 公司老总id000(&quot;接到一个外包（dispatch）&quot;)endid000--&gt;id1subgraph 程序员 Aid1(&quot;接受到上级需求（dispatch）&quot;)--&gt;id2id2[&quot;因为太忙不能接手（onIntercept）&quot;]endid2--false--&gt;id3subgraph 程序员 Bid3[&quot;接受到上级(程序员 A)需求（dispatch）&quot;]--&gt;id4id4[&quot;需求还行，我接手了（onIntercept 拦截）&quot;]--true 开做--&gt;id5[&quot;CV代码中（onTouch）&quot;]endid4-.-xid6subgraph 程序员 Cid6[&quot;没收到需求可做，摆烂中&quot;]end</code></pre><blockquote><p>这一次程序员 B 接手了任务，相当于直接在 <code>onInterceptTouchEvent</code> 中返回 true，代表拦截这个需求，所以 程序员 C 就不能得到这个需求了</p><p>这里符合之前说的一个规律：<code>Down</code> 事件用于寻找谁来处理这次事件</p></blockquote><h4 id="上级询问进度（对应-Move）-1"><a href="#上级询问进度（对应-Move）-1" class="headerlink" title="上级询问进度（对应 Move）"></a>上级询问进度（对应 <code>Move</code>）</h4><p>上级又来询问外包公司进度</p><pre><code class=" mermaid">flowchart TBsubgraph 公司老总id000(&quot;询问进度（dispatch）&quot;)endid000--&gt;id1subgraph 程序员 Aid1[&quot;被询问进度（dispatch）&quot;]--&gt;id2id2[&quot;评审程序员 B 进度（onIntercept）&quot;]endid2--false--&gt;id3subgraph 程序员 Bid3[&quot;被询问进度（dispatch）&quot;]--&gt;id5id5[&quot;还在继续CV代码中（onTouch）&quot;]endsubgraph 程序员 Cid6[&quot;仍在摆烂中&quot;]end</code></pre><blockquote><p><strong>注意:</strong> 程序员 B 只有两步，与之前少了一步 <code>onIntercept</code> 拦截，就符合刚开始讲的那个规律：<code>onInterceptTouchEvent() 只有一次返回 true 的机会，返回 true 后就不会再被调用</code></p><p>而程序员 C 因为开始时就因为被 B 提前抢了需求，所以就收不到任何信息，只能一直摆烂</p></blockquote><h4 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h4><p><code>Down</code> 事件决定了之后所有的事件由谁来处理</p><p>但如果我让父布局中途拦截事件该怎们办？这个需求只能在 <code>Move</code> 事件中才能实现了</p><h3 id="示例3-Move中拦截"><a href="#示例3-Move中拦截" class="headerlink" title="示例3-Move中拦截"></a>示例3-Move中拦截</h3><p>我们在示例2上加一些突发情况，比如在询问进度时，程序员 A 发现 程序员 B 做得太拉，把他辞退了，自己来做。</p><p>如果用代码表示的话就是在 <code>Move</code> 事件中，程序员 A 的 <code>onIntercept</code> 方法返回了 true，此时整个事件树就会变为：</p><pre><code class=" mermaid">flowchart TBsubgraph 公司老总id000(&quot;询问进度（dispatch）&quot;)endid000--&gt;id1subgraph 程序员 Aid1[&quot;被询问进度（dispatch）&quot;]--&gt;id2id2[&quot;评审程序员 B 进度（onIntercept）&quot;]--发现做得太烂--&gt;id3id3[&quot;召回需求，自己来做（onTouch）&quot;]endid2--触发辞退Cancel事件--&gt;idbsubgraph 程序员 Bidb[&quot;做辞退前的工作（onTouch）&quot;]endsubgraph 程序员 Cidc[&quot;仍在摆烂中&quot;]end</code></pre><p>之后的事件就只有程序员 A 在做了，并且因为程序员 B 被辞退，所以程序员 A 就不会再次查看程序员 B 的进度，这里也满足 <code>onIntercept</code> 只有一次返回 true 的机会</p><pre><code class=" mermaid">flowchart TBsubgraph 公司老总id000(&quot;询问进度（dispatch）&quot;)endid000--&gt;id1subgraph 程序员 Aid1[&quot;被询问进度（dispatch）&quot;]--&gt;id3id3[&quot;重构程序员 B 代码中（onTouch）&quot;]endsubgraph 程序员 Bidb[&quot;无业游民&quot;]endsubgraph 程序员 Cidc[&quot;仍在摆烂中&quot;]end</code></pre><p>在 <code>Move</code> 中父布局想拦截子布局事件，就直接在 <code>onIntercept</code> 中返回 true 就可以了</p><p>其实这种突发事件在很多控件源码中都有实现，只是如果你没有深入探究的话可能不会发现</p><blockquote><p>比如：<code>ScrollView</code> 中有一个 <code>Button</code></p><p>之前我们谈到 <code>Down</code> 事件决定了谁来处理，那么我的 <code>Down</code> 只能交给 <code>Button</code> 去拦截，<code>ScrollView</code> 不能在 <code>Down</code> 中拦截事件（即 <code>onIntercept</code> 返回 true）</p><p>而如果你在按住的短时间内上下滑动一定的距离，<code>ScrollView</code> 就会在 <code>Move</code> 中拦截 <code>Button</code> 的事件</p><p>至于短时间有好短，一定距离有好一定，我们后面从源码中再进行解析</p></blockquote><h3 id="示例4-防止被辞退"><a href="#示例4-防止被辞退" class="headerlink" title="示例4-防止被辞退"></a>示例4-防止被辞退</h3><p>上面我们讲了在 <code>Move</code> 中辞退他人的情况（在 <code>Move</code> 中拦截子布局事件），这种情况很常见，但如何实现不让父布局拦截呢？其实官方提供了一个方法专门用于这种情况：<code>requestDisallowInterceptTouchEvent</code>，在例子中，你可以把它想象成签订了合同</p><pre><code class=" mermaid">flowchart TBsubgraph 公司老总id000(&quot;接到一个外包（dispatch）&quot;)endid000--&gt;id1subgraph 程序员 Aid1(&quot;接受到上级需求（dispatch）&quot;)--&gt;id2id2[&quot;因为太忙不能接手（onIntercept）&quot;]endid2--false--&gt;id3subgraph 程序员 Bid3[&quot;接受到上级(程序员 A)需求（dispatch）&quot;]--&gt;id4id4[&quot;太麻烦不想接手（onIntercept 拦截）&quot;]endid4--false--&gt;id6subgraph 程序员 Cid6[&quot;接受到上级(程序员 B)需求（dispatch）&quot;]--true--&gt;id7id7[&quot;接手这个需求（onTouch）&quot;]--&gt;id[&quot;签订针对于该次需求的合同（requestDisallow）&quot;]end</code></pre><p>上面的图是在 <code>Down</code> 事件中签订的（也可以在 <code>Move</code> 中签订），签订过后，之后询问进度时（<code>Move</code> 事件）都会变化</p><pre><code class=" mermaid">flowchart TBsubgraph 公司老总id000(&quot;询问进度（dispatch）&quot;)endid000--&gt;id1subgraph 程序员 Aid1[&quot;被询问进度（dispatch）&quot;]endid1--&gt;id4subgraph 程序员 Bid4[&quot;被询问进度（dispatch）&quot;]endid4--&gt;id6subgraph 程序员 Cid6[&quot;被询问进度（dispatch）&quot;]--&gt;id7id7[&quot;还在CV代码中（onTouch）&quot;]end</code></pre><p>可以发现程序员 A 和程序员 B 都直接少了评审的步骤，这样 程序员 C 就可以安心 CV 代码了</p><blockquote><p><code>requestDisallowInterceptTouchEvent</code> 方法的注意事项</p><ul><li>这个方法虽然是签的合同，但不是终身合同，合同最长有效期只有这次需求结束，即下一次需求需要重新签订（下一次 <code>Down</code> 事件需要重新调用该方法）</li><li>可以随时撕毁该合同，然后回归到程序员 A 每次都评审代码</li><li>签订合同后是所有上级都不能评审代码了</li><li>只能在签订人 <code>dispatchTouchEvent</code> 调用后才能签订，因为 <code>dispatchTouchEvent</code> 的 <strong><code>Down</code> 事件</strong>会强制清空所有合同</li></ul><p>灵活运用这个方法，你就可以解决一些常见的滑动冲突了</p><p>比如：之前我们提到 <code>ScrollView</code> 中有一个 <code>Button</code>，如果我们想实现只要手指触摸 <code>Button</code> 就不允许 <code>ScrollView</code> 滚动。直接在 <code>Button</code> 收到的 <code>Down</code> 事件调用 <code>requestDisallowInterceptTouchEvent </code>即可</p></blockquote><h3 id="普通滑动小结"><a href="#普通滑动小结" class="headerlink" title="普通滑动小结"></a>普通滑动小结</h3><p>详细的滑动事件分发图可以去看我当时画的整个流程图：<a href="https://www.processon.com/view/link/6191f797079129330ada2bd7">https://www.processon.com/view/link/6191f797079129330ada2bd7</a></p><p>这里因为图片太大看不清楚</p><p><img src="http://processon.com/chart_image/60955dcfe0b34d254ce7de8d.png"></p><h2 id="嵌套滑动"><a href="#嵌套滑动" class="headerlink" title="嵌套滑动"></a>嵌套滑动</h2><p>前面简单讲解了普通滑动的流程，如果你仔细思考会发现一个普通滑动有一个较严重的缺点：一旦父布局拦截了事件，子布局就再也不能收到事件（对应被辞退后总不能再召回来吧）</p><p>官方也意识到了这个问题，所以推出了嵌套滑动的解决方案</p><p>为了更好的兼容以前的 Android 版本，嵌套滑动最开始是以扩展包发布的，原理就是从底层 View 往上寻找需要嵌套滑动的 View，然后把事件传递给它</p><h3 id="NestedScrollingChild2"><a href="#NestedScrollingChild2" class="headerlink" title="NestedScrollingChild2"></a>NestedScrollingChild2</h3><p>嵌套滑动的事件发送者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyView1</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context,<br>    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>,<br>    defStyleRes: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : View(context, attrs, defStyleAttr, defStyleRes), NestedScrollingChild2 &#123;<br>    <span class="hljs-comment">// 开始嵌套滑动，不是回调，是你在合适的位置自己调用</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startNestedScroll</span><span class="hljs-params">(axes: <span class="hljs-type">Int</span>, type: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 结束嵌套滑动，也不是回调，自己调用</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">stopNestedScroll</span><span class="hljs-params">(type: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 是否有嵌套的接收者</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hasNestedScrollingParent</span><span class="hljs-params">(type: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 分发自己处理后的事件</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchNestedScroll</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        dxConsumed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dyConsumed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dxUnconsumed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dyUnconsumed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        offsetInWindow: <span class="hljs-type">IntArray</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        type: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 分发自己处理前的事件</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchNestedPreScroll</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        dx: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dy: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        consumed: <span class="hljs-type">IntArray</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        offsetInWindow: <span class="hljs-type">IntArray</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        type: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然看着要实现的方法有很多，但其实官方专门写了一个帮助类 <code>NestedScrollingChildHelper</code>，你只需要在合适的位置调用上面的几个方法就可以了，具体怎么实现需要你们自己去看官方的源码了，因为一般情况下不会自己去写嵌套滑动的事件发送者，所以我就不讲了</p><p>这里给出一些文章：<a href="https://blog.csdn.net/ListerCi/article/details/103849417?spm=1001.2101.3001.6650.9&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-9.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-9.pc_relevant_paycolumn_v3&utm_relevant_index=11">Android - 有趣的嵌套滑动</a></p><h3 id="NestedScrollingParent2"><a href="#NestedScrollingParent2" class="headerlink" title="NestedScrollingParent2"></a>NestedScrollingParent2</h3><p>嵌套滑动的事件接收者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyViewGroup1</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context,<br>    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>,<br>    defStyleRes: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : FrameLayout(context, attrs, defStyleAttr, defStyleRes), NestedScrollingParent2 &#123;<br>    <span class="hljs-comment">// 嵌套滑动开始，用于返回是否关联此次触摸事件（需求）</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStartNestedScroll</span><span class="hljs-params">(child: <span class="hljs-type">View</span>, target: <span class="hljs-type">View</span>, axes: <span class="hljs-type">Int</span>, type: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 上一个返回 true 后就会被回调</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNestedScrollAccepted</span><span class="hljs-params">(child: <span class="hljs-type">View</span>, target: <span class="hljs-type">View</span>, axes: <span class="hljs-type">Int</span>, type: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 嵌套滑动结束</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStopNestedScroll</span><span class="hljs-params">(target: <span class="hljs-type">View</span>, type: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 嵌套滑动处理事件，在发送者处理后再处理</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNestedScroll</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        target: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dxConsumed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dyConsumed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dxUnconsumed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        dyUnconsumed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        type: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 嵌套滑动处理事件，在发送者处理前处理</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNestedPreScroll</span><span class="hljs-params">(target: <span class="hljs-type">View</span>, dx: <span class="hljs-type">Int</span>, dy: <span class="hljs-type">Int</span>, consumed: <span class="hljs-type">IntArray</span>, type: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与 <code>NestedScrollingChild2</code> 一样，官方也有一个帮助类 <code>NestedScrollingParentHelper</code></p><p><code>NestedScrollingParent2</code> 是嵌套滑动中用得最多的，理解了它每个方法的回调时机，你就能很快学会嵌套滑动了</p><pre><code class=" mermaid">sequenceDiagramalt DownChild-&gt;&gt;Child:onInterceptTouch()Child-&gt;&gt;Parent:startNestedScroll(TYPE_TOUCH)Parent-&gt;&gt;Parent:onStartNestedScroll()Parent-&gt;&gt;Parent:onNestedScrollAccepted()else MoveChild-&gt;&gt;Child:onTouchEvent()Child-&gt;&gt;Parent:自身消费前 dispatchNestedPreScroll(IntArray)Parent-&gt;&gt;Parent:IntArray[0] = 100, IntArray[1] = 100 消费一些距离Child-&gt;&gt;Child:先减去 IntArray，再自身消费Child-&gt;&gt;Parent:还剩一些距离 dispatchNestedScroll()else 惯性滑动Child-&gt;&gt;Parent:startNestedScroll(TYPE_NON_TOUCH)else UpChild-&gt;&gt;Parent:stopNestedScroll(TYPE_TOUCH)else 惯性滑动Child-&gt;&gt;Parent:自身消费前 dispatchNestedPreScroll(IntArray)Parent-&gt;&gt;Parent:IntArray[0] = 100, IntArray[1] = 100 消费一些距离Child-&gt;&gt;Child:先减去 IntArray，再自身消费Child-&gt;&gt;Parent:还剩一些距离 dispatchNestedScroll()Child-&gt;&gt;Parent:stopNestedScroll(TYPE_NON_TOUCH)end</code></pre><p>这里面要注意以下几点：</p><ul><li>1版本的 <code>NestedScrollingChild</code> 和 <code>NestedScrollingParent</code> 因为设计的原因，只会收到非惯性事件，不能得到惯性事件</li><li>2版本的嵌套滑动包含了惯性滑动，所以 <code>onStartNestedScroll</code> 会回调两次，并且惯性滑动的开始会在非惯性滑动的 <code>onStopNestedScroll</code> 前调用</li></ul><h2 id="NestedScrollView-源码简单分析"><a href="#NestedScrollView-源码简单分析" class="headerlink" title="NestedScrollView 源码简单分析"></a>NestedScrollView 源码简单分析</h2><h3 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent"></a>onInterceptTouchEvent</h3><p>之前我们讲到这里是是否拦截事件的地方，我们先从 <code>Down</code> 事件开始看起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN: &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ev.getY();<br>    <span class="hljs-keyword">if</span> (!inChild((<span class="hljs-type">int</span>) ev.getX(), y)) &#123; <span class="hljs-comment">// 如果触摸点不在子 View 范围内</span><br>        mIsBeingDragged = stopGlowAnimations(ev) || !mScroller.isFinished();<br>        recycleVelocityTracker();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 记录触摸的 y 值</span><br>    mLastMotionY = y;<br>    <span class="hljs-comment">// 记录触摸手指的 id</span><br>    mActivePointerId = ev.getPointerId(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 初始化速率追踪器</span><br>    initOrResetVelocityTracker();<br>    <span class="hljs-comment">// 给速度追踪器添加事件</span><br>    mVelocityTracker.addMovement(ev);<br>    <br>    <span class="hljs-comment">// 让 OverScroller 计算一次值</span><br>    mScroller.computeScrollOffset();<br>    <span class="hljs-comment">// 是否还处于上次抬手后的惯性滑动中，在下面 Move 中会用到</span><br>    mIsBeingDragged = stopGlowAnimations(ev) || !mScroller.isFinished();<br>    <span class="hljs-comment">// 开启嵌套滑动</span><br>    startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, ViewCompat.TYPE_TOUCH);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// Down 中并没有直接 return true，意思是 ScrollView 并没有在 Down 时直接拦截事件</span><br></code></pre></td></tr></table></figure><p><code>Move</code> 是最重要的一部分，里面的逻辑实现了之前我们讲到的 <code>Button</code> 与 <code>ScrollView</code> 的问题</p><p><strong>在分析 onIntercept 的 Move 前我们必须要提出两个前提条件：</strong></p><ul><li><strong>1、子 View 没有在 <code>Down</code> 中调用 <code>requestDisallow</code> 去禁止父布局拦截事件</strong></li><li><strong>2、子 View 一定会在 <code>Down</code> 是拦截或处理事件，即子 View 的 <code>onIntercept</code> 或者 <code>onTouchEvent</code> 返回 true</strong></li><li>至于原因我们在后面进行分析</li><li>这里补充说明：<code>Button</code> 这类控件就符合上面这两个条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Move 事件一共分为两种情况</span><br><br><span class="hljs-comment">// 第一种：mIsBeingDragged = true</span><br><span class="hljs-comment">// 这个时候说明处于上次抬手后的惯性滑动中</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> ev.getAction();<br><span class="hljs-keyword">if</span> ((action == MotionEvent.ACTION_MOVE) &amp;&amp; mIsBeingDragged) &#123;<br>    <span class="hljs-comment">// 于是就直接返回 true，意思就是直接交给 ScrollView 拦截处理事件</span><br>    <span class="hljs-comment">// 别忘了之前我们讲过 onIntercept 只有一次返回 true 的机会，之后就不会再调用 onIntercept</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 第二种：常见的情况</span><br><span class="hljs-keyword">switch</span> (action &amp; MotionEvent.ACTION_MASK) &#123;<br>    <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>        <br>        <span class="hljs-comment">// 这里是检测之前 Down 事件触摸的手指是否是稳定的 id，一般不会遇到这种情况</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">activePointerId</span> <span class="hljs-operator">=</span> mActivePointerId;<br>        <span class="hljs-keyword">if</span> (activePointerId == INVALID_POINTER) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 这里与上面的意义一样</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">pointerIndex</span> <span class="hljs-operator">=</span> ev.findPointerIndex(activePointerId);<br>        <span class="hljs-keyword">if</span> (pointerIndex == -<span class="hljs-number">1</span>) &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;Invalid pointerId=&quot;</span> + activePointerId<br>                    + <span class="hljs-string">&quot; in onInterceptTouchEvent&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 记录 y 值</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ev.getY(pointerIndex);<br>        <span class="hljs-comment">// 记录移动的距离</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">yDiff</span> <span class="hljs-operator">=</span> Math.abs(y - mLastMotionY);<br>        <br>        <span class="hljs-comment">// 这个判断很重要</span><br>        <span class="hljs-comment">// 这里整块的作用如下：</span><br>        <span class="hljs-comment">// 如果移动的距离超过了 mTouchSlop，就直接拦截事件，并调用 requestDisallow 禁止父布局拦截事件</span><br>        <span class="hljs-keyword">if</span> (yDiff &gt; mTouchSlop<br>                &amp;&amp; (getNestedScrollAxes() &amp; ViewCompat.SCROLL_AXIS_VERTICAL) == <span class="hljs-number">0</span>) &#123;<br>            mIsBeingDragged = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 设置返回值为 true，即代表拦截事件</span><br>            mLastMotionY = y;<br>            initVelocityTrackerIfNotExists();<br>            mVelocityTracker.addMovement(ev);<br>            mNestedYOffset = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ViewParent</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> getParent();<br>            <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 禁止父布局拦截事件</span><br>                parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 就是这个 if 实现了之前我们提到的触摸 Button 在上下移动却能使 ScrollView 滚动的原因</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 后面是其他事件的判断</span><br> <span class="hljs-keyword">return</span> mIsBeingDragged; <span class="hljs-comment">// 最后是返回的 mIsBeingDragged，如果为 true，就会直接进入 onTouchEvent</span><br> <span class="hljs-comment">// 上面拦截过后，子 View 会收到一次 Cancel 事件</span><br></code></pre></td></tr></table></figure><p>上面提到了这个 <code>mTouchSlop</code>，这是官方定义的“认为是滚动的最小移动距离”，除了 <code>ScrollView</code> 以外，<code>RecyclerView</code> 等一系列可以滚动的 <code>View</code> 都使用了它，它是一个常量（虽然是个常量，但它是根据不同的手机去调整的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个 ViewConfiguration 里面包含了很多 View 相关的常量，</span><br><span class="hljs-comment">// 如：长按的等待时间、打开侧边栏锁需要的边距值、惯性滑动的最小速度、惯性滑动的最大速度等</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">ViewConfiguration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> ViewConfiguration.get(getContext());<br>mTouchSlop = configuration.getScaledTouchSlop();<br></code></pre></td></tr></table></figure><p>在 <code>Move</code> 的代码很简单，主要就是判断是否拦截，这里一定要记住 <code>onIntercept</code> 只有一次拦截的机会，拦截后就不会再被调用，所以后面的 <code>Up</code> 时间就没有必要继续看了</p><h3 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h3><p>如果按照正常的思维，我们应该直接从 <code>Down</code> 事件开始分析，但之前我们提出了一个前提条件，所以 <code>onTouchEvent </code> 的 <code>Down</code> 事件是不会被调用的。</p><p>然后根据前面的前提条件，在 <code>ScrollView</code> 的移动距离超过了 <code>mTouchSlop</code>，<code>onTouchEvent</code> 就被调用，而因为前面是在 <code>Move</code> 中才拦截，则 <code>onTouchEvent</code> 只会收到 <code>Move</code> 后的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 代码很长，我们只分析重要的几部分</span><br><br><span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">activePointerIndex</span> <span class="hljs-operator">=</span> ev.findPointerIndex(mActivePointerId);<br>    <span class="hljs-keyword">if</span> (activePointerIndex == -<span class="hljs-number">1</span>) &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;Invalid pointerId=&quot;</span> + mActivePointerId + <span class="hljs-string">&quot; in onTouchEvent&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ev.getY(activePointerIndex);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">deltaY</span> <span class="hljs-operator">=</span> mLastMotionY - y;<br>    deltaY -= releaseVerticalGlow(deltaY, ev.getX(activePointerIndex));<br><br><span class="hljs-comment">// 你会发现这里有判断了 mIsBeingDragged，并且后面又调用了 requestDisallow</span><br><span class="hljs-comment">// 其实这就与之前我给出的前提条件相关，如果给出的前提条件，这里是不会进入 if 分支的</span><br><span class="hljs-comment">// 这个分支我们之后会再次提到</span><br>    <span class="hljs-keyword">if</span> (!mIsBeingDragged &amp;&amp; Math.abs(deltaY) &gt; mTouchSlop) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ViewParent</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> getParent();<br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>            parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>);<br>        &#125;<br>        mIsBeingDragged = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (deltaY &gt; <span class="hljs-number">0</span>) &#123;<br>            deltaY -= mTouchSlop;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            deltaY += mTouchSlop;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 如果处于拖动的状态</span><br>    <span class="hljs-keyword">if</span> (mIsBeingDragged) &#123;<br>        <span class="hljs-comment">// 分发嵌套滑动，这里是在自身处理前分发的</span><br>        <span class="hljs-keyword">if</span> (dispatchNestedPreScroll(<span class="hljs-number">0</span>, deltaY, mScrollConsumed, mScrollOffset,<br>                ViewCompat.TYPE_TOUCH)) &#123;<br>            <span class="hljs-comment">// 减去接收者消耗的距离</span><br>            deltaY -= mScrollConsumed[<span class="hljs-number">1</span>];<br>            mNestedYOffset += mScrollOffset[<span class="hljs-number">1</span>];<br>        &#125;<br>        mLastMotionY = y - mScrollOffset[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">oldY</span> <span class="hljs-operator">=</span> getScrollY();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> getScrollRange();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">overscrollMode</span> <span class="hljs-operator">=</span> getOverScrollMode();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">canOverscroll</span> <span class="hljs-operator">=</span> overscrollMode == View.OVER_SCROLL_ALWAYS<br>                || (overscrollMode == View.OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp; range &gt; <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">// 这里是处理滚动的核心方法</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">clearVelocityTracker</span> <span class="hljs-operator">=</span><br>                overScrollByCompat(<span class="hljs-number">0</span>, deltaY, <span class="hljs-number">0</span>, getScrollY(), <span class="hljs-number">0</span>, range, <span class="hljs-number">0</span>,<br>                        <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>) &amp;&amp; !hasNestedScrollingParent(ViewCompat.TYPE_TOUCH);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">scrolledDeltaY</span> <span class="hljs-operator">=</span> getScrollY() - oldY;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">unconsumedY</span> <span class="hljs-operator">=</span> deltaY - scrolledDeltaY;<br>        mScrollConsumed[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 再次分发嵌套滑动，这里是在自身处理后分发的</span><br>        dispatchNestedScroll(<span class="hljs-number">0</span>, scrolledDeltaY, <span class="hljs-number">0</span>, unconsumedY, mScrollOffset,<br>                ViewCompat.TYPE_TOUCH, mScrollConsumed);<br>        mLastMotionY -= mScrollOffset[<span class="hljs-number">1</span>];<br>        mNestedYOffset += mScrollOffset[<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-comment">// 这下面是一些不重要的代码</span><br>        <span class="hljs-keyword">if</span> (canOverscroll) &#123;<br>            deltaY -= mScrollConsumed[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">pulledToY</span> <span class="hljs-operator">=</span> oldY + deltaY;<br>            <span class="hljs-keyword">if</span> (pulledToY &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// ScrollView 的滑到边界时有个影子，就是它绘制出来的</span><br>                EdgeEffectCompat.onPullDistance(mEdgeGlowTop,<br>                        (<span class="hljs-type">float</span>) -deltaY / getHeight(),<br>                        ev.getX(activePointerIndex) / getWidth());<br>                <span class="hljs-keyword">if</span> (!mEdgeGlowBottom.isFinished()) &#123;<br>                    mEdgeGlowBottom.onRelease();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pulledToY &gt; range) &#123;<br>                EdgeEffectCompat.onPullDistance(mEdgeGlowBottom,<br>                        (<span class="hljs-type">float</span>) deltaY / getHeight(),<br>                        <span class="hljs-number">1.f</span> - ev.getX(activePointerIndex) / getWidth());<br>                <span class="hljs-keyword">if</span> (!mEdgeGlowTop.isFinished()) &#123;<br>                    mEdgeGlowTop.onRelease();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished()) &#123;<br>                <br>                ViewCompat.postInvalidateOnAnimation(<span class="hljs-built_in">this</span>);<br>                clearVelocityTracker = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (clearVelocityTracker) &#123;<br>            mVelocityTracker.clear();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p><code>onTouchEvent</code> 的 <code>Move</code> 就分析完了，后面就是 <code>Up</code> 事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">VelocityTracker</span> <span class="hljs-variable">velocityTracker</span> <span class="hljs-operator">=</span> mVelocityTracker;<br><span class="hljs-comment">// 计算速度</span><br>    velocityTracker.computeCurrentVelocity(<span class="hljs-number">1000</span>, mMaximumVelocity);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">initialVelocity</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) velocityTracker.getYVelocity(mActivePointerId);<br><span class="hljs-comment">// 如果抬手时的速度大于惯性滑动的最小速度</span><br>    <span class="hljs-keyword">if</span> ((Math.abs(initialVelocity) &gt;= mMinimumVelocity)) &#123;<br>        <span class="hljs-keyword">if</span> (!edgeEffectFling(initialVelocity)<br>                &amp;&amp; !dispatchNestedPreFling(<span class="hljs-number">0</span>, -initialVelocity)) &#123;<br>            <span class="hljs-comment">// 分发嵌套的惯性滑动，上面 dispatchNestedPreFling 也是一样</span><br>            dispatchNestedFling(<span class="hljs-number">0</span>, -initialVelocity, <span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">// 惯性滑动的核心方法</span><br>            fling(-initialVelocity);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mScroller.springBack(getScrollX(), getScrollY(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>            getScrollRange())) &#123;<br>        <span class="hljs-comment">// 这里是判断能否直接滑到顶部或底部，如果能的话，即直接滚过去</span><br>        ViewCompat.postInvalidateOnAnimation(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    mActivePointerId = INVALID_POINTER;<br><span class="hljs-comment">// 结束滚动，这里面调用了惯性滑动的 stopNestedScroll</span><br><span class="hljs-comment">// 上面是先调用的惯性滑动，再结束非惯性滑动，所以符合我们最开始提到的</span><br>    <span class="hljs-comment">// 惯性滑动的开始会在非惯性滑动的 onStopNestedScroll 前调用</span><br>    endDrag();<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>这就是 <code>Button</code> 在 <code>ScrollView</code> 中嵌套时的事件处理，我们再来看一下前提条件：</p><ul><li>1、子 View 没有在 <code>Down</code> 中调用 <code>requestDisallow</code> 去禁止父布局拦截事件</li><li>2、子 View 一定会在 <code>Down</code> 是拦截或处理事件，即子 View 的 <code>onIntercept</code> 或者 <code>onTouchEvent</code> 返回 true</li></ul><p>首先看第一个，这个得原因很简单，因为调用了 <code>requestDisallow </code> 后，父 View 的 <code>onIntercept</code> 就不会被调用</p><p>如果是第二个，这个就得看之前我们画的流程图</p><pre><code class=" mermaid">flowchart TBsubgraph activityid000(&quot;dispatchTouchEvent&quot;)id999(&quot;onTouchEvent&quot;)endid000(&quot;dispatchTouchEvent&quot;)--&gt;id1subgraph ViewGroup1id1[&quot;dispatchTouchEvent&quot;]--&gt;id2id2&#123;&quot;onIntercept&quot;&#125;--拦截--&gt;id3id3[&quot;onTouchEvent&quot;]--&gt;over0((over))endid2&#123;&quot;onIntercept&quot;&#125;--不拦截--&gt;id4subgraph ViewGroup2id4(&quot;dispatchTouchEvent&quot;)--&gt;id5id5&#123;&quot;onIntercept&quot;&#125;--拦截--&gt;id6id6[&quot;onTouchEvent&quot;]--&gt;over1((over))endid5&#123;&quot;onIntercept&quot;&#125;--不拦截--&gt;id7subgraph Viewid7(&quot;dispatchTouchEvent&quot;)--&gt;id8id8&#123;&quot;onTouchEvent&quot;&#125;id8--true--&gt;over2((over))endsubgraph ViewGroup2id8--false--&gt;id9id9&#123;&quot;onTouchEvent&quot;&#125;--true--&gt;over3((over))endsubgraph ViewGroup1id9--false--&gt;id10id10&#123;&quot;onTouchEvent&quot;&#125;--true--&gt;over4((over))endid10--false--&gt;id999</code></pre><p>如图，如果子 View 的 <code>onIntercept</code> 或者 <code>onTouchEvent</code> 没有返回 true，那么 <code>Down</code> 事件会重新回到 <code>ScrollView</code> 的 <code>onTouchEvent</code> 中，我们分析一下 <code>onTouchEvent</code> 的 <code>Down</code> 事件，记住，此时 mIsBeingDragged &#x3D; false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN: &#123;<br>    <span class="hljs-keyword">if</span> (getChildCount() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不会走这分支</span><br>    <span class="hljs-keyword">if</span> (mIsBeingDragged) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ViewParent</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> getParent();<br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>            parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果处于上次抬手后的惯性滑动中</span><br>    <span class="hljs-keyword">if</span> (!mScroller.isFinished()) &#123;<br>        <span class="hljs-comment">// 禁止惯性滑动，并且里面调用了 stopNestedScroll，通知嵌套滑动的惯性滑动结束</span><br>        abortAnimatedScroll();<br>    &#125;<br>    mLastMotionY = (<span class="hljs-type">int</span>) ev.getY();<br>    mActivePointerId = ev.getPointerId(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 开启嵌套滑动</span><br>    startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, ViewCompat.TYPE_TOUCH);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 最后你会发现 onTouchEvent 直接返回 true，即代表拦截事件，不把事件继续向上传递</span><br><span class="hljs-comment">// 竟然这里返回 true 后，那么之后的 Move 事件会怎么走呢？</span><br><span class="hljs-comment">// 这里因为是从下往上传递，在这里返回 true，就相当于你在 onIntercept 中返回 true，</span><br><span class="hljs-comment">// 之后也不会再调用 onIntercept，事件从 activity -&gt; 父父View -&gt; 父View -&gt; ScrollView，</span><br><span class="hljs-comment">// 与你在 onIntercept 中返回 true 保持一致</span><br></code></pre></td></tr></table></figure><p>然后我们在看一下之前留下的 <code>onTouchEvent</code> 中 <code>Move</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">activePointerIndex</span> <span class="hljs-operator">=</span> ev.findPointerIndex(mActivePointerId);<br>    <span class="hljs-keyword">if</span> (activePointerIndex == -<span class="hljs-number">1</span>) &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;Invalid pointerId=&quot;</span> + mActivePointerId + <span class="hljs-string">&quot; in onTouchEvent&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ev.getY(activePointerIndex);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">deltaY</span> <span class="hljs-operator">=</span> mLastMotionY - y;<br>    deltaY -= releaseVerticalGlow(deltaY, ev.getX(activePointerIndex));<br><br><span class="hljs-comment">// 这里就是之前留下的，此时才会走进这个分支</span><br>    <span class="hljs-comment">// 此时 mIsBeingDragged = false，如果在滑动距离大于 mTouchSlop 时</span><br>    <span class="hljs-keyword">if</span> (!mIsBeingDragged &amp;&amp; Math.abs(deltaY) &gt; mTouchSlop) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ViewParent</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> getParent();<br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 禁止父布局拦截事件</span><br>            parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-comment">// 设置 mIsBeingDragged = true</span><br>        mIsBeingDragged = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (deltaY &gt; <span class="hljs-number">0</span>) &#123;<br>            deltaY -= mTouchSlop;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            deltaY += mTouchSlop;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 如果处于拖动的状态</span><br>    <span class="hljs-keyword">if</span> (mIsBeingDragged) &#123;<br>        <span class="hljs-comment">// 这里跟之前分析的一样了</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>OK，<code>ScrollView</code> 的源码分析就到此了，除了 <code>ScrollView</code> 外还有 <code>RecyclerView</code> 这些基本思路都是一样的，先把事件分发给子 View，然后在 <code>Move</code> 超过了 <code>mTouchSlop</code> 后拦截事件，期间子 View 可以通过 <code>requestDisallow</code> 来禁止他们的拦截</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="onTouchEvent方法报黄"><a href="#onTouchEvent方法报黄" class="headerlink" title="onTouchEvent方法报黄"></a>onTouchEvent方法报黄</h3><blockquote><p>在重写 <code>onTouchEvent</code> 方法的时候会报黄，提示原因：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Custom</span> view MyView1 overrides <span class="hljs-literal">on</span>TouchEvent but not performClick<br></code></pre></td></tr></table></figure><p>意思就是你重写了这个方法却没有重写和调用 <code>performClick</code>，为什么要重写和调用呢？</p><p>重写时可以不需要的，但如果不调用的话，你的 View 在 <code>setOnClickListener</code> 时会无效，查看 View 源码你就会知道，点击事件是在 <code>onTouchEvent</code> 的 <code>Up</code> 事件时调用，你重写了，如果不调用 super，设置的点击监听就失效了</p><p>但一般都自定义 View 了，还要什么官方的点击事件（一般都自己写方法向外提供），我的建议是直接加上注解取消报黄即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@SuppressLint(<span class="hljs-string">&quot;ClickableViewAccessibility&quot;</span>)</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(event: <span class="hljs-type">MotionEvent</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(event)<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a>VelocityTracker</h3><blockquote><p>速率追踪器，一个计算滑动速度的帮助类，官方源码中出现的很多</p></blockquote><h3 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h3><blockquote><p>手势识别器，整合了一系列的长按、滑动等操作，自定义黑书上有讲解</p><p>但这个一般是用于 <code>View</code> 中单独使用，算是一个处理滑动的工具，一般不用来解决滑动冲突</p></blockquote><h3 id="OverScroller"><a href="#OverScroller" class="headerlink" title="OverScroller"></a>OverScroller</h3><blockquote><p>专门处理滑动距离和速度的一个工具类，如果你想实现惯性滑动等效果，可以试试它</p><p><code>ScrollView</code> 和 <code>RecyclerView</code> 中的滑动距离都是依靠它来计算的</p></blockquote><h3 id="setOnTouchListener"><a href="#setOnTouchListener" class="headerlink" title="setOnTouchListener"></a>setOnTouchListener</h3><blockquote><p>设置触摸监听</p><p>作用于 View 中自带的 <code>onTouchEvent</code> 方法基本一致</p><p>但要注意的是他会先调用 <code>OnTouchListener</code>，如果你返回 true，就不会回调 <code>onTouchEvent</code> 了</p></blockquote><h3 id="自定义-Behavior"><a href="#自定义-Behavior" class="headerlink" title="自定义 Behavior"></a>自定义 Behavior</h3><blockquote><p>其实这个只要你理解了嵌套滑动，就能很快学会它</p><p>嵌套滑动一般需要自己去重写 <code>View</code> 才能使用，但使用 <code>Behavior</code> 就可以省去这个过程，协调者布局直接管理整个滑动事件分发，将你的 <code>View</code> 与 <code>Behavior</code> 进行绑定，间接实现了嵌套滑动的处理，达到解耦的效果</p><p>之前廖老师想实现 BottomSheetBehavior + Vp2 + Rv 的效果，但官方的 <code>BottomSheetBehavior</code> 有点坑，它只能跟第一个子布局进行嵌套滑动，导致官方的无法实现理想的效果</p><p>然后我写了一个自定义 <code>BottomSheetBehavior</code>：<a href="https://github.com/985892345/BottomSheetTest">https://github.com/985892345/BottomSheetTest</a></p></blockquote><h3 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h3><p>一般我们会实现一些长按移动整个 View 的操作，官方提供了两个东西</p><p>推荐文章地址：<a href="https://blog.csdn.net/qq_31339141/article/details/107597055">https://blog.csdn.net/qq_31339141/article/details/107597055</a></p><h4 id="OnDragListener"><a href="#OnDragListener" class="headerlink" title="OnDragListener"></a>OnDragListener</h4><blockquote><p>拖放的监听</p><p>文章地址：<a href="https://juejin.cn/post/7062961027578757156?share_token=df84e073-fe9b-4ee4-a240-02373939c9ec">https://juejin.cn/post/7062961027578757156?share_token=df84e073-fe9b-4ee4-a240-02373939c9ec</a></p><p>有个还在测试的 jetpack 的库：<a href="https://developer.android.google.cn/jetpack/androidx/releases/draganddrop">draganddrop</a></p></blockquote><h4 id="ViewDragHelper"><a href="#ViewDragHelper" class="headerlink" title="ViewDragHelper"></a>ViewDragHelper</h4><blockquote><p>你可以把这个认为是 <code>OnDragListener</code> 的升级版，但使用方式是完全不同的</p><p>自定义红书上有讲解</p></blockquote><h4 id="掌邮新课表"><a href="#掌邮新课表" class="headerlink" title="掌邮新课表"></a>掌邮新课表</h4><blockquote><p>我接手的掌邮新课表也加入了拖放的效果，但并没有用到上面这两个东西，采用的思路与 <code>RecyclerView</code> 的 <code>ItemTouchHelper</code> 一致，自定义了滑动事件分发来实现的，原因在于存在一些复杂的事件交互，只能自己去实现</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解RecyclerView</title>
    <link href="/2022/09/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RecyclerView/"/>
    <url>/2022/09/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RecyclerView/</url>
    
    <content type="html"><![CDATA[<h1 id="浅析RecyclerView"><a href="#浅析RecyclerView" class="headerlink" title="浅析RecyclerView"></a>浅析RecyclerView</h1><blockquote><p>本文大致会先讲解RecyclerView的基础知识及使用，最后会深入讲解一点原理。当然，本人知识水平有限哈，太深入的东西我现在还没接触到，还请大家包容，阿里嘎多~</p></blockquote><h2 id="一、RecyclerView的历史与发展"><a href="#一、RecyclerView的历史与发展" class="headerlink" title="一、RecyclerView的历史与发展"></a>一、RecyclerView的历史与发展</h2><p>既然讲到了RV，那不得不先知道它怎么来的。<br>&amp;nbsp;<br>RecyclerView是<strong>Android 5.0</strong>提出的新的UI控件，与其一起诞生的还有著名的Material Design以及CardView等新特性。最初位于support.v7包中，这里既然提到了v7，那我就简单介绍一点v4，v7包以及androidx的历史发展。support-v4是<strong>Android 3.0</strong>推出的库，为了加入Fragment以及向下兼容老系统，即最低兼容到Android 1.6。support-v7向下兼容到Android 2.1，这两个库中包含有RecyclerView、ViewPager等常用控件。随着时间的推移，现在的Android系统已经发展到13了，显然这两个库就有些跟不上时代了，于是从<strong>Android 9.0</strong>开始，Google推出了<strong>androidx</strong>，以后推出的所有新特性都会加入到androidx中，并且androidx包下面的API都是随着扩展库发布的，这些API基本不会依赖于操作系统的具体版本，所有命名中它就不再包含版本号了。<br>&amp;nbsp;<br>所以，现在我们使用的RecyclerView都是包含在androidx包中。我们最开始学Android的时候肯定都接触过ListView，ListView的功能也很强大，在RecyclerView没出现之前，开发者们使用的都是ListView来展示大量的数据。但是ListView的性能比较差，<strong>之后我会对比一下二者的缓存策略</strong>，扩展性也不是很好，所以具有更加强大功能的RecyclerView诞生了。它包含有横向纵向排列的LinearLayoutManager、网格排列的GridLayoutManager和瀑布流排列的StaggeredGridLayoutManager。下面我先来带大家简单了解一下RecyclerView的使用。</p><h2 id="二、RecyclerView的使用"><a href="#二、RecyclerView的使用" class="headerlink" title="二、RecyclerView的使用"></a>二、RecyclerView的使用</h2><p>这部分我不会讲很多，毕竟学会使用它也不是很难，具体的大家可以去参考一下《第一行代码》，本文的重点还是放在更深一点的缓存策略，回收复用，LayoutManager 以及 ItemTouchHelper等分析上。</p><h3 id="（1）创建数据列表"><a href="#（1）创建数据列表" class="headerlink" title="（1）创建数据列表"></a>（1）创建数据列表</h3><p>这里演示的就不搞那么复杂了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>(<span class="hljs-keyword">val</span> string: String)<br></code></pre></td></tr></table></figure><h3 id="（2）创建Adapter"><a href="#（2）创建Adapter" class="headerlink" title="（2）创建Adapter"></a>（2）创建Adapter</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicAdapter</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> dataList: List&lt;Data&gt;) : RecyclerView.Adapter&lt;BasicAdapter.ViewHolder&gt;() &#123;<br><br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewHolder</span>(view: View) : RecyclerView.ViewHolder(view) &#123;<br>        <span class="hljs-keyword">val</span> dataString: TextView = view.findViewById(R.id.tv_str)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(parent: <span class="hljs-type">ViewGroup</span>, viewType: <span class="hljs-type">Int</span>)</span></span>: ViewHolder &#123;<br>        <span class="hljs-keyword">val</span> view = LayoutInflater.from(parent.context)<br>            .inflate(R.layout.title_item, parent, <span class="hljs-literal">false</span>)<br>        <span class="hljs-keyword">return</span> ViewHolder(view)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">ViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = dataList[position]<br>        holder.dataString.text = <span class="hljs-keyword">data</span>.string<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = dataList.size<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（3）Activity创建RecyclerView对象"><a href="#（3）Activity创建RecyclerView对象" class="headerlink" title="（3）Activity创建RecyclerView对象"></a>（3）Activity创建RecyclerView对象</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这是单向布局</span><br><span class="hljs-keyword">val</span> layoutManager = LinearLayoutManager(<span class="hljs-keyword">this</span>)<br>vb.recyclerView.layoutManager = layoutManager<br><span class="hljs-keyword">val</span> adapter = BasicAdapter(dataList)<br>vb.recyclerView.adapter = adapter<br><br><span class="hljs-comment">// 网格布局</span><br><span class="hljs-comment">// 将第一行代码替换为</span><br><span class="hljs-keyword">val</span> layoutManager = LinearLayoutManager(<span class="hljs-keyword">this</span>， <span class="hljs-number">2</span>) <span class="hljs-comment">// 表示分两列排布</span><br><br><span class="hljs-comment">// 瀑布流布局</span><br><span class="hljs-keyword">val</span> layoutManager = StaggeredGridLayoutManager(<span class="hljs-number">2</span>, StaggeredGridLayoutManager.VERTICAL)<br></code></pre></td></tr></table></figure><p>演示结果就不给大家展示了，比较简单，一笔带过。接下来的内容就涉及到更加深入的部分了。</p><h2 id="三、RecyclerView的缓存复用机制"><a href="#三、RecyclerView的缓存复用机制" class="headerlink" title="三、RecyclerView的缓存复用机制"></a>三、RecyclerView的缓存复用机制</h2><p>RecyclerView的性能之所以强大，就是得益于它的缓存机制。我们通常认为RV具有四级缓存机制，而官方表示只有三级，这里我还是以四级缓存来讲述。下面是RV的四级缓存结构图。<br><img src="https://img-blog.csdnimg.cn/008d5818f9954d968093b25019c19bc7.png#pic_center" alt="RV四级缓存结构"></p><table><thead><tr><th>层级</th><th>缓存变量</th><th>缓存名</th><th>用途</th></tr></thead><tbody><tr><td>1</td><td>mChangeScrap与 mAttachedScrap</td><td>可见缓存</td><td>用于布局过程中屏幕可见表项的回收和复用</td></tr><tr><td>2</td><td>mCachedViews</td><td>缓存列表</td><td>用于移出屏幕表项的回收和复用，不会清空数据</td></tr><tr><td>3</td><td>mViewCacheExtension</td><td>自定义缓存</td><td>自定义一个缓存，我们一般用不到</td></tr><tr><td>4</td><td>RecycledViewPool</td><td>缓存池</td><td>用于移出屏幕表项的回收和复用，会将ViewHolder的数据重置</td></tr></tbody></table><blockquote><p>在正式介绍四级缓存之前，我们还需要了解一下RV的Item的几个状态。</p></blockquote><table><thead><tr><th align="left">方法</th><th align="left">FLAG</th><th align="left">含义</th><th align="left">具体场景</th></tr></thead><tbody><tr><td align="left">isInvalid()</td><td align="left">FLAG_INVALID</td><td align="left">ViewHolder的数据是无效的</td><td align="left">1. 调用了setAdapter()<br>2. 调用了notifyDataSetChanged()等方法</td></tr><tr><td align="left">isRemoved()</td><td align="left">FLAG_REMOVED</td><td align="left">ViewHolder的数据已经被移除</td><td align="left">调用了notifyItemRemoved()</td></tr><tr><td align="left">isUpdated()</td><td align="left">FLAG_UPDATE</td><td align="left">ViewHolder的数据需要重新绑定</td><td align="left">1. isInvalid的几种情况<br>2. 调用了onBindViewHolder()<br>3. 调用了notifyItemChanged()</td></tr><tr><td align="left">isBound()</td><td align="left">FLAG_BOUND</td><td align="left">数据已经绑定了某个Item上，数据是有效状态</td><td align="left">调用了onBindViewHolder()</td></tr></tbody></table><h3 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1. 一级缓存"></a>1. 一级缓存</h3><h4 id="（1）一级缓存原理"><a href="#（1）一级缓存原理" class="headerlink" title="（1）一级缓存原理"></a>（1）一级缓存原理</h4><p>Scrap是RV中最轻量的缓存，包括mChangeScrap和mAttachedScrap，只是作为临时缓存的存在。主要用于缓存出现在屏幕内的item，当我们通过notifyItemRemoved()，notifyItemChanged()通知item发生变化的时候，通过mAttachedScrap缓存没有发生变化的ViewHolder，其他的则由mChangedScrap缓存，添加itemView的时候快速从里面取出，完成局部刷新。通过源码理解一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">scrapView</span><span class="hljs-params">(View view)</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> getChildViewHolderInt(view);<br>    <span class="hljs-keyword">if</span> (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)<br>        || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123;<br>    <span class="hljs-keyword">if</span> (holder.isInvalid() &amp;&amp; !holder.isRemoved() &amp;&amp; !mAdapter.hasStableIds()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Called scrap view with an invalid view.&quot;</span><br>                    + <span class="hljs-string">&quot; Invalid views cannot be reused from scrap, they should rebound from&quot;</span><br>                    + <span class="hljs-string">&quot; recycler pool.&quot;</span> + exceptionLabel());<br>        &#125;<br>        holder.setScrapContainer(<span class="hljs-built_in">this</span>, <span class="hljs-literal">false</span>);<br>        mAttachedScrap.add(holder);<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mChangedScrap == <span class="hljs-literal">null</span>) &#123;<br>            mChangedScrap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ViewHolder&gt;();<br>        &#125;<br>        holder.setScrapContainer(<span class="hljs-built_in">this</span>, <span class="hljs-literal">true</span>);<br>        mChangedScrap.add(holder);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，对于页面中显示的Item，当调用 <strong>LayoutManage</strong>r 类的 <strong>onLayoutChildren()</strong> 方法对views进行布局，这时会将RecyclerView上的items全部暂存到一个 <strong>ArrayList</strong> 集合，这里的数据是没有做修改的，所以不用重新绑定 Adapter。而如果其他情况比如调用了 <strong>notifyItemChanged()</strong> 和 <strong>notifyItemRangeChanged()</strong> 来通知数据发生了更新，数据或位置发生改变，那么该ViewHolder会被缓存到mChangedScrap中，这里存储的是发生了变化的ViewHolder，所以要重新走Adapter的绑定方法。可能我 文字表述的不是很清楚，下面我放一张图来助大家理解。<br><img src="https://img-blog.csdnimg.cn/6b870794d9d74e89b82ebcee100aebc7.png#pic_center" alt="在这里插入图片描述"><br>图中的itemB删除掉，然后itemC，itemD依次移动上来，这里itemA和itemB前后参数没有发生变化（虽然itemB被移除了，但移除的时候它还是有效的，会被打上REMOVED标签，表示它是要删除的），所以他们两个存储到mAttachedscrap()，而itemC和itemD的位置发生了改变，所以他俩要存到mChangedScrap()中去。总结来说，删除itemB时，ABCD都会进入Scrap缓存，删除后，会从Scrap中将ACD取出，A的位置和数据都没有发生变化，CD的位置发生了变化但数据还是原封不动。</p><h4 id="（2）一级缓存复用"><a href="#（2）一级缓存复用" class="headerlink" title="（2）一级缓存复用"></a>（2）一级缓存复用</h4><p>复用的源码在ViewHolder tryGetViewHolderForPositionByDeadline(*)方法中。我对源码的解释在代码的注释里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 0) If there is a changed scrap, try to find from there</span><br><span class="hljs-comment">// 这里是从mChangedScrap()取ViewHolder，isPreLayout()判断是否为预布局，是一个特殊情况。</span><br><span class="hljs-comment">// 那什么是预布局呢？稍后我讲LayoutManager的时候会具体说一下</span><br><span class="hljs-keyword">if</span> (mState.isPreLayout()) &#123;            <br>holder = getChangedScrapViewForPosition(position);            <br>    fromScrapOrHiddenOrCache = holder != <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// OK，现在我们点进getChangedScrapViewForPosition()方法中看一下是怎么取得ViewHolder</span><br><span class="hljs-comment">// find by position</span><br><span class="hljs-comment">// 这是按照position来取</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; changedScrapSize; i++) &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> mChangedScrap.get(i);<br>    <span class="hljs-keyword">if</span> (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position) &#123;<br>    holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP); <span class="hljs-comment">// 添加标签表示从Scrap取</span><br>        <span class="hljs-keyword">return</span> holder;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// find by id</span><br><span class="hljs-comment">// 这是通过定义的id来取</span><br><span class="hljs-keyword">if</span> (mAdapter.hasStableIds()) &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">offsetPosition</span> <span class="hljs-operator">=</span> mAdapterHelper.findPositionOffset(position);<br>    <span class="hljs-keyword">if</span> (offsetPosition &gt; <span class="hljs-number">0</span> &amp;&amp; offsetPosition &lt; mAdapter.getItemCount()) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> mAdapter.getItemId(offsetPosition);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; changedScrapSize; i++) &#123;<br>            <span class="hljs-comment">// 从mChangedScrap中取holder</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> mChangedScrap.get(i);<br>            <span class="hljs-keyword">if</span> (!holder.wasReturnedFromScrap() &amp;&amp; holder.getItemId() == id) &#123;<br>            holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);<br>                <span class="hljs-keyword">return</span> holder;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从这里开始就是缓存复用真正的第一步，上面的是预加载的特殊情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1) Find by position from scrap/hidden list/cache</span><br><span class="hljs-comment">// 这里就是从mAttachedScrap()中取ViewHolder了</span><br><span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span>) &#123;<br>holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);<br>    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 这里还要检验ViewHolder的有效性</span><br>    <span class="hljs-keyword">if</span> (!validateViewHolderForOffsetPosition(holder)) &#123;<br>        <span class="hljs-comment">// recycle holder (and unscrap if relevant) since it can&#x27;t be used</span><br>            <span class="hljs-keyword">if</span> (!dryRun) &#123;<br>            <span class="hljs-comment">// we would like to recycle this but need to make sure it is not used by</span><br>                <span class="hljs-comment">// animation logic etc.</span><br>                holder.addFlags(ViewHolder.FLAG_INVALID);<br>                <span class="hljs-keyword">if</span> (holder.isScrap()) &#123;<br>                removeDetachedView(holder.itemView, <span class="hljs-literal">false</span>);<br>                    holder.unScrap();<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.wasReturnedFromScrap()) &#123;<br>                  holder.clearReturnedFromScrapFlag();<br>                &#125;<br>                <span class="hljs-comment">// 如果不满足有效性则直接回收该ViewHolder</span><br>                recycleViewHolderInternal(holder);<br>            &#125;<br>            holder = <span class="hljs-literal">null</span>;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>          fromScrapOrHiddenOrCache = <span class="hljs-literal">true</span>;<br>         &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这是从mAttachedScrap()取VH的核心源码，和上面的差不多。</span><br><span class="hljs-comment">// 只是多了几个判断条件，该holder须是有效的并且未被移除。</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">scrapCount</span> <span class="hljs-operator">=</span> mAttachedScrap.size();<br><br><span class="hljs-comment">// Try first for an exact, non-invalid match from scrap.</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; scrapCount; i++) &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> mAttachedScrap.get(i);<br><span class="hljs-comment">// 第二个条件为索引判断，表示只能复用到指定位置</span><br>    <span class="hljs-keyword">if</span> (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position<br>    &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved())) &#123;<br>    holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);<br>        <span class="hljs-keyword">return</span> holder;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码中可以看到，ViewHolder的复用是有顺序的，首先会判断是否预布局，如果是就从一级缓存中的mChangedScrap()中获取。如果没获取到就去mAttachScrap()和二级缓存中找。而一级缓存之所以说轻量，首先是因为它只针对当前页面显示的这些item，其次是因为它用完就会清空缓存，不占空间，效率也快。所以通知数据更新我们推荐使用notifyItemChanged()，实现局部刷新，用的是一级缓存来实现复用。而如果我们调用notifyDataChanged()来通知更新，会使数据全部进行刷新，不会走Scrap，性能低下。</p><h3 id="3-二级缓存"><a href="#3-二级缓存" class="headerlink" title="3. 二级缓存"></a>3. 二级缓存</h3><h4 id="（1）二级缓存原理"><a href="#（1）二级缓存原理" class="headerlink" title="（1）二级缓存原理"></a>（1）二级缓存原理</h4><p>CacheView用于RecyclerView列表位置产生变动时，通常称为离屏缓存，对刚刚移出屏幕的view进行回收。它的默认容量是2（可以修改），同样我们用一张图来帮助理解一下。<br><img src="https://img-blog.csdnimg.cn/01311bed9ff14912a061a972e1fe52b7.png#pic_center" alt="在这里插入图片描述"></p><h4 id="（2）二级缓存复用"><a href="#（2）二级缓存复用" class="headerlink" title="（2）二级缓存复用"></a>（2）二级缓存复用</h4><p>接着上面的一级缓存复用讲。<br>这里还是getScrapOrHiddenOrCachedHolderForPosition()方法里的，如果刚才从mAttachScrap里没取到ViewHolder，那么就会走二级缓存，从mCachedViews里找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Search in our first-level recycled view cache. 官方说这里是第一级，但在我们日常使用中还是称他为第二级缓存</span><br><span class="hljs-comment">// 这是根据position来取</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">cacheSize</span> <span class="hljs-operator">=</span> mCachedViews.size();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cacheSize; i++) &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> mCachedViews.get(i);<br>    <span class="hljs-comment">// invalid view holders may be in cache if adapter has stable ids as they can be</span><br>    <span class="hljs-comment">// retrieved via getScrapOrCachedViewForId</span><br>    <span class="hljs-comment">// 这里要对索引进行判断，只有当位置对得上才能拿来复用，</span><br>    <span class="hljs-comment">// 这也就意味着从mCatchedViews中取出的ViewHolder只能复用到指定的位置。</span><br>    <span class="hljs-keyword">if</span> (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() == position<br>    &amp;&amp; !holder.isAttachedToTransitionOverlay()) &#123;<br>    <span class="hljs-comment">// 如果不在容量范围内，就把ViewHolder丢出去，丢到缓存池中。</span><br>    <span class="hljs-keyword">if</span> (!dryRun) &#123;<br>        mCachedViews.remove(i);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;getScrapOrHiddenOrCachedHolderForPosition(&quot;</span> + position<br>            + <span class="hljs-string">&quot;) found match in cache: &quot;</span> + holder);<br>        &#125;<br>        <span class="hljs-keyword">return</span> holder;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是源码里的第三步，这里是根据id来取，上面的是根据position来取，相差不大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2) Find from scrap/cache via stable ids, if exists</span><br><span class="hljs-keyword">if</span> (mAdapter.hasStableIds()) &#123;<br>holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),<br>    type, dryRun);<br>    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// update position</span><br>        holder.mPosition = offsetPosition;<br>        fromScrapOrHiddenOrCache = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 点进getScrapOrCachedViewForId()</span><br><span class="hljs-comment">// Search the first-level cache</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">cacheSize</span> <span class="hljs-operator">=</span> mCachedViews.size();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cacheSize - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> mCachedViews.get(i);<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>CachedView的缓存主要是应对来回滑动的情况，这时候CachedView才会真正的起作用，其缓存的ViewHolder不需要重新赋值，就可以直接拿来用了。而且我们还可以修改它的容量，通过下面这个方法来修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setItemViewCacheSize</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>    mRecycler.setViewCacheSize(size);<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下，mAttachedScrap和mCachedViews都是需要进行索引判断，也就是说从这两个缓存中取出的ViewHolder只能复用到指定的位置。mCachedViews只能缓存屏幕外它容量大小的ViewHolder，超出容量的部分会被移除，丢到缓存池中，一会我再来具体讲解缓存池。</p><h3 id="5-三级缓存"><a href="#5-三级缓存" class="headerlink" title="5. 三级缓存"></a>5. 三级缓存</h3><p>三级缓存ViewCacheExtension是我们自定义的缓存，一般来说官方给的一、二、四级缓存就够用了，我们不会用到它，所以我也就一笔带过了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span> &amp;&amp; mViewCacheExtension != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// We are NOT sending the offsetPosition because LayoutManager does not know it.</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> mViewCacheExtension.getViewForPositionAndType(<span class="hljs-built_in">this</span>, position, type);<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码中分析，如果我们自定义了一个缓存并且前面的一二级缓存没有找到ViewHolder，系统就会从我们自定义的这个缓存里去找ViewHolder。</p><h3 id="6-四级缓存"><a href="#6-四级缓存" class="headerlink" title="6. 四级缓存"></a>6. 四级缓存</h3><p>好的，本文的<strong>第一个重点</strong>来了！在这里我会详细地分析<strong>RV的缓存池</strong>机制。<br>先来看看这一级的复用机制。</p><h4 id="（1）缓存池结构"><a href="#（1）缓存池结构" class="headerlink" title="（1）缓存池结构"></a>（1）缓存池结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// fallback to pool</span><br><span class="hljs-keyword">if</span> (DEBUG) &#123;<br>    Log.d(TAG, <span class="hljs-string">&quot;tryGetViewHolderForPositionByDeadline(&quot;</span><br>        + position + <span class="hljs-string">&quot;) fetching from shared pool&quot;</span>);<br>    &#125;<br>    holder = getRecycledViewPool().getRecycledView(type);<br>    <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) &#123;<br>    holder.resetInternal();<br>        <span class="hljs-keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) &#123;<br>        invalidateDisplayListInt(holder);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这一部分和之前的一二级缓存复用机制有很大区别，没有那么多的限制条件了，不用判断索引是不是指定位置。但是它需要根据<strong>itemType</strong>来区分不同类型的<strong>ViewHolder</strong>。但在了解缓存池的复用机制之前，我们得先知道RecycledViewPool的基本结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecycledViewPool</span> &#123;<br><span class="hljs-comment">//同类ViewHolder缓存个数上限为5</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MAX_SCRAP</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">// Tracks both pooled holders, as well as create/bind timing metadata for the given type.</span><br>    <span class="hljs-comment">// 回收池中存放单个类型ViewHolder的容器</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrapData</span> &#123;<br>    <span class="hljs-comment">//同类ViewHolder存储在ArrayList中</span><br>        ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mMaxScrap</span> <span class="hljs-operator">=</span> DEFAULT_MAX_SCRAP;<br>    &#125;<br>    <span class="hljs-comment">//回收池中存放所有类型ViewHolder的容器</span><br>    SparseArray&lt;ScrapData&gt; mScrap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparseArray</span>&lt;&gt;();<br>    ...<br>    <span class="hljs-comment">//ViewHolder入池按viewType分类入池，一个类型的ViewType存放在一个ScrapData中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putRecycledView</span><span class="hljs-params">(ViewHolder scrap)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">viewType</span> <span class="hljs-operator">=</span> scrap.getItemViewType();<br>        <span class="hljs-keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = getScrapDataForType(viewType).mScrapHeap;<br>        <span class="hljs-comment">//如果超限了，则放弃入池</span><br>        <span class="hljs-keyword">if</span> (mScrap.get(viewType).mMaxScrap &lt;= scrapHeap.size()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; scrapHeap.contains(scrap)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;this scrap item already exists&quot;</span>);<br>        &#125;<br>        scrap.resetInternal();<br>        <span class="hljs-comment">//回收时，ViewHolder从列表尾部插入</span><br>        scrapHeap.add(scrap);<br>    &#125;<br>    <br>    <span class="hljs-comment">//从回收池中获取ViewHolder对象</span><br>    <span class="hljs-keyword">public</span> ViewHolder <span class="hljs-title function_">getRecycledView</span><span class="hljs-params">(<span class="hljs-type">int</span> viewType)</span> &#123;<br>    <span class="hljs-comment">// 获取到viewType</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ScrapData</span> <span class="hljs-variable">scrapData</span> <span class="hljs-operator">=</span> mScrap.get(viewType);<br>        <span class="hljs-keyword">if</span> (scrapData != <span class="hljs-literal">null</span> &amp;&amp; !scrapData.mScrapHeap.isEmpty()) &#123;<br>        <span class="hljs-keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;<br>            <span class="hljs-comment">//复用时，从列表尾部获取ViewHolder（优先复用刚入池的ViewHoler）</span><br>            <span class="hljs-keyword">return</span> scrapHeap.remove(scrapHeap.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以根据上述分析得到如下结论：RecycledViewPool中的ViewHolder存储在<strong>SparseArray</strong>中，并且按viewType分类存储，同一类型的ViewHolder存放在一个<strong>ArrayList</strong>中。虽然没有了对索引的判断，但是从mRecyclerPool中取出的ViewHolder**只能复用于相同viewType的表项。</p><p>那么现在我们再来分析缓存池的复用过程。</p><h4 id="（2）缓存池复用"><a href="#（2）缓存池复用" class="headerlink" title="（2）缓存池复用"></a>（2）缓存池复用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">holder = getRecycledViewPool().getRecycledView(type);<br><br><span class="hljs-comment">// 这里是getRecyclerViewPool()，主要作用就是new了一个RecyclerViewPool对象出来。</span><br><span class="hljs-comment">// 然后再根据type来从缓存池中获取对应类型的ViewHolder。</span><br>RecycledViewPool <span class="hljs-title function_">getRecycledViewPool</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (mRecyclerPool == <span class="hljs-literal">null</span>) &#123;<br>    mRecyclerPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecycledViewPool</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> mRecyclerPool;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是缓存池复用的运作机制，相信大家都已经对这部分的内容有所了解了，那么什么时候数据会被放到缓存池中呢？</p><h4 id="（3）表项放入缓存池的几种情况"><a href="#（3）表项放入缓存池的几种情况" class="headerlink" title="（3）表项放入缓存池的几种情况"></a>（3）表项放入缓存池的几种情况</h4><h5 id="item移出屏幕"><a href="#item移出屏幕" class="headerlink" title="item移出屏幕"></a>item移出屏幕</h5><p>如果大家有印象的话，上面交代了一部分，超出mCachedViews的部分会被丢到这里来。这种情况就是当你滑动屏幕，item移出到屏幕之外后，超出屏幕两个之外的item被缓存池回收，为什么是两个之外呢？因为这两个是缓存在mCachedViews中的，因为它的复用效率更快，优先级更高。超出两个之外的按照先入先出的原则，被mCachedViews移出缓存。从这里可以看出，当你在滑动屏幕的过程中mCachedViews是不断进行 <strong>“输入输出”</strong> 的。</p><h5 id="一级缓存的ViewHolder无效"><a href="#一级缓存的ViewHolder无效" class="headerlink" title="一级缓存的ViewHolder无效"></a>一级缓存的ViewHolder无效</h5><p>在讲一级二级缓存复用机制的时候，我说过从mAttachedScrap，mCachedViews中取ViewHolder时，还需要检验有效性，具体是怎么检验的呢，我们从源码入手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">validateViewHolderForOffsetPosition</span><span class="hljs-params">(ViewHolder holder)</span> &#123;<br><span class="hljs-comment">// if it is a removed holder, nothing to verify since we cannot ask adapter anymore</span><br>    <span class="hljs-comment">// if it is not removed, verify the type and id.</span><br>    <span class="hljs-comment">// item是否被移除</span><br>    <span class="hljs-keyword">if</span> (holder.isRemoved()) &#123;<br>    <span class="hljs-comment">// 如果是被移除的，返回是否为预加载</span><br>        <span class="hljs-keyword">return</span> mState.isPreLayout();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果不是预加载布局，就检查ViewType是否和Adapter对应位置的ViewHolder相同</span><br>    <span class="hljs-keyword">if</span> (!mState.isPreLayout()) &#123;<br>    <span class="hljs-comment">// don&#x27;t check type if it is pre-layout.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> mAdapter.getItemViewType(holder.mPosition);<br>        <span class="hljs-keyword">if</span> (type != holder.getItemViewType()) &#123;<br>        <span class="hljs-comment">// 如果类型不相同，返回false，即无效</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 这里是检查id</span><br>    <span class="hljs-keyword">if</span> (mAdapter.hasStableIds()) &#123;<br>    <span class="hljs-keyword">return</span> holder.getItemId() == mAdapter.getItemId(holder.mPosition);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码上看，只有当缓存中 ViewHolder 的 viewType 或 id 和 Adapter 对应位置上的属性相同时（简单来说就是只有对得上号的才是有效的ViewHolder）才会从一二级缓存中取出复用。否则就会将无效的ViewHolder丢到缓存池中。</p><p>还有其他几种情况我就不一一列举了，大体差不多。缓存池就相当于一个回收站，别人不要的都会往缓存池里塞。接下来我要讲一下从缓存池里拿出来复用的ViewHolder和前面几种有什么区别。</p><h4 id="（4）从缓存池取出的ViewHolder和前面的区别"><a href="#（4）从缓存池取出的ViewHolder和前面的区别" class="headerlink" title="（4）从缓存池取出的ViewHolder和前面的区别"></a>（4）从缓存池取出的ViewHolder和前面的区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">holder = getRecycledViewPool().getRecycledView(type);<br><span class="hljs-comment">// 刚才没贴的代码现在补上</span><br><span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) &#123;<br>holder.resetInternal();<br>    <span class="hljs-keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) &#123;<br>    invalidateDisplayListInt(holder);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码什么意思呢？就是当ViewHolder从缓存池取出来后，判断holder是否为空，如果不为空，说明holder从缓存池中取出来了。那么就执行 holder.resetInternal() ，意思是将取出的ViewHolder<strong>重置</strong>，我们点进这个方法看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">resetInternal</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//将ViewHolder的flag置0，剩下的一些属性也将其重置，要么置0，要么置空</span><br>mFlags = <span class="hljs-number">0</span>;<br>mPosition = NO_POSITION;<br>    mOldPosition = NO_POSITION;<br>    mItemId = NO_ID;<br>    mPreLayoutPosition = NO_POSITION;<br>    mIsRecyclableCount = <span class="hljs-number">0</span>;<br>    mShadowedHolder = <span class="hljs-literal">null</span>;<br>    mShadowingHolder = <span class="hljs-literal">null</span>;<br>    clearPayload();<br>    mWasImportantForAccessibilityBeforeHidden = ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO;<br>    mPendingAccessibilityState = PENDING_ACCESSIBILITY_STATE_NOT_SET;<br>    clearNestedRecyclerViewIfNotNested(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 上面重置时将flag置0，这里flag与FLAG_BOUND与操作，结果必为0</span><br><span class="hljs-comment">// 所以将flag置0相当于解绑</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isBound</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> (mFlags &amp; FLAG_BOUND) != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（5）总结"><a href="#（5）总结" class="headerlink" title="（5）总结"></a>（5）总结</h4><blockquote><p>在滚动过程中，当需要 ViewHolder 进行布局时，先去一二级缓存里找有没有这个刚刚移除 ViewHolder，如果有就直接拿出来复用。如果没有，就去缓存池里拿出来一个 <code>ViewHolder</code> 返回给 RecyclerView ，让他重新绑定数据。</p><p>综上所述，从缓存池里取出来的ViewHolder将其重置，复用的时候再重新绑定数据。而一二级缓存无需再绑定数据，<strong>直接拿来复用</strong>，因为他们的位置和数据都没有变化。当有相同类型的表项插入列表时，<strong>不用重新创建 ViewHolder 实例</strong>（执行 onCreateViewHolder()），从缓存池中获取即可。到这里，RV的四级缓存复用机制就差不多讲完了，大家也对RV有了更深一步的了解，但是，RV是什么时候又是怎么将这些ViewHolder填充屏幕的呢？这个问题我们还需深入探讨一下LayoutManager，相信大家对这个也不陌生。</p></blockquote><h2 id="四、LayoutManager"><a href="#四、LayoutManager" class="headerlink" title="四、LayoutManager"></a>四、LayoutManager</h2><p>LayoutManager是<strong>布局管理器</strong>，主要的作用是布局子视图，处理滚动过程中子视图的添加与回收。接下来我会讲一下它是怎么处理表项的加载和布局的。说实话，刚开始讲这个我都不知道从哪入手，在源码中遨游，跳来跳去的，往往看一个方法，就要跳到更多方法去理解这个方法，然后那些方法中还有更多的方法需要理解……</p><h3 id="1-LayoutManager管理表项的添加"><a href="#1-LayoutManager管理表项的添加" class="headerlink" title="1. LayoutManager管理表项的添加"></a>1. LayoutManager管理表项的添加</h3><p>首先，我们既然要理解滚动过程中表项的状态，肯定还是要从 onTouchEvent() 入手，这个是RV的触摸事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecyclerView</span> &#123;<br>...<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouchEvent</span><span class="hljs-params">(MotionEvent e)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (action) &#123;<br>            <span class="hljs-comment">// RecyclerView 对滑动事件的处理</span><br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>            <span class="hljs-comment">// 前面是判断启动条件的一些代码，就不展示了</span><br>                ...<br>                <span class="hljs-comment">// 滚动的内部</span><br>                <span class="hljs-keyword">if</span> (scrollByInternal(<br>                        canScrollHorizontally ? dx : <span class="hljs-number">0</span>,<br>                        canScrollVertically ? dy : <span class="hljs-number">0</span>,<br>                        e)) &#123;...&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，触摸事件调用了 scrollByInternal() 方法，并把滑动的距离传了进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">scrollByInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, MotionEvent ev)</span> &#123;<br><span class="hljs-keyword">if</span> (mAdapter != <span class="hljs-literal">null</span>) &#123;<br>    mReusableIntPair[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    mReusableIntPair[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 在这里调用了 scrollStep()，滑动步骤</span><br>    scrollStep(x, y, mReusableIntPair);<br>        <br>    consumedX = mReusableIntPair[<span class="hljs-number">0</span>];<br>    consumedY = mReusableIntPair[<span class="hljs-number">1</span>];<br>    unconsumedX = x - consumedX;<br>    unconsumedY = y - consumedY;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>scrollStep() 是滚动之前进行的操作，dispatchNestedScroll() 是真正滚动的方法，dispatch是分发调度的意思。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">scrollStep</span><span class="hljs-params">(<span class="hljs-type">int</span> dx, <span class="hljs-type">int</span> dy, <span class="hljs-meta">@Nullable</span> <span class="hljs-type">int</span>[] consumed)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">consumedX</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">consumedY</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (dx != <span class="hljs-number">0</span>) &#123;<br>    consumedX = mLayout.scrollHorizontallyBy(dx, mRecycler, mState);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dy != <span class="hljs-number">0</span>) &#123;<br>        consumedY = mLayout.scrollVerticallyBy(dy, mRecycler, mState);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 scrollStep() 方法里，我们终于看到了 mLayout，这是一个 <strong>LayoutManager</strong> 对象，说明从这开始，由布局管理器来接管。我们以 LinearLayoutManager 为例，将垂直位移作为参数传给 scrollBy()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">scrollVerticallyBy</span><span class="hljs-params">(<span class="hljs-type">int</span> dy, RecyclerView.Recycler recycler,</span><br><span class="hljs-params">RecyclerView.State state)</span> &#123;<br><span class="hljs-keyword">if</span> (mOrientation == HORIZONTAL) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> scrollBy(dy, recycler, state);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">scrollBy</span><span class="hljs-params">(<span class="hljs-type">int</span> delta, RecyclerView.Recycler recycler, RecyclerView.State state)</span> &#123;<br><span class="hljs-comment">// 更新LayoutState</span><br>updateLayoutState(layoutDirection, absDelta, <span class="hljs-literal">true</span>, state);<br><span class="hljs-comment">// 滚动时向列表中填充新的表项</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">consumed</span> <span class="hljs-operator">=</span> mLayoutState.mScrollingOffset<br>    + fill(recycler, mLayoutState, state, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>scrollBy() 中终于找到了我们想看到的 **fill()**，是填充表项的意思，这个意思是在滚动之前将未显示在界面的表项进行预布局吗？我们继续往下走。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">fill</span><span class="hljs-params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span><br><span class="hljs-params">RecyclerView.State state, <span class="hljs-type">boolean</span> stopOnFocusable)</span> &#123;<br>...<br><span class="hljs-keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="hljs-number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;<br>...<br><span class="hljs-comment">// 如果剩余空间 &gt; 0，就循环添加item，layoutChunk()就是这个作用</span><br>layoutChunk(recycler, state, layoutState, layoutChunkResult);<br>...<br><span class="hljs-comment">// 如果 layoutChunk 中将 mFinished 设置为 true ，就退出循环</span><br><span class="hljs-keyword">if</span> (layoutChunkResult.mFinished) &#123;<br>        <span class="hljs-keyword">break</span>;<br>        &#125;<br>        ...<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">layoutChunk</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span><br><span class="hljs-params">            LayoutState layoutState, LayoutChunkResult result)</span> &#123;<br>    <br><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> layoutState.next(recycler);<br><span class="hljs-comment">// 如果view为空，即 layoutState 没有下一个item了，就结束布局</span><br><span class="hljs-keyword">if</span> (view == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; layoutState.mScrapList == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;received null view when unexpected&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// if we are laying out views in scrap, this may return null which means there is</span><br>        <span class="hljs-comment">// no more items to layout.</span><br>        result.mFinished = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>...<br><span class="hljs-keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection<br>    == LayoutState.LAYOUT_START)) &#123;<br>    <span class="hljs-comment">// 将获取到的下一个 view 添加进来</span><br>    addView(view);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    addView(view, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>fill()</strong> 方法会根据剩余空间来循环地调用 <strong>layoutChunk()</strong> 向列表中填充表项，滚动列表的场景中，剩余空间的值由滚动距离决定。而填充用到的 view 其实就是从缓存里取出的，这就回到了之前讲过的<strong>缓存复用</strong>的步骤中去了。大家看一下源码就懂了~。<strong>addView()</strong> 就是向列表里添加视图的具体方法，在这里面将要添加的子视图与RecyclerView绑定起来，成为它的子视图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">View <span class="hljs-title function_">next</span><span class="hljs-params">(RecyclerView.Recycler recycler)</span> &#123;<br><span class="hljs-keyword">if</span> (mScrapList != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> nextViewFromScrapList();<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> recycler.getViewForPosition(mCurrentPosition);<br>mCurrentPosition += mItemDirection;<br><span class="hljs-keyword">return</span> view;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就是循环填充表项中，获取 <strong>layoutState</strong> 下一个 view 的方法，它又调用了 <strong>Recycler</strong> 的<strong>getViewForPosition()</strong> 方法，通过当前的位置获取 view。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> View <span class="hljs-title function_">getViewForPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> position)</span> &#123;<br><span class="hljs-keyword">return</span> getViewForPosition(position, <span class="hljs-literal">false</span>);<br>&#125;<br><br>View <span class="hljs-title function_">getViewForPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> position, <span class="hljs-type">boolean</span> dryRun)</span> &#123;<br><span class="hljs-keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;<br>&#125;<br></code></pre></td></tr></table></figure><p>大家看到 <strong>tryGetViewHolderForPositionByDeadline()</strong> 可能就恍然大悟了，这不就是复用吗，从一到四级缓存中获取到 ViewHolder。经过以上分析，我做一下这部分的总结。</p><blockquote><p>我们从 RecyclerView 的 <strong>onTouchEvent()</strong> 入手，通过调用链一步一步往下分析，终于在 <strong>layoutChunk()</strong> 方法里找到了LayoutManager 管理表项添加的内容。它是通过 <strong>next()</strong> 方法从缓存中获取到下一个表项，然后将其添加到列表中，这样，在用户来回滑动的过程中，在屏幕之外的 item 就可以正常的显示出来。而子视图要显示在什么位置是需要进行测量的，知道了显示的位置，才可以将它布局到界面上。那我们就来看看是怎么布局的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 还是这个方法里</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">layoutChunk</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span><br><span class="hljs-params">            LayoutState layoutState, LayoutChunkResult result)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 测量获取到的子视图所占的空间和位置</span><br>    measureChildWithMargins(view, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 得到填充该视图所需要消耗的空间</span><br>    result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);<br>    ...<br>    <span class="hljs-comment">// We calculate everything with View&#x27;s bounding box (which includes decor and margins)</span><br>    <span class="hljs-comment">// To calculate correct layout position, we subtract margins.</span><br>    <span class="hljs-comment">// 计算位置并将该表项布局</span><br>    layoutDecoratedWithMargins(view, left, top, right, bottom);<br>&#125;<br></code></pre></td></tr></table></figure><p>经过这个方法后布局子视图后，回到 <strong>fill()</strong> 中，剩余空间 <strong>remainingSpace</strong> 将布局子视图消耗的空间减掉以作为循环退出条件，所以最多会填充 <strong>remainingSpace</strong> 容量大小的表项，这个大小是通过滚动位移绝对值计算的，源码我就不放了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!layoutChunkResult.mIgnoreConsumed || layoutState.mScrapList != <span class="hljs-literal">null</span><br>|| !state.isPreLayout()) &#123;<br>layoutState.mAvailable -= layoutChunkResult.mConsumed;<br>    <span class="hljs-comment">// we keep a separate remaining space because mAvailable is important for recycling</span><br>    remainingSpace -= layoutChunkResult.mConsumed;<br>&#125;<br></code></pre></td></tr></table></figure><p>好啦，至此我们就应该知道 <strong>LayoutManager</strong> 是如何添加和布局表项的了。以下两条就是阅读源码总结出的精华。</p><blockquote><p>RecyclerView 在滚动发生之前，会有一个填充新表项的动作，填充的是当前还未显示的表项。</p><p>RecyclerView 填充表项是通过<code>while</code>循环实现的，当列表没有剩余空间时，填充表项也就结束了。</p></blockquote><h3 id="2-LayoutManager管理表项的回收"><a href="#2-LayoutManager管理表项的回收" class="headerlink" title="2. LayoutManager管理表项的回收"></a>2. LayoutManager管理表项的回收</h3><p>LayoutManager 的另一个作用便是回收了，有新表项入就有旧表项出。我在讲表项的添加的时候，有一个 **fill() ** 函数，它完成列表的填充，但填充之后的代码我没有放，现在来给大家看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">fill</span><span class="hljs-params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span><br><span class="hljs-params">            RecyclerView.State state, <span class="hljs-type">boolean</span> stopOnFocusable)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 添加的操作</span><br>    layoutChunk(recycler, state, layoutState, layoutChunkResult);<br>    ...<br>    <span class="hljs-keyword">if</span> (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;<br>    ...<br>        <span class="hljs-comment">// 回收的操作</span><br>        recycleByLayoutState(recycler, layoutState);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>fill() 每次添加一个表项之后，都会执行一次回收操作，我们继续沿着调用链走。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recycleByLayoutState</span><span class="hljs-params">(RecyclerView.Recycler recycler, LayoutState layoutState)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;<br>    recycleViewsFromEnd(recycler, scrollingOffset, noRecycleSpace);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        recycleViewsFromStart(recycler, scrollingOffset, noRecycleSpace);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recycleViewsFromStart</span><span class="hljs-params">(RecyclerView.Recycler recycler, <span class="hljs-type">int</span> scrollingOffset,</span><br><span class="hljs-params"><span class="hljs-type">int</span> noRecycleSpace)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 一条控制线</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">limit</span> <span class="hljs-operator">=</span> scrollingOffset - noRecycleSpace;<br>    <span class="hljs-comment">// 列表中子视图的数量</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childCount</span> <span class="hljs-operator">=</span> getChildCount();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;<br>    <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getChildAt(i);<br>        <span class="hljs-comment">// getDecoratedEnd(item)就是获取该item底部纵坐标的方法</span><br>        <span class="hljs-keyword">if</span> (mOrientationHelper.getDecoratedEnd(child) &gt; limit<br>        || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123;<br>        <span class="hljs-comment">// stop here</span><br>            <span class="hljs-comment">// 回收子视图的方法，会将旧的表项从列表中删除</span><br>            recycleChildren(recycler, <span class="hljs-number">0</span>, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意！</strong>重点来了，recycleViewsFromStart() 中出现了一个 <strong>limit</strong>，这个 limit 是什么？大家之前可能有个疑问，说是将旧的表项回收掉，但是从哪里开始回收呢，又该回收多少呢？而这个 <strong>limit</strong> 就是解答疑问的关键，它是一条隐形的控制线，控制的就是回收的具体位置。 <code>mOrientationHelper.getDecoratedEnd(child) &gt; limit</code> 当表项底部的纵坐标大于 limit 的值时，就回收该表项。也就是说位于 limit <strong>控制线上</strong>的表项就会被回收。用一张图理解一下~</p><p><img src="https://img-blog.csdnimg.cn/e795a9e5b80643f1abbf26c834284dcc.png#pic_center" alt="limit线理解"></p><p>limit 的值为 <strong>scrollingOffset - noRecycleSpace</strong> ，其中 noRecycleSpace &#x3D; 0（源码中被赋值为零），那么 limit 就只与 scrollingOffset 有关了，那这个 scrollingOffset 又是怎么计算的呢？我们在源码中继续寻找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateLayoutState</span><span class="hljs-params">(<span class="hljs-type">int</span> layoutDirection, <span class="hljs-type">int</span> requiredSpace,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> canUseExistingSpace, RecyclerView.State state)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 获取到列表最后一个item</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getChildClosestToEnd();<br>    <span class="hljs-comment">// 计算 scrollingOffset</span><br>    <span class="hljs-comment">// getDecoratedEnd()获取列表最后一个item底部的位置，getEndAfterPadding()获取列表底部的位置</span><br>    scrollingOffset = mOrientationHelper.getDecoratedEnd(child)<br>    - mOrientationHelper.getEndAfterPadding();<br>    <span class="hljs-comment">// 为 mScrollingOffset 赋值</span><br>    mLayoutState.mScrollingOffset = scrollingOffset;<br>&#125; <br></code></pre></td></tr></table></figure><p>它是在这里被引用的，大家一定不陌生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">scrollBy</span><span class="hljs-params">(<span class="hljs-type">int</span> delta, RecyclerView.Recycler recycler, RecyclerView.State state)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 滑动位移绝对值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">absDelta</span> <span class="hljs-operator">=</span> Math.abs(delta);<br>    <span class="hljs-comment">// 更新 LayoutState</span><br>    updateLayoutState(layoutDirection, absDelta, <span class="hljs-literal">true</span>, state);<br>    <span class="hljs-comment">// 计算表项消耗的像素</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">consumed</span> <span class="hljs-operator">=</span> mLayoutState.mScrollingOffset<br>    + fill(recycler, mLayoutState, state, <span class="hljs-literal">false</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <strong>updateLayoutState()</strong> 方法里，<strong>scrollingOffset</strong> 的大小为列表最后一个 item 的底部到列表底部的距离，这样 <strong>limit</strong> 的值就算出来了。比较抽象的一个概念，我也用一张图来带大家理解一下。</p><p><img src="https://img-blog.csdnimg.cn/c0331cf83e0b43dca7f1d0e0de38c92d.png#pic_center" alt="计算距离"></p><p>用户上拉下滑时，limit 的值如此计算，可能有人会问到，limit 线不是在上面的吗，怎么在下面计算？没错！因为下面的这段距离也正是 limit 线离顶部的距离。因此，我们可以认为，limit 的值就是这一次滚动的总距离，<strong>limit当前所在位置，在滚动完成后会和列表顶部重合</strong> 。这里我也画了一张图来助大家理解。</p><p><img src="https://img-blog.csdnimg.cn/d6c8313a69af450e8dc6807be187c7f7.png#pic_center" alt="在这里插入图片描述"></p><p>相信大家看了图就会更理解了一些，结合前面所讲，limit 线上面就是需要回收的（即<strong>item1</strong>），而列表底部下面的是将要添加进列表的（即<strong>item8</strong>）。但是 item8 之后的 item 呢？答案是，随着我们的滚动，用于计算 limit 值的 <strong>scrollingOffset</strong> 在不断变大，因为每添加一个新表项，它就会更新值，将新表项消耗的像素值加进来。这样 limit 的值也就在不断地变化，是动态更新的。</p><blockquote><p>在循环填充新表项时，新表项占用的像素值每次都会追加到 <code>layoutState.mScrollingOffset</code>，即它的值在不断增大（<code>limit 隐形线</code>在不断下移）。在一次<code>while</code>循环的最后，会调用<code>recycleByLayoutState()</code>根据当前<code>limit 隐形线</code>的位置回收表项。</p></blockquote><p>我们通过源码看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">fill</span><span class="hljs-params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span><br><span class="hljs-params">            RecyclerView.State state, <span class="hljs-type">boolean</span> stopOnFocusable)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="hljs-number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;<br>        <span class="hljs-comment">// 循环添加表项</span><br>        layoutChunk(recycler, state, layoutState, layoutChunkResult);<br>    ...<br>        <span class="hljs-comment">// 每次添加一个新表项，都会重新计算 mScrollingOffset 的值</span><br>    layoutState.mScrollingOffset += layoutChunkResult.mConsumed;<br>        <span class="hljs-comment">// 计算后，回收 limit 线上面的表项</span><br>    recycleByLayoutState(recycler, layoutState);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这，我相信你们就更加的理解了 <strong>LayoutManager</strong> 的<code>回收机制</code>了，也能够将它和<code>添加机制</code>连接起来。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>讲完了 LayoutManager 的添加和回收机制，最后我来总结一下：</p><blockquote><ol><li><p>RecyclerView 在滚动发生之前，会根据预计滚动位移大小来决定需要向列表中填充多少新的表项。</p></li><li><p>RecyclerView 填充表项是通过<code>while</code>循环一个一个实现的，当列表没有剩余空间时，填充表项也就结束了。</p></li><li><p>RecyclerView 滑动发生之前，会计算出一条 <strong>limit 控制线</strong>，它是决定哪些表项该被回收的重要依据。它可以理解为：隐形线当前所在位置，在滚动完成后会和列表顶部重叠</p></li><li><p><strong>limit 控制线</strong>的初始值 &#x3D; 列表当前可见表项的底部到列表底部的距离，即列表在不填充新表项时，可以滑动的最大距离。每一个新填充表项消耗的像素值都会被追加到 limit 值之上，即 <strong>limit 控制线</strong>会随着新表项的填充而不断地下移。</p></li><li><p>触发回收逻辑时，会遍历当前所有表项，若某表项的底部位于 <strong>limit 控制线</strong>下方，则该表项上方的所有表项都会被回收。</p></li></ol></blockquote><p>以上是我对源码的分析与看别人博客所总结，如果有不正确之处，还请大家批评指正~</p><h2 id="五、ItemTouchHelper"><a href="#五、ItemTouchHelper" class="headerlink" title="五、ItemTouchHelper"></a>五、ItemTouchHelper</h2><p>ItemTouchHelper 这个类是我们用来给表项添加各种修饰的帮助类，我们可以用它来实现表项的侧滑删除和拖拽等效果。对于这部分内容，我会先讲一点应用，然后从应用入手跟着源码逐步分析原理。</p><h3 id="（1）ItemTouchHelper基本使用"><a href="#（1）ItemTouchHelper基本使用" class="headerlink" title="（1）ItemTouchHelper基本使用"></a>（1）ItemTouchHelper基本使用</h3><p>首先，实现一个 Callback 继承自 ItemTouchHelper.Callback。重写它的几个重要函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecyclerTouchHelpCallBack</span>(<span class="hljs-keyword">var</span> onCallBack: OnHelperCallBack) : ItemTouchHelper.Callback() &#123;<br>    <br>    <span class="hljs-keyword">var</span> edit = <span class="hljs-literal">false</span><br>    <span class="hljs-comment">// 该函数是用来设置滑动方向的，比如下面的 dragFlags 和 swipeFlags</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMovementFlags</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">recyclerView: <span class="hljs-type">RecyclerView</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">viewHolder</span>: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">V</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">if</span> (!edit) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-comment">// 拖拽方向（上下左右）</span><br>       <span class="hljs-keyword">val</span> dragFlags = ItemTouchHelper.UP or ItemTouchHelper.DOWN <br>        or ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT <br>        <br>        <span class="hljs-comment">// 侧滑删除（左右）</span><br>        <span class="hljs-keyword">val</span> swipeFlags = ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT<br>        <br>        <span class="hljs-keyword">return</span> makeMovementFlags(dragFlags, swipeFlags)<br>&#125;<br>    <br>    <span class="hljs-comment">// 该方法主要用来通知你拖拽的item从哪里移动到了哪里</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMove</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        recyclerView: <span class="hljs-type">RecyclerView</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        viewHolder: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">ViewHolder</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        target: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">ViewHolder</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-comment">// 如果当前拖拽的item与目标item的类型不一样，将无法交换位置</span><br>        <span class="hljs-keyword">if</span> (viewHolder.itemViewType != target.itemViewType) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><br>        <span class="hljs-keyword">val</span> fromPosition = viewHolder.adapterPosition<br>        <span class="hljs-keyword">val</span> targetPosition = target.adapterPosition<br><br>        onCallBack.onMove(fromPosition, targetPosition)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 侧滑的部分我们以删除为例</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSwiped</span><span class="hljs-params">(viewHolder: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">ViewHolder</span>, direction: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 调用Callback的remove将侧滑删除的item移出列表</span><br>        onCallBack.remove(viewHolder, direction, viewHolder.layoutPosition)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">itemMove</span><span class="hljs-params">(adapter: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">Adapter</span>&lt;<span class="hljs-type">RecyclerView</span>.<span class="hljs-type">ViewHolder</span>&gt;, <span class="hljs-keyword">data</span>: <span class="hljs-type">List</span>&lt;*&gt;, fromPosition: <span class="hljs-type">Int</span>, targetPosition: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span>.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (fromPosition &lt; targetPosition) &#123;<br>            <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> fromPosition until targetPosition) &#123;<br>                Collections.swap(<span class="hljs-keyword">data</span>, i, i + <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> targetPosition until fromPosition) &#123;<br>                Collections.swap(<span class="hljs-keyword">data</span>, i, i + <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br><br>        adapter.notifyItemMoved(fromPosition, targetPosition)<br>    &#125;<br>    ...<br>    <span class="hljs-comment">// 后面还有一些功能函数我就不一一列举了，知道这么个流程就行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，主要实现的有三个函数，第一个就是 <strong>getMovementFlags()</strong> ，该方法主要用来设置拖拽和侧滑的方向，第二个是 <strong>onMove()</strong> ，该方法用来设置拖拽的 item 的起始位置和目的地。然后通过 <strong>itemMove()</strong> 方法将拖拽的 item 移动到目的地，剩下的 item 依次前移或后移。第三个就是 <strong>onSwiped()</strong> 用于实现侧滑的方法。</p><p>接下里就是Activity中的代码了，我只展示其中主要的一些代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">callback = RecyclerTouchHelpCallBack(<span class="hljs-keyword">object</span> : RecyclerTouchHelpCallBack.OnHelperCallBack &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMove</span><span class="hljs-params">(fromPosition: <span class="hljs-type">Int</span>, targetPosition: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 移动item</span><br>        callback.itemMove(adapter, adapter.mData, fromPosition, targetPosition)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSelectedChanged</span><span class="hljs-params">(viewHolder: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">ViewHolder</span>, actionState: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 选中的改变样式</span><br>        viewHolder.itemView.alpha = <span class="hljs-number">1f</span><br>        viewHolder.itemView.scaleX = <span class="hljs-number">1.2f</span><br>        viewHolder.itemView.scaleY = <span class="hljs-number">1.2f</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clearView</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        recyclerView: <span class="hljs-type">RecyclerView</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        viewHolder: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">ViewHolder</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        callback.edit = <span class="hljs-literal">false</span><br>        <span class="hljs-comment">// 完成移动，选中的改变样式</span><br>        adapter.mData<br>        viewHolder.itemView.alpha = <span class="hljs-number">1f</span><br>        viewHolder.itemView.scaleY = <span class="hljs-number">1f</span><br>        viewHolder.itemView.scaleX = <span class="hljs-number">1f</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">remove</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        viewHolder: <span class="hljs-type">RecyclerView</span>.<span class="hljs-type">ViewHolder</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        direction: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        position: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>    <span class="hljs-comment">// </span><br>        adapter.removeData(position)<br>    &#125;<br><br>&#125;)<br><br>ItemTouchHelper(callback).attachToRecyclerView(binding.rvItem)<br></code></pre></td></tr></table></figure><p>这里的 <strong>Callback</strong> 就是为了实现我们定义的接口，然后具体实现其功能，其实最主要的还是最后一行代码，这一行的主要作用我一会会通过源码进行分析。</p><p>这就是 ItemTouchHelper 的基本使用，其实挺简单的，作用就是辅助 RecyclerView 对其子视图添加一些额外的功能。但我们学习嘛，就要知其然还要知其所以然。接下来我会从 <strong>attachToRecyclerView()</strong> 入手，这个就是入口方法，我们逐步分析实现原理。</p><h3 id="（2）ItemTouchHelper原理"><a href="#（2）ItemTouchHelper原理" class="headerlink" title="（2）ItemTouchHelper原理"></a>（2）ItemTouchHelper原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachToRecyclerView</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> RecyclerView recyclerView)</span> &#123;<br><span class="hljs-keyword">if</span> (mRecyclerView == recyclerView) &#123;<br>        <span class="hljs-comment">// 如果已经赋值过了，就直接返回，不执行后面的操作</span><br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// nothing to do</span><br>    &#125;<br>    <span class="hljs-comment">// 如果 mRecyclerView 不为 null 就摧毁重置</span><br>    <span class="hljs-keyword">if</span> (mRecyclerView != <span class="hljs-literal">null</span>) &#123;<br>    destroyCallbacks();<br>    &#125;<br>    mRecyclerView = recyclerView;<br>    <span class="hljs-keyword">if</span> (recyclerView != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Resources</span> <span class="hljs-variable">resources</span> <span class="hljs-operator">=</span> recyclerView.getResources();<br>        mSwipeEscapeVelocity = resources<br>        .getDimension(R.dimen.item_touch_helper_swipe_escape_velocity);<br>        mMaxSwipeVelocity = resources<br>                .getDimension(R.dimen.item_touch_helper_swipe_escape_max_velocity);<br>        setupCallbacks();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法就是将我们自己的 RecyclerView 与源码中的 RV 绑定，然后对其进行一系列的操作。最后，该方法继续调用 setupCallbacks() </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setupCallbacks</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ViewConfiguration</span> <span class="hljs-variable">vc</span> <span class="hljs-operator">=</span> ViewConfiguration.get(mRecyclerView.getContext());<br>    <span class="hljs-comment">// 注意这个变量 mSlop 后面会提</span><br>    mSlop = vc.getScaledTouchSlop();<br>    mRecyclerView.addItemDecoration(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">// 添加 Item 触摸监听器，后面会用到，里面包含 onInterceptTouchEvent()、onTouchEvent()</span><br>    mRecyclerView.addOnItemTouchListener(mOnItemTouchListener);<br>    mRecyclerView.addOnChildAttachStateChangeListener(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">// 启动手势检测，检测是不是长按操作</span><br>    startGestureDetection();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们沿着调用链一步一步走，startGestureDetection() 启动手势检测</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startGestureDetection</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// new 一个监听器对象，对用户手势进行监听</span><br>    mItemTouchHelperGestureListener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemTouchHelperGestureListener</span>();<br>    mGestureDetector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GestureDetectorCompat</span>(mRecyclerView.getContext(),<br>            mItemTouchHelperGestureListener);<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是检测是否为长按动作的具体方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemTouchHelperGestureListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GestureDetector</span>.SimpleOnGestureListener &#123;<br>    ...<br>    <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLongPress</span><span class="hljs-params">(MotionEvent e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!mShouldReactToLongPress) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>        <span class="hljs-comment">// 先找到子视图，onLongPress()在 GestureDetectorCompat类中调用，</span><br>        <span class="hljs-comment">// 然后将e传进来，通过刚才的startGestureDetection方法</span><br>        <span class="hljs-comment">// findChildView()就是通过获取event坐标定位到子视图的</span><br>    <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> findChildView(e);<br>    <span class="hljs-keyword">if</span> (child != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 获取子视图对应的ViewHolder，接下来对ViewHolder进行操作</span><br>        <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">vh</span> <span class="hljs-operator">=</span> mRecyclerView.getChildViewHolder(child);<br>        <span class="hljs-keyword">if</span> (vh != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">if</span> (!mCallback.hasDragFlag(mRecyclerView, vh)) &#123;<br>             <span class="hljs-keyword">return</span>;<br>            &#125;<br>                <span class="hljs-comment">// 对这个pointerId不了解的请移步最后的补充项</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">pointerId</span> <span class="hljs-operator">=</span> e.getPointerId(<span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// Long press is deferred.</span><br>            <span class="hljs-comment">// Check w/ active pointer id to avoid selecting after motion</span><br>            <span class="hljs-comment">// event is canceled.</span><br>            <span class="hljs-keyword">if</span> (pointerId == mActivePointerId) &#123;<br>               <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> e.findPointerIndex(mActivePointerId);<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> e.getX(index);<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> e.getY(index);<br>                mInitialTouchX = x;<br>                mInitialTouchY = y;<br>                mDx = mDy = <span class="hljs-number">0f</span>;<br>                <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>                    Log.d(TAG,<br>                        <span class="hljs-string">&quot;onlong press: x:&quot;</span> + mInitialTouchX + <span class="hljs-string">&quot;,y:&quot;</span> + mInitialTouchY);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (mCallback.isLongPressDragEnabled()) &#123;<br>                        <span class="hljs-comment">// 通过select()方法选中当前ViewHolder，以便对其进行拖拽操作</span><br>                        <span class="hljs-comment">// select()方法主要就是选中功能</span><br>                        <span class="hljs-comment">// 将 FLAG = ACTION_STATE_DRAG 传入，代表是拖拽操作</span><br>                   select(vh, ACTION_STATE_DRAG);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看一下 <strong>findChildView()</strong> 是怎么进行寻找子视图的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">View <span class="hljs-title function_">findChildView</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-comment">// first check elevated views, if none, then call RV</span><br>    <span class="hljs-comment">// 获取触摸点相对于view的坐标</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> event.getX();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> event.getY();<br>    <span class="hljs-comment">// mSelected != null 即当前选中了一个子视图</span><br>    <span class="hljs-keyword">if</span> (mSelected != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 获取选中的ViewHolder对应的View，然后将其返回，这样就找到的View实例</span><br>        <span class="hljs-comment">// mSelected是一个ViewHolder对象</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">selectedView</span> <span class="hljs-operator">=</span> mSelected.itemView;<br>        <span class="hljs-keyword">if</span> (hitTest(selectedView, x, y, mSelectedStartX + mDx, mSelectedStartY + mDy)) &#123;<br>            <span class="hljs-keyword">return</span> selectedView;<br>        &#125;<br>    &#125;<br>    ...<br>    <span class="hljs-comment">// 我们先只考虑选中的情况</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的 <strong>onLongPress()</strong> 是我们用来监听手指是否进行了长按的操作，同样的，肯定还有方法可以监听手指是否进行了侧滑操作，从源码中看，我们发现是 <strong>checkSelectForSwipe()</strong> 进行侧滑操作的判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">checkSelectForSwipe</span><span class="hljs-params">(<span class="hljs-type">int</span> action, MotionEvent motionEvent, <span class="hljs-type">int</span> pointerIndex)</span> &#123;<br>    <span class="hljs-comment">// 一些判断是否是侧滑操作的代码，无关紧要，如果不是就返回</span><br>    <span class="hljs-keyword">if</span> (mSelected != <span class="hljs-literal">null</span> || action != MotionEvent.ACTION_MOVE<br>    || mActionState == ACTION_STATE_DRAG || !mCallback.isItemViewSwipeEnabled()) &#123;<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mRecyclerView.getScrollState() == RecyclerView.SCROLL_STATE_DRAGGING) &#123;<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ...<br>    <span class="hljs-comment">// mDx and mDy are only set in allowed directions. We use custom x/y here instead of</span><br>    <span class="hljs-comment">// updateDxDy to avoid swiping if user moves more in the other direction</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> motionEvent.getX(pointerIndex);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> motionEvent.getY(pointerIndex);<br><br>    <span class="hljs-comment">// Calculate the distance moved -&gt; 计算滑动距离</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> x - mInitialTouchX;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">dy</span> <span class="hljs-operator">=</span> y - mInitialTouchY;<br>    <span class="hljs-comment">// swipe target is chose w/o applying flags so it does not really check if swiping in that</span><br>    <span class="hljs-comment">// direction is allowed. This why here, we use mDx mDy to check slope value again.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">absDx</span> <span class="hljs-operator">=</span> Math.abs(dx);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">absDy</span> <span class="hljs-operator">=</span> Math.abs(dy);<br><br>    <span class="hljs-comment">// 这里的 mSlop 在上面提到的 setupCallbacks() 中被赋值</span><br>    <span class="hljs-comment">// 主要用于解决滑动冲突，如果我们侧滑的距离不够则不进行下一步操作（如删除），直接返回</span><br>    <span class="hljs-comment">// 只有滑动的距离大于 mSlop 值，才继续执行</span><br>    <span class="hljs-comment">// 说起来，和我们的日常习惯对上了</span><br>    <span class="hljs-keyword">if</span> (absDx &lt; mSlop &amp;&amp; absDy &lt; mSlop) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 下面一部分代码也是判断滑动距离的</span><br>    ...<br>    <span class="hljs-comment">// 这里也通过 select() 方法进行选中操作</span><br>    <span class="hljs-comment">// 将 FLAG = ACTION_STATE_SWIPE 传入，代表是侧滑操作</span><br>    select(vh, ACTION_STATE_SWIPE);<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，了解了如何判断手势进行了何种操作，接下来我们该重点研究 <strong>select()</strong> 方法了，这是一个十分重要的方法，我们需要通过它来选中我们想要进行拖拽或侧滑操作的View。然后对其进行具体的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ViewHolder selected, <span class="hljs-type">int</span> actionState)</span> &#123;<br>    <span class="hljs-comment">// 如果已经选中就直接返回</span><br>    <span class="hljs-keyword">if</span> (selected == mSelected &amp;&amp; actionState == mActionState) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ...<br>    <span class="hljs-comment">// 赋值操作，之前的状态</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">prevActionState</span> <span class="hljs-operator">=</span> mActionState;<br>    mActionState = actionState;<br>    <span class="hljs-comment">// 执行当前状态为&#x27;拖拽&#x27;的操作</span><br>    <span class="hljs-keyword">if</span> (actionState == ACTION_STATE_DRAG) &#123;<br>        <span class="hljs-comment">// 如果没有选中一个item，就抛出异常</span><br>        <span class="hljs-keyword">if</span> (selected == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Must pass a ViewHolder when dragging&quot;</span>);<br>        &#125;<br><span class="hljs-comment">// 为选中的子视图设置绘制监听，主要为了设置绘制的顺序</span><br>        mOverdrawChild = selected.itemView;<br>        addChildDrawingOrderCallback();<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">if</span> (mSelected != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">prevSelected</span> <span class="hljs-operator">=</span> mSelected;<br>        <span class="hljs-keyword">if</span> (prevSelected.itemView.getParent() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果之前的状态是拖拽，则给swipeDir赋值为0，否则执行swipeIfNecessary()操作</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">swipeDir</span> <span class="hljs-operator">=</span> prevActionState == ACTION_STATE_DRAG ? <span class="hljs-number">0</span><br>                    : swipeIfNecessary(prevSelected);<br>            <span class="hljs-type">int</span> animationType;<br>            ...<br>            <span class="hljs-comment">// 执行一系列判断操作，代码简单我就不过多解释了</span><br>            <span class="hljs-keyword">if</span> (prevActionState == ACTION_STATE_DRAG) &#123;<br>                animationType = ANIMATION_TYPE_DRAG;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (swipeDir &gt; <span class="hljs-number">0</span>) &#123;<br>                animationType = ANIMATION_TYPE_SWIPE_SUCCESS;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                animationType = ANIMATION_TYPE_SWIPE_CANCEL;<br>            &#125;<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            removeChildDrawingOrderCallbackIfNecessary(prevSelected.itemView);<br>            mCallback.clearView(mRecyclerView, prevSelected);<br>        &#125;<br>        <span class="hljs-comment">// 将选中状态置为空</span><br>        mSelected = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (selected != <span class="hljs-literal">null</span>) &#123;<br>        mSelectedFlags =<br>                (mCallback.getAbsoluteMovementFlags(mRecyclerView, selected) &amp; actionStateMask)<br>                        &gt;&gt; (mActionState * DIRECTION_FLAG_COUNT);<br>        mSelectedStartX = selected.itemView.getLeft();<br>        mSelectedStartY = selected.itemView.getTop();<br>        mSelected = selected;<br><br>        <span class="hljs-keyword">if</span> (actionState == ACTION_STATE_DRAG) &#123;<br>            mSelected.itemView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);<br>        &#125;<br>    &#125;<br>    ...<br>    <span class="hljs-comment">// 这是一个ItemTouchUIUtil的一个接口，需要我们自己来实现具体功能，比如选中改变item的样式</span><br>    mCallback.onSelectedChanged(mSelected, mActionState);<br>    <span class="hljs-comment">// 刷新拖拽或侧滑更新后的位置</span><br>    mRecyclerView.invalidate();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们自己实现的 <strong>onSelectedChanged()</strong> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 长按时调用</span><br>override fun <span class="hljs-title function_">onSelectedChanged</span><span class="hljs-params">(viewHolder: RecyclerView.ViewHolder?, actionState: Int)</span> &#123;<br><span class="hljs-built_in">super</span>.onSelectedChanged(viewHolder, actionState)<br>    viewHolder?.let &#123;<br>    onCallBack.onSelectedChanged(viewHolder, actionState)<br>    &#125;<br>&#125;<br><br>override fun <span class="hljs-title function_">onSelectedChanged</span><span class="hljs-params">(viewHolder: RecyclerView.ViewHolder, actionState: Int)</span> &#123;<br><span class="hljs-comment">// 选中的改变样式</span><br>viewHolder.itemView.alpha = <span class="hljs-number">1f</span><br>viewHolder.itemView.scaleX = <span class="hljs-number">1.2f</span><br>viewHolder.itemView.scaleY = <span class="hljs-number">1.2f</span><br>&#125;<br></code></pre></td></tr></table></figure><p>好了，看了这么多源码以及我对部分源码的讲解，我们现在来总结一下整个流程，这个过程也是在教大家如何看源码，在源码中找到关键之处。</p><blockquote><p>我们通过<code>ItemTouchHelper</code>实现拖拽，侧滑功能，为了实现这两个功能，我们得先要将我们自己的<code>RecyclerView</code>和源码中的绑定，然后进行手势操作的监听，监听我们对<code>item</code>进行了何种操作，是侧滑操作还是长按拖拽操作。我们记得是通过 <strong>onLongPress()</strong> 和 <strong>checkSelectForSwipe()</strong> 两个方法来判断的，判断之后，两个方法都调用了 <strong>select()</strong> 来选中执行的 Item。关于 select() 方法呢，我还有一点补充：</p><ol><li><p>如果处于手势开始阶段，即<code>selected</code>不为null，那么会通过<code>getAbsoluteMovementFlags</code>方法来获取执行我们设置的flag，这个方法就是我们通过 <strong>checkSelectForSwipe()</strong> 和 <strong>onLongPress()</strong> 传进来的，上面也讲到了。这样我们就知道执行哪些行为(侧滑或者拖动)和方向(上、下、左和右)。同时还会记录下被选中<code>ItemView</code>的位置。简而言之，就是一些变量的初始化。</p></li><li><p>如果处于手势释放阶段，即<code>selected</code>为null，同时<code>mSelected</code>不为null，那么此时需要做的事情就稍微有一点复杂。手势释放之后，需要做的事情无非有两件：1. 相关的<code>ItemView</code>到正确的位置，就比如说，如果滑动条件不满足，那么就返回原来的位置，这个就是一个动画；2. 清理操作，比如说将<code>mSelected</code>重置为null之类的。</p></li></ol></blockquote><p>到了这里，我们已经可以对自己的 RecyclerView 的 Item 选中并进行下一步操作了。我们先带着一个疑问来继续分析，那就是我们怎么让选中的 Item 跟随我们的手指进行移动呢？</p><p>我们知道，View 的 <strong>onTouchEvent()</strong> 方法是专门对触摸事件进行操作的，那我们就从源码中找到这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onTouchEvent</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> RecyclerView recyclerView, <span class="hljs-meta">@NonNull</span> MotionEvent event)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 如果速度轨迹不为空，就是当前有触摸事件，将该event添加进去</span><br>    <span class="hljs-keyword">if</span> (mVelocityTracker != <span class="hljs-literal">null</span>) &#123;<br>        mVelocityTracker.addMovement(event);<br>    &#125;<br>    <span class="hljs-comment">// 当前的手势操作ID为NONE，直接返回</span><br>    <span class="hljs-keyword">if</span> (mActivePointerId == ACTIVE_POINTER_ID_NONE) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取该event的Id,对MotionEvent不太懂的移步 -&gt; &#x27;补充&#x27;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> event.getActionMasked();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">activePointerIndex</span> <span class="hljs-operator">=</span> event.findPointerIndex(mActivePointerId);<br>    <span class="hljs-comment">// 进行是否为侧滑事件的判断</span><br>    <span class="hljs-keyword">if</span> (activePointerIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>        checkSelectForSwipe(action, event, activePointerIndex);<br>    &#125;<br>    <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">viewHolder</span> <span class="hljs-operator">=</span> mSelected;<br>    <span class="hljs-comment">// 如果没选中 ViewHolder 直接返回</span><br>    <span class="hljs-keyword">if</span> (viewHolder == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">switch</span> (action) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>            <span class="hljs-comment">// Find the index of the active pointer and fetch its position</span><br>            <span class="hljs-keyword">if</span> (activePointerIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>                updateDxDy(event, mSelectedFlags, activePointerIndex);<br>                moveIfNecessary(viewHolder);<br>                mRecyclerView.removeCallbacks(mScrollRunnable);<br>                mScrollRunnable.run();<br>                mRecyclerView.invalidate();<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 被其他事件拦截的处理，将轨迹清除</span><br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:<br>            <span class="hljs-keyword">if</span> (mVelocityTracker != <span class="hljs-literal">null</span>) &#123;<br>                mVelocityTracker.clear();<br>            &#125;<br>        <span class="hljs-comment">// fall through</span><br>        <span class="hljs-comment">// 手指抬起，将Id置为NONE，退出switch</span><br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<br>            select(<span class="hljs-literal">null</span>, ACTION_STATE_IDLE);<br>            mActivePointerId = ACTIVE_POINTER_ID_NONE;<br>            <span class="hljs-keyword">break</span>;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对 onTouchEvent() 我对这个方法讲的很清楚，也相信大家明白了大致流程，其中对我们来说最重要的就是 <strong>ACTION_MOVE</strong> ，在这里面的就是我们手指滑动过程中进行的。我们对这里面的代码一行一行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>    <span class="hljs-comment">// Find the index of the active pointer and fetch its position</span><br>    <span class="hljs-keyword">if</span> (activePointerIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>        updateDxDy(event, mSelectedFlags, activePointerIndex);<br>        moveIfNecessary(viewHolder);<br>        mRecyclerView.removeCallbacks(mScrollRunnable);<br>        mScrollRunnable.run();<br>        mRecyclerView.invalidate();<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一步：更新<code>mDx</code>和<code>mDy</code>的值。<code>mDx</code>和<code>mDy</code>表示手指在x轴和y轴上分别滑动的距离，将<code>mSelectedFlags</code>和<code>activePointerIndex</code>作为参数传过去，第一个代表选中的操作，是侧滑还是拖拽；第二个是当前触摸事件的Id，唯一标识。</p><p>第二步：如果需要，移动其他<code>ItemView</code>的位置。这个主要针对拖动行为，我们具体来看看这部分的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">moveIfNecessary</span><span class="hljs-params">(ViewHolder viewHolder)</span> &#123;<br>    <span class="hljs-comment">// 下面这些代码都是不符合 move 的条件</span><br>    ...<br>    <span class="hljs-comment">// 找可能会交换位置的ItemView</span><br>    List&lt;ViewHolder&gt; swapTargets = findSwapTargets(viewHolder);<br>    <span class="hljs-keyword">if</span> (swapTargets.size() == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// may swap. -&gt; 找到符合条件交换的ItemView</span><br>    <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> mCallback.chooseDropTarget(viewHolder, swapTargets, x, y);<br>    <span class="hljs-keyword">if</span> (target == <span class="hljs-literal">null</span>) &#123;<br>        mSwapTargets.clear();<br>        mDistances.clear();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">toPosition</span> <span class="hljs-operator">=</span> target.getAdapterPosition();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">fromPosition</span> <span class="hljs-operator">=</span> viewHolder.getAdapterPosition();<br>    <span class="hljs-comment">// 回调Callback里面的onMove方法，这个方法需要我们手动实现，在基本使用里有，大家可以上去翻翻</span><br>    <span class="hljs-keyword">if</span> (mCallback.onMove(mRecyclerView, viewHolder, target)) &#123;<br>        <span class="hljs-comment">// keep target visible</span><br>        mCallback.onMoved(mRecyclerView, viewHolder, fromPosition,<br>                target, toPosition, x, y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总的来说，分为三步：</p><ol><li><p>调用<code>findSwapTarget</code>方法，寻找可能会跟选中的<code>Item</code>交换位置的<code>Item</code>。这里判断的条件是只要选中的<code>Item</code>跟某一个<code>Item</code>重叠，那么这个<code>Item</code>可能会跟选中的<code>Item</code>交换位置。</p></li><li><p>调用Callback的<code>chooseDropTarget</code>方法来找到符合交换条件的<code>Item</code>。这里符合的条件是指，选中的<code>Item</code>的<code>bottom</code>大于目标<code>Item</code>的<code>bottom</code>或者<code>Item</code>的<code>top</code>大于目标<code>Item</code>的<code>top</code>。一般我们可以重写<code>chooseDropTarget</code>方法，来定义什么条件下就交换位置。</p></li><li><p>回调<code>Callback</code>的<code>onMove</code>方法,这个方法需要我们自己实现。这里需要注意的是，如果<code>onMove</code>方法返回为true的话，会调用<code>Callback</code>另一个<code>onMove</code>方法来保证target可见。为什么必须保证target可见呢？从官方文档上来看的话，如果target不可见，在某些滑动的情形下，target会被remove掉。</p></li></ol><p>刚才说，<code>findSwapTargets()</code> 是找到可能会交换位置的<code>item</code>，而<code>chooseDropTarget()</code>是找到会交换位置的<code>item</code>就直接交换，听起来好抽象，那二者具体有什么区别呢？其中<code>findSwapTarget</code>方法是找到可能会交换位置的<code>ItemView</code>，<code>chooseDropTarget</code>方法是找到一定会交换位置的<code>ItemView</code>，这是两个方法的不同点。同时，如果此时在拖动，但是拖动的<code>ItemView</code>还未达到交换条件，也就是跟另一个<code>ItemView</code>只是重叠了一小部分，这种情况下，<code>findSwapTargets</code>方法返回的集合不为空，但是<code>chooseDropTarget</code>方法寻找的<code>ItemView</code>为空。</p></blockquote><p>第三步：如果当页展示的<code>Item</code>不符合条件，需要拖拽到更远的地方，这时就需要滑动<code>RecyclerView</code>。这个主要针对拖拽行为，此时如果拖动一个<code>ItemView</code>达到<code>RecyclerView</code>的底部或者顶部，会滑动<code>RecyclerView</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">mScrollRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (mSelected != <span class="hljs-literal">null</span> &amp;&amp; scrollIfNecessary()) &#123;<br>            <span class="hljs-keyword">if</span> (mSelected != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//it might be lost during scrolling</span><br>                moveIfNecessary(mSelected);<br>            &#125;<br>            mRecyclerView.removeCallbacks(mScrollRunnable);<br>            ViewCompat.postOnAnimation(mRecyclerView, <span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在<code>run</code>方法里面通过<code>scrollIfNecessary</code>方法来判断<code>RecyclerView</code>是否滚动，如果需要滚动,<code>scrollIfNecessary</code>方法会自动完成滚动操作。</p><p>第四步：这步就是更新侧滑或者拖拽完成之后的视图了。<code>ItemView</code>在随着手指移动时，变化的是<code>translationX</code>和<code>translationY</code>两个属性，所以只需要调用<code>invalidate</code>方法就行。调用<code>invalidate</code>方法之后，相当于<code>RecyclerView</code>会重新绘制一次，那么所有<code>ItemDecoration</code>的<code>onDraw</code>和<code>onDrawOver</code>方法都会被调用，而恰好的是，<code>ItemTouchHelper</code>继承了<code>ItemDecoration</code>。而绘制的方法就是 <strong>onDraw()</strong> 。我们具体来看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas c, RecyclerView parent, RecyclerView.State state)</span> &#123;<br>    <span class="hljs-comment">// we don&#x27;t know if RV changed something so we should invalidate this index.</span><br>    mOverdrawChildPosition = -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">float</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, dy = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (mSelected != <span class="hljs-literal">null</span>) &#123;<br>        getSelectedDxDy(mTmpPosition);<br>        dx = mTmpPosition[<span class="hljs-number">0</span>];<br>        dy = mTmpPosition[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// 这里又调用了 Callback 的 onDraw 方法</span><br>    mCallback.onDraw(c, parent, mSelected,<br>            mRecoverAnimations, mActionState, dx, dy);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas c, RecyclerView parent, ViewHolder selected,</span><br><span class="hljs-params">        List&lt;ItemTouchHelper.RecoverAnimation&gt; recoverAnimationList,</span><br><span class="hljs-params">        <span class="hljs-type">int</span> actionState, <span class="hljs-type">float</span> dX, <span class="hljs-type">float</span> dY)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">recoverAnimSize</span> <span class="hljs-operator">=</span> recoverAnimationList.size();<br>    ...<br>    <span class="hljs-keyword">if</span> (selected != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> c.save();<br>        onChildDraw(c, parent, selected, dX, dY, actionState, <span class="hljs-literal">true</span>);<br>        c.restoreToCount(count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>onChildDraw</code>方法，将所有正在交换位置的<code>ItemView</code>和被选中的<code>ItemView</code>作为参数传递过去。而在<code>onChildDraw</code>方法里面，调用了<code>ItemTouchUIUtil</code>的<code>onDraw</code>方法。我们从<code>ItemTouchUiUtil</code>的实现类<code>BaseImpl</code>找到答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas c, RecyclerView recyclerView, View view,</span><br><span class="hljs-params"><span class="hljs-type">float</span> dX, <span class="hljs-type">float</span> dY, <span class="hljs-type">int</span> actionState, <span class="hljs-type">boolean</span> isCurrentlyActive)</span> &#123;<br>    view.setTranslationX(dX);<br>    view.setTranslationY(dY);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里改变了每个<code>ItemView</code>的<code>translationX</code>和<code>translationY</code>，从而实现了<code>ItemView</code>随着手指移动的效果。从这里，我们可以看出来，一旦调用<code>RecyclerView</code>的<code>invalidate</code>方法，<code>ItemTouchHelper</code>的<code>onDraw</code>方法和<code>onDrawOver</code>方法都会被执行。</p><h2 id="六、补充"><a href="#六、补充" class="headerlink" title="六、补充"></a>六、补充</h2><p>我找到了一些题外知识，但与RV有关的文章，对于前面有些内容不懂的小伙伴可以参考一下~</p><p>（1）<a href="https://juejin.cn/post/6926439885742014472#heading-16">MotionEvent详解</a></p><p>（2）<a href="https://blog.csdn.net/qq_46526828/article/details/117296001?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165771516516782248539532%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165771516516782248539532&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-11-117296001-null-null.142%5Ev32%5Econtrol,185%5Ev2%5Econtrol&utm_term=listview%E5%92%8Crecyclerview%E7%BC%93%E5%AD%98&spm=1018.2226.3001.4187">ListView和RecyclerView缓存对比</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin协程</title>
    <link href="/2022/09/21/Kotlin%E5%8D%8F%E7%A8%8B/"/>
    <url>/2022/09/21/Kotlin%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Kotlin协程"><a href="#Kotlin协程" class="headerlink" title="Kotlin协程"></a>Kotlin协程</h1><h2 id="一、Kotlin协程简介"><a href="#一、Kotlin协程简介" class="headerlink" title="一、Kotlin协程简介"></a>一、Kotlin协程简介</h2><h3 id="1-什么是协程？"><a href="#1-什么是协程？" class="headerlink" title="1. 什么是协程？"></a>1. 什么是协程？</h3><blockquote><p><strong>2022.08.28 起 -&gt; 预计于 2022.09.04 结束</strong></p><p>协程是什么，这个问题在我刚开始学习<code>Kotlin</code>的时候其实很迷茫，最初的理解就是可以实现异步的一段程序，在安卓中可以结合<code>Retrofit</code>用来网络请求。但很显然，这是非常肤浅的。所以，此篇文章用来深入理解一下<strong>Kotlin</strong>中的协程部分。</p></blockquote><p>其实简单来说，协程最核心的就是函数或者一段程序能够被挂起，稍后可以在挂起的位置恢复。根据维基百科的说法：</p><blockquote><p><strong>协程</strong>（英语：coroutine）是计算机程序的一类组件，推广了<a href="https://zh.m.wikipedia.org/wiki/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1">协作式多任务</a>的<a href="https://zh.m.wikipedia.org/wiki/%E5%AD%90%E4%BE%8B%E7%A8%8B">子例程</a>，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程更适合于用来实现彼此熟悉的程序组件，如<a href="https://zh.m.wikipedia.org/wiki/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1">协作式多任务</a>、<a href="https://zh.m.wikipedia.org/wiki/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a>、<a href="https://zh.m.wikipedia.org/wiki/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">事件循环</a>、<a href="https://zh.m.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>、<a href="https://zh.m.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC">无限列表</a>和<a href="https://zh.m.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(%E8%BD%AF%E4%BB%B6)">管道</a>。</p></blockquote><p>协程的挂起和恢复是程序逻辑自己控制的，协程是通过主动挂起出让运行权来实现协作的，所以从本质上来讲讨论协程就是在讨论程序的控制流程。探讨协程最核心的点就是对<strong>挂起</strong>和<strong>恢复</strong>的研究。</p><h3 id="2-相比于线程"><a href="#2-相比于线程" class="headerlink" title="2. 相比于线程"></a>2. 相比于线程</h3><p>协程有些类似于线程，但线程是<strong>抢占式多任务</strong>的，而协程是<strong>协作式多任务</strong>的。这两者有什么区别呢？线程一旦开始执行就不能暂停，直到该任务结束，这个过程都是连续的，不存在协作问题。而协程可以实现任务执行流程的协作调度。而且线程的调度需要借助操作系统，由操作系统进行控制，协程则不需要。同线程相比，协程也更加轻量，不太占用系统资源。</p><h3 id="3-协程的分类"><a href="#3-协程的分类" class="headerlink" title="3. 协程的分类"></a>3. 协程的分类</h3><h4 id="（1）根据是否有调用栈来分类"><a href="#（1）根据是否有调用栈来分类" class="headerlink" title="（1）根据是否有调用栈来分类"></a>（1）根据是否有调用栈来分类</h4><ul><li>有栈协程（Stackful Coroutine）：每一个协程都有自己的调用栈，有点类似于线程的调用栈，这种情况下的协程实现很大程度上接近线程，主要的不同体现在调度上。</li><li>无栈线程（Stackless Coroutine）：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法实现。</li></ul><p>有栈协程的有点是可以在任意函数调用层级的任意位置挂起，并转移调度权，但有栈协程总是会给协程开辟一块栈内存，因此内存开销也大大增加，而无栈协程在内存方面就比较有优势。</p><p>那<code>Kotlin</code>的协程是否有栈呢？如果我们狭义地认为调用栈就只是类似于线程为函数提供的调用栈的话，Kotlin既然无法在任意层次普通函数调用内实现挂起，那么可以将<strong>Kotlin协程</strong>认为是<strong>无栈协程</strong>。（Kotlin的挂起函数，即suspend关键字声明的函数，只能在协程体内或者其他挂起函数内调用，而不能在普通函数内调用，但挂起函数可以随意调用普通函数）。但如果从挂起函数可以实现任意层次嵌套调用内挂起的效果来讲，也可以将<strong>Kotlin协程</strong>视为一种<strong>有栈协程</strong>的实现。但我们大可不必纠结于Kotlin协程是属于哪一类。</p><h4 id="（2）根据调度方式分类"><a href="#（2）根据调度方式分类" class="headerlink" title="（2）根据调度方式分类"></a>（2）根据调度方式分类</h4><ul><li>对称协程（Symmetric Coroutine）：任何一个协程都是相互独立并且平等的，调度权可以在任意协程之间转移。</li><li>非对称协程（Asymmetric Coroutine）：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。</li></ul><p>对称协程实际上非常接近线程了，而非对称协程的调用则更接近我们的思维方式，常见语言对协程的实现也基本上都是非对称协程。例如<strong>async&#x2F;await</strong>，await 时将调度权转移到异步调用中，异步调用返回的结果或抛出异常时总是将调度权转移回 await 的位置。这就是典型的调用于非调用关系。非对称协程在实现上也更加自然，相对容易，而且只要对非对称协程稍作修改就可实现对称协程的能力。</p><p>Kotlin 的挂起函数就是非对称协程的例子，调用者与非调用者的关系是固定的，被调用者运行完毕后只能返回到调用者，而不能返回到其他协程。当然，Kotlin 也有自己的对称协程的实现。还是用几张图来理解一下吧：</p><p>这是对称协程，每个协程调用之后，都将调度权返回给调度器，各协程间是平等的关系。</p><p><img src="https://pic1.zhimg.com/v2-1b5386fdeae8480977e7f9670c819ea0_r.jpg" alt="对称协程"></p><p>这就是非对称协程，只存在调用者和被调用者的关系。</p><p><img src="https://pic3.zhimg.com/80/v2-170ad18468256f3c05afb93895036fae_1440w.jpg" alt="非对称协程"></p><p>当然，不管 Kotlin 到底是属于哪一种协程，我们最终都以讨论其函数的挂起和恢复为主。 </p><h2 id="二、Kotlin协程基础"><a href="#二、Kotlin协程基础" class="headerlink" title="二、Kotlin协程基础"></a>二、Kotlin协程基础</h2><h3 id="1-协程的构造"><a href="#1-协程的构造" class="headerlink" title="1. 协程的构造"></a>1. 协程的构造</h3><h3 id="（1）协程的创建与启动"><a href="#（1）协程的创建与启动" class="headerlink" title="（1）协程的创建与启动"></a>（1）协程的创建与启动</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">val</span> continuation = <span class="hljs-keyword">suspend</span> &#123;<br>    println(<span class="hljs-string">&quot;In Coroutine.&quot;</span>)<br>        <span class="hljs-number">5</span><br>    &#125;.createCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;Coroutine End: <span class="hljs-variable">$result</span>&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context = EmptyCoroutineContext<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过<code>createCoroutine()</code>来创建了一个协程，点进去看看它的源码是咋写的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(<br>    completion: Continuation&lt;T&gt;<br>): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; =<br>    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)<br></code></pre></td></tr></table></figure><ul><li>Receiver 是一个被 suspend 修饰的挂起函数，也是协程的执行体，称他为<strong>协程体</strong>。</li><li>参数 completion 会在协程执行完成后调用，实际上就是协程的完成回调。</li><li>返回值是一个 Continuation 对象，之后会通过这个值启动该协程。</li></ul><p>创建之后，我们在代码中通过调用<code>startCoroutine()</code>函数来启动协程</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> continuation1 = <span class="hljs-keyword">suspend</span> &#123;<br>    println(<span class="hljs-string">&quot;In Coroutine.&quot;</span>)<br>    <span class="hljs-number">5</span><br>&#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Coroutine End: <span class="hljs-variable">$result</span>&quot;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>和创建的过程大差不差，源码也差不多，我们也来分析一下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> ()</span></span> -&gt; T).startCoroutine(<br>    completion: Continuation&lt;T&gt;<br>) &#123;<br>    createCoroutineUnintercepted(completion).intercepted().resume(<span class="hljs-built_in">Unit</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，最后通过 **resume() **函数来启动这个协程。但是为什么通过这个函数就能启动协程呢？由于我们的刨根问底的精神，我们继续深入研究。我们通过 <strong>println(continuation)</strong> 来看看打印出什么。</p><p><img src="https://img-blog.csdnimg.cn/3390acb176d942a482cd59ce24fbcd37.png" alt="结果"></p><p>第一行就是打印出的东西，这是个啥？</p><p>熟悉 java 字节码的同学可能知道，这是指这是一个匿名内部类，但这个匿名内部类哪来的呢？我也不知道，当然是学来的~</p><p>书中描述是编译器根据我们的协程体，就是那个lambda表达式生成的。这个类继承自<strong>SuspendLambda</strong>类，而这个类又是<strong>Continuation</strong>接口的实现类。通过打印出的东西，我们还可以看到另一个东西，<strong>invokeSuspend</strong>， 这个就可以解释这个Suspend Lambda是如何编译的了，这个函数的实现就是协程体。正是因为调用了协程体的 <strong>resume()</strong> 函数才让协程得以执行。</p><p>除此之外，在源码中，还有一组创建和启动的API。这一组API可以为协程体提供一个作用域，在这个作用域内可以直接使用作用域内定义的函数或者状态。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutine(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>): Continuation&lt;<span class="hljs-built_in">Unit</span>&gt; =<br>    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-params">(<span class="hljs-keyword">suspend</span> R.()</span></span> -&gt; T).startCoroutine(<br>    receiver: R,<br>    completion: Continuation&lt;T&gt;<br>) &#123;<br>    createCoroutineUnintercepted(receiver, completion).intercepted().resume(<span class="hljs-built_in">Unit</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对比可以发现，这一组仅仅只多了一个 Receiver 的类型R，这个就是为协程提供作用域的。我们首先来封装一个启动协程的函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R, T&gt;</span> <span class="hljs-title">launchCoroutine</span><span class="hljs-params">(receiver: <span class="hljs-type">R</span>, block: <span class="hljs-type">suspend</span> <span class="hljs-type">R</span>.() -&gt; <span class="hljs-type">T</span>)</span></span> &#123;<br>    block.startCoroutine(receiver, <span class="hljs-keyword">object</span> : Continuation&lt;T&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br>            <span class="hljs-keyword">get</span>() = EmptyCoroutineContext<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>            println(<span class="hljs-string">&quot;Coroutine End: <span class="hljs-variable">$result</span>&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后自定义一个协程作用域。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义一个协程作用域</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerScope</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;produce <span class="hljs-variable">$value</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后调用这个函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callLaunchCoroutine</span><span class="hljs-params">()</span></span>&#123;<br>    launchCoroutine(ProducerScope&lt;<span class="hljs-built_in">Int</span>&gt;()) &#123;<br>        println(<span class="hljs-string">&quot;In Coroutine.&quot;</span>)<br>        <span class="hljs-comment">// 可以直接使用作用域内的函数 produce()</span><br>        produce(<span class="hljs-number">1024</span>)<br>        delay(<span class="hljs-number">1000</span>)<br>        produce(<span class="hljs-number">2048</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们在 <strong>launchCoroutine()</strong> 中调用了 <strong>ProducerScope</strong> 中的函数，结果如下：</p><p><img src="https://img-blog.csdnimg.cn/60027ccab39a4202bf00bb11d3e040bb.png" alt="作用域结果"></p><p>作用域可以用来提供函数支持，当然也可以增加限制。这个时候我们就要用到一个注解 <strong>RestrictsSuspension</strong> ，当作用域在这个注解作用下，在其内部就无法调用外部的挂起函数，就比如 delay()。</p><p><img src="https://img-blog.csdnimg.cn/f7a52253da67494da2452f021544d2e2.png" alt="baocuo"></p><p>可以看到，编译器报错了，这个注解在某些特定的场景下可以避免无效甚至危险的挂起函数的调用。当然我还没遇到这样的场景（汗.)</p><h3 id="（2）协程的挂起"><a href="#（2）协程的挂起" class="headerlink" title="（2）协程的挂起"></a>（2）协程的挂起</h3><p>我们已经知道在 Kotlin 中使用 <strong>suspend</strong> 关键字修饰的函数叫做挂起函数，而挂起函数只能在其他挂起函数或者协程体内调用。接下里我们来看两段挂起函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 挂起函数可以像普通函数一样返回</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc01</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 挂起函数也可以处理异步逻辑</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">suspendFunc02</span><span class="hljs-params">(a: <span class="hljs-type">String</span>, b: <span class="hljs-type">String</span>)</span></span><br>        = suspendCoroutine &#123; continuation -&gt;<br>    thread &#123;<br>        continuation.resumeWith(Result.success(<span class="hljs-number">5</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个都是被 suspend 修饰的挂起函数，但是他们真的都会处于挂起状态吗？答案是否。挂起函数不一定会真的挂起，只有当这个挂起函数处理异步调用时，这个协程才会被挂起。通过编译器我们也可以发现这两个函数哪一个被挂起，哪一个没被挂起。</p><p><img src="https://img-blog.csdnimg.cn/0da302ec5a53401aa0b0d76bd6846e80.png" alt=" 是否挂起"></p><p>很明显，suspendFunc01() 没有被挂起。因为它没有出现异步调用，只相当于一个普通函数。</p><p>通过前面的介绍我们知道，suspendCoroutine() 函数可以返回一个 Continuation 实例，这部分也就是协程体。在协程的内部挂起函数的调用处被称为挂起点，挂起点如果出现了异步调用，那么当前的协程就会被挂起，直到对应的 Continuation 的 resume 函数被调用才会恢复执行。而 <strong>suspendFunc02()</strong> 挂起点处就有异步调用，所以它是被挂起的。</p><p>所以为什么普通函数不能调用挂起函数呢？原因就是普通函数中没有 Continuation 实例，而挂起函数要被挂起 <strong>Continuation 实例是必需的</strong>，编译器能够对这个实例进行正确传递。</p><h3 id="（3）协程的上下文"><a href="#（3）协程的上下文" class="headerlink" title="（3）协程的上下文"></a>（3）协程的上下文</h3><p>在前面讲到协程的创建与启动时，可以看到，除了 resumeWith() 函数，还有一个 context，也就是上下文。熟悉安卓开发的肯定对这个都不陌生，它承载了<strong>资源获取、配置管理</strong>等重要工作，在很多控件中，这个 context 都必不可少，那它在协程中有什么用呢？协程的上下文也是大同小异，它的数据结构特征更加的显著，比较类似于List，Map等经典数据结构。先来看看它的主要源码叭~</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Key</span>&lt;<span class="hljs-type">E : Element</span>&gt;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> : <span class="hljs-type">CoroutineContext</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A key of this coroutine context element.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> key: Key&lt;*&gt;<br>    <br>    <span class="hljs-comment">// 通过该方法根据 key 返回一个Element(一个CoroutineContext类型的元素)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;E : Element&gt;</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;<span class="hljs-type">E</span>&gt;)</span></span>: E? =<br>        <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) <span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> E <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">fold</span><span class="hljs-params">(initial: <span class="hljs-type">R</span>, operation: (<span class="hljs-type">R</span>, <span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R =<br>        operation(initial, <span class="hljs-keyword">this</span>)<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">minusKey</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext =<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.key == key) EmptyCoroutineContext <span class="hljs-keyword">else</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Element 接口中有一个属性 <strong>key</strong>，这个 key 就是协程上下文这个集合中元素的索引，有点像 List 的索引 index ，但不同的是这个 key “长”在了数据的里面，这就意味着协程上下文一创建就找到了自己的位置。下面我们就来为协程上下文添加一些简单元素。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CoroutineName</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String): AbstractCoroutineContextElement(Key)&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key: CoroutineContext.Key&lt;CoroutineName&gt;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span> = name<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CoroutineExceptionHandler</span>(<span class="hljs-keyword">val</span> onErrorAction: (Throwable) -&gt; <span class="hljs-built_in">Unit</span>)<br>    : AbstractCoroutineContextElement(Key)&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key: CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(error: <span class="hljs-type">Throwable</span>)</span></span>&#123;<br>        error.printStackTrace()<br>        onErrorAction(error)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个就是要添加到上下文中的类，都继承自抽象类 **AbstractCoroutineContextElement()**，而这个类是 Element 类型的。究其根本还是一个 ContinuationContext 对象。第一个类是为协程实现一个名字，第二个类是协程异常处理器的实现。他们是如何添加到上下文中的呢？莫急，且看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> coroutineContext: CoroutineContext = EmptyCoroutineContext<br>    coroutineContext += CoroutineName(<span class="hljs-string">&quot;test1&quot;</span>)<br>    coroutineContext += CoroutineExceptionHandler &#123;<br>        println(it)<br>    &#125;<br><br><span class="hljs-comment">//    第二种写法</span><br><span class="hljs-comment">//    coroutineContext += CoroutineName(&quot;test1&quot;) + CoroutineExceptionHandler &#123;</span><br><span class="hljs-comment">//        println(it)</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-keyword">suspend</span> &#123;<br>        println(<span class="hljs-string">&quot;In Coroutine [<span class="hljs-subst">$&#123;coroutineContext[CoroutineName]&#125;</span>].&quot;</span>)<br>        <span class="hljs-comment">// throw ArithmeticException()</span><br>        <span class="hljs-number">100</span><br>    &#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br><br>        <span class="hljs-comment">// 将定义好的 continuationContext 赋值给 context</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context = coroutineContext<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span> &#123;<br>            result.onFailure &#123;<br>                context[CoroutineExceptionHandler]?.onError(it)<br>            &#125;.onSuccess &#123;<br>                println(<span class="hljs-string">&quot;Result <span class="hljs-variable">$it</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是很像集合元素的添加？没错，就是这么简单。这样我们就知道协程上下文的设置和获取的方法了。当然，上下文不止有这么点作用，通过我对官方文档的调查，协程上下文还包含一个 <em>协程调度器</em> （参见 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a>）它确定了相关的协程在哪个线程或哪些线程上执行。协程调度器可以将协程限制在一个特定的线程执行，或将它分派到一个线程池，亦或是让它不受限地运行。</p><p>所有的协程构建器诸如 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch</a> 和 <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> 接收一个可选的 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a> 参数，它可以被用来显式的为一个新协程或其它上下文元素指定一个调度器。这些只作为了解，深入研究还待学习。</p><h3 id="（4）协程的拦截器"><a href="#（4）协程的拦截器" class="headerlink" title="（4）协程的拦截器"></a>（4）协程的拦截器</h3><p>在协程上下文的基础上，标准库中还提供了另一个组件，就是拦截器，它允许我们拦截协程异步回调时的恢复调用，简单来说就是在异步回调的过程中为这个回调添加一些东西，比如添加个日志，甚至还可以在这个过程中控制线程的切换。</p><p>拦截器其实也是上下文的一种实现，我们定义好一个拦截器之后赋值给 context 就行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogInterceptor</span> : <span class="hljs-type">ContinuationInterceptor</span> &#123;<br>    <span class="hljs-comment">// 为 key 赋值</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key = ContinuationInterceptor<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">interceptContinuation</span><span class="hljs-params">(continuation: <span class="hljs-type">Continuation</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span><br>            = LogContinuation(continuation)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogContinuation</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;)<br>    : Continuation&lt;T&gt; <span class="hljs-keyword">by</span> continuation &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;before resumeWith: <span class="hljs-variable">$result</span>&quot;</span>)<br>        continuation.resumeWith(result)<br>        println(<span class="hljs-string">&quot;after resumeWith.&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">suspend</span> &#123;<br>        suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Kotlin&quot;</span>)<br>        suspendFunc02(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Coroutine&quot;</span>)<br>    &#125;.startCoroutine(<span class="hljs-keyword">object</span> : Continuation&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>        <span class="hljs-comment">// 将拦截器赋值给context</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context = LogInterceptor()<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span> &#123;<br>            result.getOrThrow()<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
