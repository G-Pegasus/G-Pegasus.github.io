

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="Android性能优化性能优化是一个app很重要的一部分，一个性能优良的app从被下载到启动到使用都能给用户到来很好的体验。自然我们做性能优化也是从被下载（安装包优化）、启动（启动优化）、使用（渲染优化、耗电优化、内存优化………）等入手。因为我也是个菜鸟，所有东西都是现学的，所以过程中有任何问题都可以提出来，大家一起长知识。 安装包优化当今手机的内存普遍是128G或者256G，当用户长时间使用，产">
<meta property="og:type" content="article">
<meta property="og:title" content="Android性能优化">
<meta property="og:url" content="http://example.com/2022/08/11/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Android性能优化性能优化是一个app很重要的一部分，一个性能优良的app从被下载到启动到使用都能给用户到来很好的体验。自然我们做性能优化也是从被下载（安装包优化）、启动（启动优化）、使用（渲染优化、耗电优化、内存优化………）等入手。因为我也是个菜鸟，所有东西都是现学的，所以过程中有任何问题都可以提出来，大家一起长知识。 安装包优化当今手机的内存普遍是128G或者256G，当用户长时间使用，产">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220707220022.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708002040.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708125305.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708143206.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708180528.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708181942.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708184448.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708185117.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/IMG_20220708_230442.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708184448.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220709010830.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220709013129.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220709015258.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220709020245.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220709020233.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220709021347.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/IMG_20220708_233143.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/qq_pic_merged_1657355581046.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220709_163546.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220709_163630.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220712_174301.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220712180704.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708215247.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708215035.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708215416.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708220207.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/AAA.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220712233902.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220712234246.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220712234418.jpg">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220713_140120.jpg">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d23d65e12d34ad396b8826de6bf2d35~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/451499b3b9f8131b8396c7870d76670a.png">
<meta property="og:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220713002246.png">
<meta property="article:published_time" content="2022-08-11T08:37:33.000Z">
<meta property="article:modified_time" content="2022-10-20T00:57:40.673Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220707220022.png">
  
  
  
  <title>Android性能优化 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Android性能优化"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-11 16:37" pubdate>
          August 11, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          62k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          515 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android性能优化</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Android性能优化"><a href="#Android性能优化" class="headerlink" title="Android性能优化"></a>Android性能优化</h1><p>性能优化是一个app很重要的一部分，一个性能优良的app从被下载到启动到使用都能给用户到来很好的体验。自然我们做性能优化也是从被下载（安装包优化）、启动（启动优化）、使用（渲染优化、耗电优化、内存优化………）等入手。因为我也是个菜鸟，所有东西都是现学的，所以过程中有任何问题都可以提出来，大家一起长知识。</p>
<h2 id="安装包优化"><a href="#安装包优化" class="headerlink" title="安装包优化"></a>安装包优化</h2><p>当今手机的内存普遍是128G或者256G，当用户长时间使用，产生了大量数据后，留给app安装的空间可能只有几十个G，甚至更少。所以一个app的大小可能就决定了用户是否选择你。</p>
<h6 id="优化方案："><a href="#优化方案：" class="headerlink" title="优化方案："></a>优化方案：</h6><ol>
<li><p>清理无用资源</p>
<p>在app打包的时候一些废弃的代码和无用的资源可能也会被打包，这无疑会增加app的体积。好在Android Studio有这么一个检测无用资源和代码的功能。具体方法是【Refactor】-&gt;【Remove Unused Resources..】</p>
<img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220707220022.png" srcset="/img/loading.gif" lazyload style="zoom: 80%;" />

<p>再点击【Preview】可查看和选择无用的资源和代码。</p>
</li>
<li><p>使用Lint工具检查代码</p>
<p>Android-Lint是as集成的一个代码检查工具，它可以检测图片是否重复，优化xml布局等等。</p>
<p>具体使用是Android Studio -&gt; 【Code】-&gt; 【Inspect Code】</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708002040.png" srcset="/img/loading.gif" lazyload></p>
<p>Lint问题的种类：</p>
<ul>
<li>Correctness 不够完美的编码，比如硬编码、使用过时 API 等</li>
<li>Performance 对性能有影响的编码，比如：静态引用，循环引用等</li>
<li>Internationalization 国际化，直接使用汉字，没有使用资源引用等</li>
<li>Security 不安全的编码，比如在 WebView 中允许使用 JavaScriptInterface 等</li>
<li>Usability 可用的，有更好的替换的 比如排版、图标格式建议.png格式 等</li>
<li>Accessibility 辅助选项，比如ImageView的contentDescription往往建议在属性中定义 等</li>
</ul>
<p>具体的一些问题种类的细分我这里就不多说了，可以看看这篇博客:</p>
<p><a target="_blank" rel="noopener" href="https://www.freesion.com/article/250513772/">Android性能优化之 Android Lint - 灰信网（软件开发博客聚合） (freesion.com)</a></p>
</li>
<li><p>使用shrinkResources</p>
<p>我们知道缩小APK大小的方法除了开启混淆外</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">minifyEnabled <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p>还有</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">shrinkResources <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p>这里说一下，minifyEnabled 是用来删除无用的代码，shrinkResources是用来删除无用的文件（但其实不是真正的删除，只是保留文   件名但是没有内容）。还有要注意，shrinkResources需要与minifyEnabled 来配合使用，只有当minifyEnabled 为true的时候			    shrinkResources才会起作用。但是有时候我们可能添加了一张图片只是作为验证，并未引用，这时候shrinkResources可能就会误删，怎么办呢？很简单，新增一个res&#x2F;raw&#x2F;keep.xml文件，并在文件如下编码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span> <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:keep</span>=<span class="hljs-string">&quot;@drawable/xxxx,@layout/xxxxx&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>keep里面就列举需要保留误删的资源。</p>
<p>注：string.xml中没有被引用的怎么设置都不会被删除，shrinkResources删除的只是drawable和layout</p>
</li>
<li><p>资源压缩</p>
<p>在Android中，使用的图片是比较多的，这些图片是很占用资源的，对图片进行压缩和择优选择也是app瘦身的一种方案。</p>
<p>（1）使用tinypng等图片压缩工具对图片进行压缩，然后替换之前的图片</p>
<p>（2）尽量将图片都用Webp格式的，其次是JPG格式，再是PNG格式</p>
<p>（3）使用SVG，矢量图能比位图节约30%~40%的空间</p>
<p>（4）尽量不要在项目中使用帧动画，一秒就十几张图片也是很耗内存的，使用Lottie等方案</p>
<p>（5）重用Bitmap，不使用了记得回收</p>
<p>（6）可以使用微信开源资源文件混淆工具——AndResGuard。一般可以压缩apk的1M左右大。</p>
</li>
<li><p>其他方法</p>
<ul>
<li><p>动态加载so库文件，插件化开发；</p>
</li>
<li><p>统一第三方库，在满足需求的前提下选择体积更小的库，仅引入需要的代码。比如图片加载库，按缓存的需要来我们可以对图片加载库做个排序：Picasso &lt; Android-Universal-Image-Loader &lt; Glide &lt; Fresco，Fresco体积比较大，一般用于图片缓存量比较大的app，比如壁纸app，一般Glide可满足日常需求，Picasso体积最小，它与和Square的网络库一起能发挥最大作用，因为Picasso可以选择将网络请求的缓存部分交给了okhttp实现；</p>
</li>
<li><p>避免使用枚举，可能几十个枚举才相当于一张图片，但是积少成多嘛；</p>
</li>
<li><p>在多国语言需求不大的情况下可以删除其他国家的语言，只保留中文和英文。</p>
</li>
<li><p>再深入一点的还有字节码优化等等等</p>
</li>
</ul>
</li>
</ol>
<h2 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h2><p>启动优化可以说是性能优化里很重要很重要的一个部分了，用户拿到你的app，第一印象自然是app启动的界面，app启动的流畅度和时间长短，可以说启动性能就是一个app的门面。（最讨厌app启动时候的广告了）</p>
<p>大家可能都听说过2-5-8原则：</p>
<ul>
<li>当用户在0-2秒之间得到响应时，会觉得系统响应得很快</li>
<li>当用户在2-5秒之间得到响应时，会感觉系统的响应速度还可以</li>
<li>当用户在5-8秒之间得到响应时，会感觉系统响应得速度很慢，但是还能接受</li>
<li>当用户在超过8秒还无法得到响应时，会感觉系统很垃圾，认为系统已经挂了</li>
</ul>
<p>所以不管你的app做的再怎么牛逼，用户点进你的app，反应速度让他很失望，用户也无继续使用的欲望。那么我们应该如何去规划整体的启动优化呢？具体方案如下：</p>
<h5 id="冷启动、热启动和温启动"><a href="#冷启动、热启动和温启动" class="headerlink" title="冷启动、热启动和温启动"></a>冷启动、热启动和温启动</h5><p>什么是冷启动、热启动、温启动？</p>
<ul>
<li>冷启动：系统不存在App进程（如APP首次启动或APP被完全杀死）时启动App称为冷启动。</li>
<li>热启动：按了Home键或其它情况app被切换到后台，再次启动App的过程。</li>
<li>温启动：温启动包含了冷启动的一些操作，不过App进程依然存在，这代表着它比热启动有更多的开销。</li>
</ul>
<p>由此可见启动最慢的是冷启动，最快的是热启动。着重优化的地方也是冷启动。</p>
<p>在冷启动下会进行如下的相关流程</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708125305.png" srcset="/img/loading.gif" lazyload></p>
<p>与我们代码相关的只有创建Application之后到首帧绘制之前。</p>
<ol>
<li><h3 id="Application创建"><a href="#Application创建" class="headerlink" title="Application创建"></a>Application创建</h3><p>当Application启动时，空白的启动窗口将保留在屏幕上，直到系统首次完成绘制应用程序。此时，系统进程会交换应用程序的启动窗口，允许用户开始与应用程序进行交互。这就是为什么我们的程序启动时会先出现一段时间的黑屏(白屏)，但其实市面上很多app启动都是有一个logo的，再是页面。</p>
<p>如何解决？</p>
<p>在themes.xml定义一个主题</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;WelcomeTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.NoActionBar&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--设置背景颜色或者图片--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/xxxx<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--设置没有ActionBar--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:windowNoTitle&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--设置顶部状态栏颜色--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:statusBarColor&quot;</span> &gt;</span>@color/xxxx<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ图片20220708143206.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;" />



<p>但是这样也改变了activity启动后的theme，所以还得在onCreate方法中将主题还原，即</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    	setTheme(R.style.Theme_Universe); <span class="hljs-comment">//恢复原有的样式</span><br>        setContentView(R.layout.activity_main)<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>当然也可另外用一个activity来用作启动的activity，在里面也可以做一些延时的操作或者加入开屏广告什么的一些操作。</p>
<p>我们很多时候并不是用系统默认的Application，更多的时候是自定义一个MyApplication，然后在里面做一些初始化的操作。但是如果需要初始化的东西太多了，比如友盟，Bugly，网络请求库，图片加载库，ARouter等，势必会拖慢app的启动速度。那怎么办呢？这些又都是必须要的。只能异步加载了，或者等应用内启动之后再初始化。这里给出一些比价简单的优化操作：</p>
<ol>
<li>可以在Application中封装两个方法一个onSyncLoad，一个onAsyncLoad。比如像友盟，Bugly这样的业务非必要的可以的异步加载。可以放在onAsyncLoad中初始化；对于图片，网络请求框架就放在onSyncLoad中初始化。可能有人会觉得onAsyncLoad中异步会额外开销一个Thread，但其实当一个app体量变大后，开销一个Thread带来的收益是远远大于原来同步初始化的</li>
<li>我们知道ContentProvider作为Android四大组件之一，它的onCreate方法是在Application.attachBaseContext() 和 Application.onCreate()之间执行的（原理后面说），所以我们也可以间接使用它来初始化操作以减轻Application的负担，这也是很多第三方库的做法，比如LeakCanary、Picasso。但是这样也有弊端，要知道ContentProvider属于四大组件之一也是比较重量级的，据测试，一个空ContentProvider启动就耗时2ms，如果数量再增加，那么可能性能优化就得不偿失了。所以JetPack新成员App Startup就诞生了。具体App Startup的使用非常简单，这里就不多说了，给出郭霖的文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/rverE0OGRnncB5-K-_Wesg">https://mp.weixin.qq.com/s/rverE0OGRnncB5-K-_Wesg</a></li>
<li>再比如地图，推送等，非第一时间需要的可以在主线程做延时启动。当程序已经启动起来之后，在进行初始化。</li>
</ol>
</li>
<li><h6 id="Activity创建"><a href="#Activity创建" class="headerlink" title="Activity创建"></a>Activity创建</h6></li>
</ol>
<p>Activity里面的优化和Application差不多，但是Activity.onCreate方法的开销是最大的，对整个app启动的影响也最大，所以绝对不能再里面执行太耗时的操作。其次是对布局优化也可以缩短onCreate的时间，具体见渲染优化。</p>
<p>这里再介绍几个用于检测app启动性能的工具：</p>
<ul>
<li><p>最简单的就是as自己的日志工具</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708180528.jpg" srcset="/img/loading.gif" lazyload alt="D"></p>
<p>搜索词是Displayed，右边选No Files，然后就能看到各个Activity的启动时间了。</p>
</li>
<li><p>在Terminal中输入adb shell am start  -W 包名&#x2F;包名.首屏Activity  这一行命令就能看到页面的启动时间</p>
<img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ图片20220708181942.png" srcset="/img/loading.gif" lazyload alt="T" style="zoom:200%;" />

<p>控制台输出了以下信息</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Starting: Intent &#123; act=android<span class="hljs-selector-class">.intent</span><span class="hljs-selector-class">.action</span><span class="hljs-selector-class">.MAIN</span> cat=<span class="hljs-selector-attr">[android.intent.category.LAUNCHER]</span> cmp=com<span class="hljs-selector-class">.example</span>.universe/<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.MainActivity</span> &#125;<br>Status: ok<br>LaunchState: COLD<br>Activity: com<span class="hljs-selector-class">.example</span>.universe/<span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.MainActivity</span><br>TotalTime: <span class="hljs-number">3447</span><br>WaitTime: <span class="hljs-number">3450</span><br>Complete<br></code></pre></td></tr></table></figure>

<p>简单说一下</p>
<ul>
<li><p>LaunchState：代表启动方式</p>
</li>
<li><p>TotalTime：代表启动时间，包含创建进程+Application 初始化+Activity 初始化到界面显示。</p>
</li>
<li><p>WaitTime： 一般比TotalTime 大点，包含系统影响的耗时</p>
</li>
</ul>
</li>
<li><p>借助优化检测工具</p>
<p><strong>TraceView</strong></p>
<p>TraceView是以图形的形式展示执行时间、调用栈等信息，信息比较全面，包含所有线程。<br>使用TraceView检测生成生成的结果会放在Andrid&#x2F;data&#x2F;packagename&#x2F;files路径下。因为Traceview收集的信息比较全面，所以会导致运行开销严重，整体APP的运行会变慢，因此我们无法区分是不是Traceview影响了我们的启动时间。AS已经为我们内置了TraceVeiw，直接用</p>
<p>具体使用是AS - &gt; 【ProFiler】-&gt; 右侧SESSIONS 旁边的+号 -&gt; 选择你的手机，在选择一个进程  就会出现这样的画面</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708184448.png" srcset="/img/loading.gif" lazyload alt="F"></p>
<p>图中A是一些事件的响应，比如点击，屏幕翻转等等</p>
<p>B是CPU的一些使用情况，这里会说</p>
<p>C是内存的一些使用情况，等会讲内存优化的时候会说</p>
<p>D是电量的一些情况，讲耗电优化会说</p>
<p>E是时间轴</p>
<p>这里我们点击B区，就会出现下列界面</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708185117.png" srcset="/img/loading.gif" lazyload alt="G"></p>
<p>同样，A是一些事件的响应，B是CPU的执行情况，C是线程列表和线程占用CPU的情况，D是时间轴，E是记录这些情况成文件进行更加细致的分析，这里就不说明了，可以百度其用法。</p>
<p>以此我们可以更加直观的看出CPU的使用情况，从而找出问题解决问题。</p>
<p><strong>SysTrace</strong></p>
<p>Systrace是结合Android内核数据，生成HTML报告，从报告中我们可以看到各个线程的执行时间以及方法耗时和CPU执行时间等。它比TraceView更轻量，但用法差不多，具体用法可参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f83d84dcd0b8">Android Systrace使用介绍 - 简书 (jianshu.com)</a></p>
</li>
</ul>
<h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>在Android的虚拟机中，每fork一个进程，它的内存是给定的，因为移动设备的内存相对PC比较小，资源紧张，因此一个app在运行过程中一定要管理好自己的那部分内存，以提高稳定性。在内存使用中经常出现的问题也是内存抖动和内存泄漏了。</p>
<h3 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h3><p>内存抖动是由于短时间内有大量对象进出JVM的新生区导致的，内存忽高忽低，有短时间内上升和下落的趋势，分析图成锯齿状。</p>
<p>它伴随着频繁的GC（Garbage Collection垃圾回收），频繁GC会大量占用UI线程和CPU资源，会导致APP整体卡顿，甚至OOM。</p>
<h5 id="先说为什么频繁GC会导致APP整体卡顿？"><a href="#先说为什么频繁GC会导致APP整体卡顿？" class="headerlink" title="先说为什么频繁GC会导致APP整体卡顿？"></a>先说为什么频繁GC会导致APP整体卡顿？</h5><p>在JVM的GC机制中，垃圾回收有单线程收集和多线程收集，但不管是哪种回收方式，在回收的时候所有用户线程都会被暂停（STW），具体原理涉及JVM的知识了，就不再深入了。所以频繁地GC，用户线程就会被频繁地暂停，自然app就会卡顿。</p>
<h5 id="为什么频繁GC也有可能会OOM？"><a href="#为什么频繁GC也有可能会OOM？" class="headerlink" title="为什么频繁GC也有可能会OOM？"></a>为什么频繁GC也有可能会OOM？</h5><p>先看一张图</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/IMG_20220708_230442.jpg" srcset="/img/loading.gif" lazyload alt="A"></p>
<p>这里简单说一下JVM的空间担保机制，简单理解就是Java堆划分为新生代 （Young Generation）和老年代（Old Generation）两个区域，新生代空间比较少，只有1&#x2F;3，而老年代有2&#x2F;3，新生代中不断有对象被创建然后回收，只有少部分仍然存在的对象会进入老年代。而当频繁GC时，会导致新生代中有大量对象被创建，然后新生代空间就会不够用，这时候老年代就会划分一部分空间用来给新生代创建大量的对象。这就是JVM的空间担保机制。但是当老年代被划出一部分空间后，假如这时候有一个比较大的对象，比如一张图片，从新生区转移到了老年区，但是这时候老年区被缩小了，剩下的空间不够了，这时候就触发了OOM。</p>
<h5 id="怎么监测内存抖动？"><a href="#怎么监测内存抖动？" class="headerlink" title="怎么监测内存抖动？"></a>怎么监测内存抖动？</h5><p>AS有自带的检测内存抖动的工具—–Memory Monitor</p>
<p>其实这个在启动优化工具里面也提到过。</p>
<p>打开方式：Profiler -&gt;SESSIONS右边的加号选择你的手机在选择你的app   就会出现这样的界面</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708184448.png" srcset="/img/loading.gif" lazyload alt="F"></p>
<p>这次我们不点B，选择C区Memory，这时候就会出现如下界面</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220709010830.jpg" srcset="/img/loading.gif" lazyload alt="B"></p>
<p>A依然是一些事件的反应，B是内存使用的图形化显示，C是鼠标放在图形上就会有各个语言占用内存情况，D是时间轴，但这是内存使用正常的情况，当出现频繁GC的情况时</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220709013129.png" srcset="/img/loading.gif" lazyload></p>
<p>是这样滴，底部还会有一排垃圾桶表示频繁回收。那么如何定位呢？我们看到左侧有三个选项：</p>
<ul>
<li>Capture heap dump：捕获堆转储，什么是堆转储？就是java的内存快照，简单来说就是把这些内存记录写入一个文件，文件类型是hprof，然后进行更细致的分析。更多的时候是结合MAT（Memory Analyzer tool）来分析内存泄漏，这也是比较老的方法，大家可查阅了解一下，但是这种方法比较低效（搞不好as会卡死），现在检测内存泄漏有更方便的工具—LeakCanary</li>
<li>Record native allocations：记录native相关对象的内存分配</li>
<li>Record java&#x2F;kotlin allocations：记录java&#x2F;kotlin相关对象的内存分配</li>
</ul>
<p>这里一般发生内存抖动都是由于频繁创建java&#x2F;kotlin对象引起的，所以我们选择第三个并点击Record，等待一会就会出现这样的界面</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220709015258.png" srcset="/img/loading.gif" lazyload alt="A"></p>
<p>上面一排排的垃圾桶就表示在频繁GC，下面的表格显示了各个对象内存分配情况，我们点击最多的char数组</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220709020245.jpg" srcset="/img/loading.gif" lazyload alt="A"></p>
<p>跟踪可以发现是stringPlus相关操作引起的GC频繁，再看String</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220709020233.jpg" srcset="/img/loading.gif" lazyload alt="A"></p>
<p>这里就追踪到了，原来是MainActivity里面的manyGCTest方法的问题。再看源码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        findViewById&lt;Button&gt;(R.id.button).setOnClickListener &#123;<br>            Thread&#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) manyGCTest()<br>            &#125;.start()<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manyGCTest</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;&quot;</span><br>        repeat(<span class="hljs-number">10000</span>)&#123;<br>            str += it<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">100</span>)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>给一个按钮设置监听，按下开启线程，在一个死循环里面进行10000次字符串拼接操作，实际上每次str+&#x3D;it都会创建一个对象然后进行字符串拼接，但如果我们换成这样，情况会有所好转</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        findViewById&lt;Button&gt;(R.id.button).setOnClickListener &#123;<br>            Thread&#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) manyGCTest()<br>            &#125;.start()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manyGCTest</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">/*var str = &quot;&quot;</span><br><span class="hljs-comment">        repeat(10000)&#123;</span><br><span class="hljs-comment">            str += it</span><br><span class="hljs-comment">        &#125;*/</span><br>        <span class="hljs-keyword">val</span> sb = StringBuilder()<br>        repeat(<span class="hljs-number">10000</span>)&#123;<br>            sb.append(it)<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">100</span>)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>内存抖动减轻</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220709021347.png" srcset="/img/loading.gif" lazyload></p>
<p>这是因为StringBuilder做字符串拼接只会创建一次对象，所以我们在大量字符串拼接中能使用StringBuilder尽量使用StringBuilder。其实这样的情况也是比较常见的，比如在onDraw里面涉及了很多用Color.parseColor()来解析颜色，但是parseColor里面也涉及了很多字符串的操作，如果一个自定义View比较复杂这种操作很多的话这也会影响app的性能，再或者存储Cookie等等。具体的一些字符串拼接方式的区别这里也不多说了，给出一篇博客：[七种java字符串拼接详解 - &#96;&#96;&#96;…简单点 - 博客园 (cnblogs.com)](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yysbolg/p/13532971.html">https://www.cnblogs.com/yysbolg/p/13532971.html</a>)</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>内存泄漏可以说是面试必问的，也是我们开发者所必须熟知的。那么什么是内存泄漏呢？就是程序中已经动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费。简单来说就是一个对象该被回收却没有被回收，造成了内存浪费。那我们怎么知道一个对象怎么才能被GC回收呢？看一张图</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/IMG_20220708_233143.jpg" srcset="/img/loading.gif" lazyload alt="A"></p>
<p>在JVM中判断一个对象是否应该被回收一般根据可达性分析，如果一个对象的根可达，那它就不应该被回收，反之应该被回收。那么什么是根呢？就是GC roots，GC roots 一般有静态变量，线程栈变量，常量池，JNI（指针）等。举个例子，在我们还没学架构之前一直用的MVC，即所有的网络相关的操作都在Activity中进行，然后用Handler进行线程切换。但是在Handler作为非静态内部类的时候是有可能发生内存泄漏的，因为非静态内部类Handler会持有外部Activity的引用，而message会持有Handler的引用（具体见Handler源码），message会被messageQueue引用，messageQueue又被Looper引用，Looper又被Threadlocal引用，而Threadlocal属于Thread的变量即线程栈变量（GC roots即变量的根）。如果此时message是个延迟消息，而恰好在这延迟的时间段里面Activity被销毁了但是因为它还在被message引用造成它有根，不能被及时回收而一直占用内存。比教好的方案是把Handle写成静态内部类，因为静态内部类是不会持有外部的引用的，或者在onDestroy里面移除所有message。</p>
<p>这里说个题外话，java的内存泄漏和C&#x2F;C++有什么区别呢？</p>
<p>在java中，一个进程其实就是一个JVM的实例，进程中的操作都是靠JVM托管的。假如我开启了两个java进程A和B，A用来打游戏，B用来学高数。假如这时候我不想学习了，就是B发生了内存泄漏，B进程就挂掉了，但这并不影响A进程的进行，你挂你的，我运行我的。但在C&#x2F;C++中就不一样了，C&#x2F;C++中没有JVM，发生内存泄漏了影响的是整个操作系统，这个时候只有重启操作系统才会使被浪费的空间得到重用。这也就是为什么电脑用久了不重启一次就会变卡，而手机不会。</p>
<h5 id="怎么检测内存泄漏呢？"><a href="#怎么检测内存泄漏呢？" class="headerlink" title="怎么检测内存泄漏呢？"></a>怎么检测内存泄漏呢？</h5><p>上面提及了一种方案，就是使用AS自带的Android Profiler工具再结合MAT分析，但这个做法比较低效，难度也比较大，而且如果app比较庞大容易卡死AS，现今比较常用的工具是LeakCanary，它的使用比较高效，方法也比较简单。其实LeakCanary也是基于MAT进行检测Android应用程序的开源工具。</p>
<p>具体使用：在你的App中加入如下依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">debugImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-android:x.x.x&#x27;</span><br></code></pre></td></tr></table></figure>

<p>然后在启动App的时候就额外出现一个金丝雀的图标</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/qq_pic_merged_1657355581046.jpg" srcset="/img/loading.gif" lazyload></p>
<p>这是时候内存泄漏检测就开始了，在你操作App的时候，如果这时候发生了内存泄漏状态栏就会有通知，比如我的手机</p>
<img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220709_163546.jpg" srcset="/img/loading.gif" lazyload style="zoom:25%;" />

<p>点击通知它就会开始下载文件然后开始分析，分析完之后又会给你一个通知，此时再点进去就能看到LeakCanary为我们生成的发生内存泄漏对象的引用树</p>
<img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220709_163630.jpg" srcset="/img/loading.gif" lazyload alt="A" style="zoom:25%;" />

<p>可以很明显看到是SecondActivity被MyThread引用而发生内存泄漏，此时再看源码的确如此</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_second)<br>        MyThread().start()<br>    &#125;<br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>:<span class="hljs-type">Thread</span>()&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>            sleep(<span class="hljs-number">6</span>*<span class="hljs-number">6</span>*<span class="hljs-number">1000</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我在进入SecondActivity的时候开启了一个线程并让这个线程睡眠36秒，这时候我再推出当前Activity它不内存泄漏才怪呢。</p>
<h3 id="LeakCanary源码分析"><a href="#LeakCanary源码分析" class="headerlink" title="LeakCanary源码分析"></a>LeakCanary源码分析</h3><p>上面简单介绍了一下使用LeakCanary排查内存泄漏的使用，那么它为什么这么”智能”呢？为啥我们就加了一行代码它就可以监测内存泄漏了捏？这里就涉及LeakCanary的源码了。</p>
<p>在理解LeakCanary源码之前我们先来了解一下java虚拟机里的强引用，软引用，弱引用和虚引用。</p>
<ul>
<li>强引用（Strong Reference）：强引用在代码中普遍的存在，类似于“Object obj &#x3D; new Object()”，只要某个对象有强引用与之关联，JVM则无法回收该对象，即使在内存不足的情况下，JVM宁愿抛出OOM错误，也不会回收这种对象。</li>
<li>软引用（Soft Reference）：软引用常常用来描述一些有用但是非必需的对象。对于软引用关联的对象，会在JVM内存不足时既OOM之前将这些对象列入回收范围，进行二次回收。如果这时回收还是没有足够的内存才会造成内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。软引用一般用于网页的缓存图片的缓存等等比较耗时的操作，但是这些操作目前一般使用LruChche来实现，因此目前代码中很少见到SoftReference。</li>
<li>弱引用（Weak Reference）：被弱引用关联的对象只能生产到下一次垃圾收集发生之前。当垃圾收集器工作室，无论内存是否足够，都会回收弱引用关联的对象。可以使用WeakReference类来实现弱引用。</li>
<li>虚引用（Phantom Reference）：虚引用也称之为幽灵引用，或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。也无法通过虚引用来取得一个对象的实例，为一个对象设置为虚引用的唯一目的是希望这个对象被回收器回收时能收到一个系统通知，在JDK1.2之后，提供了Phantom Reference类来实现虚引用。</li>
</ul>
<p>而LeakCanary核心原理就是利用弱引用和引用队列ReferenceQueue来检测Activity&#x2F;Fragment被销毁后是否被回收。如果弱引用的引用对象被垃圾回收器回收，虚拟机就会把这个弱引用加入到与之关联的引用队列中，我们就可以此特性来检查一个对象是否被垃圾回收器回收成功。我们将上述用代码简单实现就是下面这样</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> obj: Any? = Object()<br>    <span class="hljs-keyword">val</span> referenceQueue = ReferenceQueue&lt;Any?&gt;()<br>    <span class="hljs-keyword">val</span> weakReference = WeakReference&lt;Any?&gt;(obj, referenceQueue)<span class="hljs-comment">//将对象obj与软引用关联，再将软引用与引用队列关联</span><br>    <br>    <span class="hljs-keyword">var</span> ref = referenceQueue.poll()<span class="hljs-comment">//从引用队列取出软引用，此时obj未被回收，取出的是null</span><br>    println(<span class="hljs-string">&quot;gcBefore:<span class="hljs-subst">$&#123;ref&#125;</span>&quot;</span>)<br>    <br>    obj = <span class="hljs-literal">null</span><span class="hljs-comment">//将obj与Object()的引用断开，此时obj将被GC回收</span><br>    <br>    System.gc()<br>    Thread.sleep(<span class="hljs-number">2000</span>)<br>    <br>    ref = referenceQueue.poll()<span class="hljs-comment">//obj被回收，软引用入列，取出不为null</span><br>    println(<span class="hljs-string">&quot;gcAfter:<span class="hljs-subst">$&#123;ref&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcBefore:null<br>gcAfter:java.lang.ref.WeakReference@<span class="hljs-number">60</span>f82f98<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>恰好印证。那么我们知道了核心原理，是否可以实现一个简单版的LeakCanary捏？说干就干！</p>
<p>首先，我们需要封装一下我们的弱引用，因为往往我们观测的是多个对象，那么就有多个弱引用，所以我们需要给每个弱引用设置一个Key方便查找。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyWeakCanary</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">WeakReference</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> key: String<br><br>    <span class="hljs-keyword">constructor</span>(referent: T, key: String) : <span class="hljs-keyword">super</span>(referent) &#123;<br>        <span class="hljs-keyword">this</span>.key = key<br>    &#125;<br><br>    <span class="hljs-keyword">constructor</span>(referent: T, queue: ReferenceQueue&lt;<span class="hljs-keyword">in</span> T?&gt;, key: String) : <span class="hljs-keyword">super</span>(referent, queue) &#123;<br>        <span class="hljs-keyword">this</span>.key = key<br>    &#125;<br><br>	<span class="hljs-comment">//重写toString，方便观察值</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;KeyWeakReference(key=<span class="hljs-variable">$key</span>)&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>弱引用简单封装了一下，那么还差个观察者，你要监测肯定需要一个观察者嘛。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br><br>    <span class="hljs-comment">//监测列表</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> watchedReferences = mutableMapOf&lt;String, KeyWeakReference&lt;Any?&gt;&gt;()<br><br>    <span class="hljs-comment">//保留列表</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> retainedReferences = mutableMapOf&lt;String, KeyWeakReference&lt;Any?&gt;&gt;()<br><br>    <span class="hljs-comment">//引用队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> queue = ReferenceQueue&lt;Any?&gt;()<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">watch</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>?)</span></span> &#123;<br>        <span class="hljs-comment">//生成UUID Key，便于从列表取出相应的引用</span><br>        <span class="hljs-keyword">val</span> key = UUID.randomUUID().toString()<br><br>        <span class="hljs-keyword">val</span> reference = KeyWeakReference(obj, queue, key)<span class="hljs-comment">//弱引用引用对象，引用对象与弱引用关联</span><br><br>        <span class="hljs-comment">//登记</span><br>        watchedReferences[key] = reference<br><br>        <span class="hljs-comment">//开启子线程监测对象是否泄漏</span><br>        <span class="hljs-keyword">val</span> executor = Executors.newSingleThreadExecutor()<br>        executor.execute &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>)<br>            moveToRetain(key)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//将符合泄漏的对象转移到留存区</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveToRetain</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> &#123;<br><br>        <span class="hljs-keyword">var</span> ref: KeyWeakReference&lt;Any?&gt;? = <span class="hljs-literal">null</span><br><br>        <span class="hljs-keyword">do</span> &#123;<br>            queue.poll()?.also &#123; ref = it <span class="hljs-keyword">as</span> KeyWeakReference&lt;Any?&gt; &#125;<br>            <span class="hljs-comment">//回收成功，没有发生内存泄漏的情况</span><br>            ref?.key.let &#123;<br>                watchedReferences.remove(it)<br>                retainedReferences.remove(it)<br>            &#125;<br>            ref = <span class="hljs-literal">null</span><br>        &#125; <span class="hljs-keyword">while</span> (ref != <span class="hljs-literal">null</span>)<br>        <br>        <span class="hljs-comment">//如果没有回收成功，那这个对象那这个对象肯定还在观察区，将其转移到留存区</span><br>        watchedReferences.remove(key)?.also &#123;<br>            retainedReferences[key] = it<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//供外部取出内存泄漏对象的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getReferences</span><span class="hljs-params">()</span></span>:MutableMap&lt;String,KeyWeakReference&lt;Any?&gt;&gt;&#123;<br>        <span class="hljs-keyword">return</span> retainedReferences<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，我们创建了观察列表和留存列表，这就好比现在的疫情，从外省回来会被隔离（观察列表），如果观察你有新冠就将你运往隔离医院治疗（留存列表）。然后就是观察方法，传入观察对象，之后用java自带的UUID工具生成唯一的UUID给弱引用方便根据key查询弱引用，之后是弱引用引用对象，引用队列与弱引用关联，再把该弱引用记录进观察区，之后用线程池开启子线程进行内存监测。在内存检测方法里先从引用队列拿出一个引用对象，若为空，则表明它没有被回收，观察区也就不会将它移除，之后下面remove它的时候就不为null，它就会被转移进留存区。之后外界通过这个留存区取出内存泄漏的对象进行分析通知一系列操作。</p>
<p>然后在主线程测试一下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> obj:Any? = Object()<br>    <span class="hljs-keyword">val</span> watcher = Watcher()<br>    watcher.watch(obj)<br><br>    obj = <span class="hljs-literal">null</span><span class="hljs-comment">//改变obj为null的状态来模拟内存泄漏与否</span><br>    System.gc()<br><br>    Thread.sleep(<span class="hljs-number">2000</span>)<br><br>    watcher.getReferences().forEach &#123; (key, reference) -&gt;<br>        println(<span class="hljs-string">&quot;key:<span class="hljs-variable">$key</span>,<span class="hljs-variable">$reference</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将obj置为null此时调用GC obj将被回收，无输出。再将这行注释，模拟obj被引用的情况，此时GC无法将其回收，留存区有值，打印：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">key:ca1485f4-<span class="hljs-number">929</span>a-<span class="hljs-number">45</span>f2-<span class="hljs-number">8977</span>-<span class="hljs-number">483</span>f05245f0d,KeyWeakReference(key=ca1485f4-<span class="hljs-number">929</span>a-<span class="hljs-number">45</span>f2-<span class="hljs-number">8977</span>-<span class="hljs-number">483</span>f05245f0d)<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>证明我们这个简易版的（可以说很丑陋）内存泄漏检测工具是成功的。但实际上，LeakCanary的做法比我们这个更加细节，我们这个只能检测单个对象，而LeakCanary对Activity、Fragment、Service、RootView、Viewmodel都进行了生命周期监听，并且对泄漏对象的通报和分析都是在内部进行的。</p>
<p>我们现在来看看它的源码，在看他的源码之前我们先问几个问题</p>
<ol>
<li>在LeakCanary1.0版本之前是需要在Application里面初始化的，2.0版本之后直接添加依赖就可以用了，那之后的版本它在哪初始化的捏？</li>
<li>LeakCanary是怎么对Activity、fragment（view和fragment本身）、Service、RootView、Viewmodel进行生命周期的监听的捏？</li>
<li>检测到泄漏之后是怎么处理的呢？</li>
</ol>
<p>相信带着这几个问题去看他的源码会更好理解。</p>
<p>首先看LeakCanary是在哪里初始化的？其实，在1.0版本之前，LeakCanary都是在自定义的Application里面初始化的，在2.0之后只需添加一行依赖即可。之前也提到过ContentProvider得onCreate()是在Application.onCreate前面执行的，不难想到LeakCanary就是这么许哦的。</p>
<h5 id="为什么ContentProvider的onCreate方法是在Application前面执行的呢？"><a href="#为什么ContentProvider的onCreate方法是在Application前面执行的呢？" class="headerlink" title="为什么ContentProvider的onCreate方法是在Application前面执行的呢？"></a>为什么ContentProvider的onCreate方法是在Application前面执行的呢？</h5><p>这就要看看ActivityThread的源码了，要知道他们两个的onCreate先后顺序肯定要先理清Application的创建流程，因为Application是伴随整个app的生命周期的。看到ActivityThread的main函数，我们看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    	...<br>        Looper.prepareMainLooper();<br>		...<br>        <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>        thread.attach(<span class="hljs-literal">false</span>, startSeq);<br>    	...<br>        Looper.loop();<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>Application和整个app的生命周期那肯定也伴随着主线程的启动与消亡，那肯定跟thread.attach有关，跟进看一看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(<span class="hljs-type">boolean</span> system, <span class="hljs-type">long</span> startSeq)</span> &#123;<br>	sCurrentActivityThread = <span class="hljs-built_in">this</span>;<br>	mSystemThread = system;<br>	<span class="hljs-keyword">if</span> (!system) &#123;<br>	    android.ddm.DdmHandleAppName.setAppName(<span class="hljs-string">&quot;&lt;pre-initialized&gt;&quot;</span>,<br>	                                            UserHandle.myUserId());<br>	    RuntimeInit.setApplicationObject(mAppThread.asBinder());<br>	    <span class="hljs-comment">// mgr为ActivityManagerService实例</span><br>	    <span class="hljs-keyword">final</span> <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">mgr</span> <span class="hljs-operator">=</span> ActivityManager.getService();<br>	    <span class="hljs-keyword">try</span> &#123;<br>	    	<span class="hljs-comment">// mAppThread为ApplicationThread实例,ApplicationThread是ActivityThread与AMS交互的桥梁</span><br>	        mgr.attachApplication(mAppThread, startSeq);<br>	    &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>	        <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();<br>	    &#125;<br>	    ...<br>	&#125;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里获取AMS之后调用了attachApplication(mAppThread, startSeq)，跟进看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachApplication</span><span class="hljs-params">(IApplicationThread thread, <span class="hljs-type">long</span> startSeq)</span> &#123;<br>    <span class="hljs-keyword">if</span> (thread == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(<span class="hljs-string">&quot;Invalid application interface&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">callingPid</span> <span class="hljs-operator">=</span> Binder.getCallingPid();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">callingUid</span> <span class="hljs-operator">=</span> Binder.getCallingUid();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">origId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>        attachApplicationLocked(thread, callingPid, callingUid, startSeq);<span class="hljs-comment">//这里又调用了AMS的内部方法，跟踪下去</span><br>        Binder.restoreCallingIdentity(origId);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">attachApplicationLocked</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IApplicationThread thread, <span class="hljs-type">int</span> pid, <span class="hljs-type">int</span> callingUid, <span class="hljs-type">long</span> startSeq)</span> &#123;<br>	...<br>	<span class="hljs-keyword">if</span> (app.isolatedEntryPoint != <span class="hljs-literal">null</span>) &#123;<br>	   	<span class="hljs-comment">//判断是否是isolato进程，这个可通过设置service的android:isolatedProcess开启，设置该服务是否</span><br>       	<span class="hljs-comment">//作为一个单独的进程运行，如果设置为true，此服务将在与系统其余部分隔离的特殊进程下运行，并且没有自己的权限，与它唯一		//的通信是通过服务API（绑定和启动),这个我们一般不会去这么做，直接略过</span><br>	   thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs);<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr2 != <span class="hljs-literal">null</span>) &#123;<br>	   thread.bindApplication(processName, appInfo, providerList,<span class="hljs-comment">//跟踪到者发现调用了bindApplication</span><br>	           instr2.mClass,<br>	           profilerInfo, instr2.mArguments,<br>	           instr2.mWatcher,<br>	           instr2.mUiAutomationConnection, testMode,<br>	           mBinderTransactionTrackingEnabled, enableTrackAllocation,<br>	           isRestrictedBackupMode || !normalMode, app.isPersistent(),<br>	           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),<br>	           app.compat, getCommonServicesLocked(app.isolated),<br>	           mCoreSettingsObserver.getCoreSettingsLocked(),<br>	           buildSerial, autofillOptions, contentCaptureOptions,<br>	           app.mDisabledCompatChanges);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>	   thread.bindApplication(processName, appInfo, providerList, <span class="hljs-literal">null</span>, profilerInfo,<span class="hljs-comment">//同样是这个方法的重载</span><br>	           <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, testMode,<br>	           mBinderTransactionTrackingEnabled, enableTrackAllocation,<br>	           isRestrictedBackupMode || !normalMode, app.isPersistent(),<br>	           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),<br>	           app.compat, getCommonServicesLocked(app.isolated),<br>	           mCoreSettingsObserver.getCoreSettingsLocked(),<br>	           buildSerial, autofillOptions, contentCaptureOptions,<br>	           app.mDisabledCompatChanges);<br>	&#125;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么我们继续点进thread.bindApplication看看它做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindApplication</span><span class="hljs-params">(String processName, ApplicationInfo appInfo,</span><br><span class="hljs-params">                ProviderInfoList providerList, ComponentName instrumentationName,</span><br><span class="hljs-params">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="hljs-params">                IInstrumentationWatcher instrumentationWatcher,</span><br><span class="hljs-params">                IUiAutomationConnection instrumentationUiConnection, <span class="hljs-type">int</span> debugMode,</span><br><span class="hljs-params">                <span class="hljs-type">boolean</span> enableBinderTracking, <span class="hljs-type">boolean</span> trackAllocation,</span><br><span class="hljs-params">                <span class="hljs-type">boolean</span> isRestrictedBackupMode, <span class="hljs-type">boolean</span> persistent, Configuration config,</span><br><span class="hljs-params">                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span><br><span class="hljs-params">                String buildSerial, AutofillOptions autofillOptions,</span><br><span class="hljs-params">                ContentCaptureOptions contentCaptureOptions, <span class="hljs-type">long</span>[] disabledCompatChanges,</span><br><span class="hljs-params">                SharedMemory serializedSystemFontMap)</span> &#123;<br>			...<br>           <br>            sendMessage(H.BIND_APPLICATION, data);<span class="hljs-comment">//看这里</span><br>        &#125;<br></code></pre></td></tr></table></figure>

<p>找来找去发现没有关于application的函数了，但是我们可以看到最后一行调用了sendMessage函数，并传了H.BIND_APPLICATION这个参数，那么我们点进去看看它是否跟bindApplication有关捏？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-type">int</span> what, Object obj)</span> &#123;<br>        sendMessage(what, obj, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>继续跟进</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-type">int</span> what, Object obj, <span class="hljs-type">int</span> arg1, <span class="hljs-type">int</span> arg2, <span class="hljs-type">boolean</span> async)</span> &#123;<br>        <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) &#123;<br>            Slog.v(TAG,<br>                    <span class="hljs-string">&quot;SCHEDULE &quot;</span> + what + <span class="hljs-string">&quot; &quot;</span> + mH.codeToString(what) + <span class="hljs-string">&quot;: &quot;</span> + arg1 + <span class="hljs-string">&quot; / &quot;</span> + obj);<br>        &#125;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain();<br>        msg.what = what;<br>        msg.obj = obj;<br>        msg.arg1 = arg1;<br>        msg.arg2 = arg2;<br>        <span class="hljs-keyword">if</span> (async) &#123;<br>            msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>        &#125;<br>        mH.sendMessage(msg);<span class="hljs-comment">//发现这里发送了一个消息，传入的message携带的信息就是上面传入的H.BIND_APPLICATION</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>我们发现这里调用了mH的sendMessage方法，mH会不会就是Handler?跟进mH看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">H</span> <span class="hljs-variable">mH</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">H</span>();<br></code></pre></td></tr></table></figure>

<p>是H的对象，那H是否继承了Handler方法呢？点进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    ...<br>     <span class="hljs-comment">//通过Handler进入</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>		<span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));<br>            <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                <span class="hljs-keyword">case</span> BIND_APPLICATION:<span class="hljs-comment">//根据我们传入的值进入这个分支</span><br>                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;bindApplication&quot;</span>);<br>                    <span class="hljs-type">AppBindData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (AppBindData)msg.obj;<br>                    handleBindApplication(data);<span class="hljs-comment">//在这里处理了Application的绑定</span><br>                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> EXIT_APPLICATION:<br>                    <span class="hljs-keyword">if</span> (mInitialApplication != <span class="hljs-literal">null</span>) &#123;<br>                        mInitialApplication.onTerminate();<br>                    &#125;<br>                    Looper.myLooper().quit();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> RECEIVER:<br>                ...<br>                &#125;<br>          ...<br>         &#125;<br>    ...<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>发现果然是这样。并且实现了handle Message方法，那上面我们sendMessage最终通过Handler肯定执行handle Message方法，并且根据我们传入的H.BIND_APPLICATION进入了第一个分支，继续跟进handleBindApplication(data);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleBindApplication</span><span class="hljs-params">(AppBindData data)</span> &#123;<br>        ...<br>          <span class="hljs-comment">//创建appContext</span><br>		<span class="hljs-keyword">final</span> <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> ContextImpl.createAppContext(<span class="hljs-built_in">this</span>, data.info);<span class="hljs-comment">//6660</span><br>	    ...<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//在这创建了application</span><br>            app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-literal">null</span>);<span class="hljs-comment">//6723</span><br><br>            ...<br>            <span class="hljs-keyword">if</span> (!data.restrictedBackupMode) &#123;<br>                <span class="hljs-keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;<span class="hljs-comment">//6747</span><br>                    installContentProviders(app, data.providers);<span class="hljs-comment">//可以看到这里应该就是启动ContentProvider的地方</span><br>                &#125;<br>            &#125;<br><br>           ...<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//看函数名不难发现这儿就是回调Applicatio.onCreate的地方  6762</span><br>                mInstrumentation.callApplicationOnCreate(app);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                      <span class="hljs-string">&quot;Unable to create application &quot;</span> + app.getClass().getName()<br>                      + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>                &#125;<br>            &#125;<br>		...<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，先创建appContext和application，具体创建过程这里就不细细分析了，这里我们只是简单看看ContentProvier和Application的onCreate执行顺序。然后是installContentProviders，那这里肯定就和ContentProvider有关了，等会再分析，先看下面的mInstrumentation.callApplicationOnCreate(app)，我们跟进发现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callApplicationOnCreate</span><span class="hljs-params">(Application app)</span> &#123;<br>        app.onCreate();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>其实就是调用了application的onCreate方法，那我们再跟进前面的installContentProviders看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installContentProviders</span><span class="hljs-params">(</span><br><span class="hljs-params">            Context context, List&lt;ProviderInfo&gt; providers)</span> &#123;<br>        <span class="hljs-keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (ProviderInfo cpi : providers) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_PROVIDER) &#123;<br>                <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">128</span>);<br>                buf.append(<span class="hljs-string">&quot;Pub &quot;</span>);<br>                buf.append(cpi.authority);<br>                buf.append(<span class="hljs-string">&quot;: &quot;</span>);<br>                buf.append(cpi.name);<br>                Log.i(TAG, buf.toString());<br>            &#125;<br>            <span class="hljs-type">ContentProviderHolder</span> <span class="hljs-variable">cph</span> <span class="hljs-operator">=</span> installProvider(context, <span class="hljs-literal">null</span>, cpi,<span class="hljs-comment">//在这里进行了ContentProvider的一些创建</span><br>                    <span class="hljs-literal">false</span> <span class="hljs-comment">/*noisy*/</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*noReleaseNeeded*/</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*stable*/</span>);<br>            <span class="hljs-keyword">if</span> (cph != <span class="hljs-literal">null</span>) &#123;<br>                cph.noReleaseNeeded = <span class="hljs-literal">true</span>;<br>                results.add(cph);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ActivityManager.getService().publishContentProviders(<br>                getApplicationThread(), results);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>            <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>继续跟进installProvider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ContentProviderHolder <span class="hljs-title function_">installProvider</span><span class="hljs-params">(Context context,</span><br><span class="hljs-params">            ContentProviderHolder holder, ProviderInfo info,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> noisy, <span class="hljs-type">boolean</span> noReleaseNeeded, <span class="hljs-type">boolean</span> stable)</span> &#123;<br>        <span class="hljs-type">ContentProvider</span> <span class="hljs-variable">localProvider</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        IContentProvider provider;<br>        <span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span> || holder.provider == <span class="hljs-literal">null</span>) &#123;<br>            ...<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">final</span> java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> c.getClassLoader();<br>                <span class="hljs-type">LoadedApk</span> <span class="hljs-variable">packageInfo</span> <span class="hljs-operator">=</span> peekPackageInfo(ai.packageName, <span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (packageInfo == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// System startup case.</span><br>                    packageInfo = getSystemContext().mPackageInfo;<br>                &#125;<br>                localProvider = packageInfo.getAppFactory()<br>                        .instantiateProvider(cl, info.name);<br>                provider = localProvider.getIContentProvider();<br>                <span class="hljs-keyword">if</span> (provider == <span class="hljs-literal">null</span>) &#123;<br>                    Slog.e(TAG, <span class="hljs-string">&quot;Failed to instantiate class &quot;</span> +<br>                          info.name + <span class="hljs-string">&quot; from sourceDir &quot;</span> +<br>                          info.applicationInfo.sourceDir);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (DEBUG_PROVIDER) Slog.v(<br>                    TAG, <span class="hljs-string">&quot;Instantiating local provider &quot;</span> + info.name);<br>                <span class="hljs-comment">// XXX Need to create the correct context for this provider.</span><br>                localProvider.attachInfo(c, info);<br>            &#125; <span class="hljs-keyword">catch</span> (java.lang.Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(<span class="hljs-literal">null</span>, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                            <span class="hljs-string">&quot;Unable to get provider &quot;</span> + info.name<br>                            + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            provider = holder.provider;<br>            <span class="hljs-keyword">if</span> (DEBUG_PROVIDER) Slog.v(TAG, <span class="hljs-string">&quot;Installing external provider &quot;</span> + info.authority + <span class="hljs-string">&quot;: &quot;</span><br>                    + info.name);<br>        &#125;<br>		...<br>        <span class="hljs-keyword">return</span> retHolder;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>看到这句英文注释Need to create the correct context for this provider.需要为此提供者创建正确的上下文，那肯定就是他了，跟进localProvider.attachInfo(c, info)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachInfo</span><span class="hljs-params">(Context context, ProviderInfo info, <span class="hljs-type">boolean</span> testing)</span> &#123;<br>        mNoPerms = testing;<br>        mCallingAttributionSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Only allow it to be set once, so after the content service gives</span><br><span class="hljs-comment">         * this to us clients can&#x27;t change it.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (mContext == <span class="hljs-literal">null</span>) &#123;<br>            mContext = context;<br>            <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span> &amp;&amp; mTransport != <span class="hljs-literal">null</span>) &#123;<br>                mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(<br>                        Context.APP_OPS_SERVICE);<br>            &#125;<br>            mMyUid = Process.myUid();<br>            <span class="hljs-keyword">if</span> (info != <span class="hljs-literal">null</span>) &#123;<br>                setReadPermission(info.readPermission);<br>                setWritePermission(info.writePermission);<br>                setPathPermissions(info.pathPermissions);<br>                mExported = info.exported;<br>                mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != <span class="hljs-number">0</span>;<br>                setAuthorities(info.authority);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (Build.IS_DEBUGGABLE) &#123;<br>                setTransportLoggingEnabled(Log.isLoggable(getClass().getSimpleName(),<br>                        Log.VERBOSE));<br>            &#125;<br>            ContentProvider.<span class="hljs-built_in">this</span>.onCreate();<span class="hljs-comment">//在这里回调了contentProvider的onCreate</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>最终我们在这发现回调了onCreate。这里我们只是根据函数名+源码注释+猜测去验证了他们两个的执行顺序，更多细枝末节就没看（其实是看不懂），如果大家想真正搞明白ContentProvider和Application完整的创建流程，大家可以去研究一下Android的源码。</p>
<p>知道了这个之后我们就能理解LeakCanary的做法了，翻其源码也确实是这样。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.squareup.leakcanary.objectwatcher&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;leakcanary.internal.MainProcessAppWatcherInstaller&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.leakcanary-installer&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;@bool/leak_canary_watcher_auto_install&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>那可能有人会疑问，为啥它那定义的清单文件我这也能用捏？其实这是Gradle的功劳，一个app是只能有一个清单文件的，在构建应用的时候，Gradle会合并所有的清单文件，所有文件优先级如下</p>
<ol>
<li>Product flavors 和构建类型所指定的清单文件。</li>
<li>应用程序的主清单文件。</li>
<li>类库的清单文件。</li>
</ol>
<p>具体的合并逻辑就涉及Gradle的东西了，这里就不说了。那好，那我们的第一个问题就解决了。</p>
<h5 id="LeakCanary是如何监听的"><a href="#LeakCanary是如何监听的" class="headerlink" title="LeakCanary是如何监听的"></a>LeakCanary是如何监听的</h5><p>现在我们看MainProcessAppWatcherInstaller</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainProcessAppWatcherInstaller</span> : <span class="hljs-type">ContentProvider</span>() &#123;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> application = context!!.applicationContext <span class="hljs-keyword">as</span> Application<br>    AppWatcher.manualInstall(application)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>初始化了AppWatcher</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@JvmOverloads</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manualInstall</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  application: <span class="hljs-type">Application</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  retainedDelayMillis: <span class="hljs-type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>)</span></span>,<span class="hljs-comment">//对检测对象延迟5秒检测</span><br>  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)<span class="hljs-comment">//默认的一些观察器</span><br>) &#123;<br>  checkMainThread()<br>  <span class="hljs-keyword">if</span> (isInstalled) &#123;<br>    <span class="hljs-keyword">throw</span> IllegalStateException(<br>      <span class="hljs-string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause<br>    )<br>  &#125;<br>  check(retainedDelayMillis &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-string">&quot;retainedDelayMillis <span class="hljs-variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span><br>  &#125;<br>  <span class="hljs-keyword">this</span>.retainedDelayMillis = retainedDelayMillis<br>  <span class="hljs-keyword">if</span> (application.isDebuggableBuild) &#123;<br>    LogcatSharkLog.install()<span class="hljs-comment">//日志的初始化</span><br>  &#125;<br>  <span class="hljs-comment">//核心组件，用于检测泄漏和对堆转储(head dump)的分析</span><br>  LeakCanaryDelegate.loadLeakCanary(application)<br><br>  <span class="hljs-comment">//对每一个检测器进行初始化</span><br>  watchersToInstall.forEach &#123;<br>    it.install()<br>  &#125;<br>  <span class="hljs-comment">// Only install after we&#x27;re fully done with init.</span><br>  installCause = RuntimeException(<span class="hljs-string">&quot;manualInstall() first called here&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们先不看核心组件，它比较复杂，我们先看看默认的检测器是如何对Activity、Fragment、Viewmodel等的监听的，先看appDefaultWatchers(application)这个生成默认检测器的方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">appDefaultWatchers</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  application: <span class="hljs-type">Application</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  reachabilityWatcher: <span class="hljs-type">ReachabilityWatcher</span> = objectWatcher</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: List&lt;InstallableWatcher&gt; &#123;<br>  <span class="hljs-keyword">return</span> listOf(<br>    ActivityWatcher(application, reachabilityWatcher),<span class="hljs-comment">//对Activity的检测器</span><br>    FragmentAndViewModelWatcher(application, reachabilityWatcher),<span class="hljs-comment">//对Fragment和Viewmodel的检测器</span><br>    RootViewWatcher(reachabilityWatcher),<span class="hljs-comment">//对RootView的检测器</span><br>    ServiceWatcher(reachabilityWatcher)<span class="hljs-comment">//对Service的检测器</span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建各个检测器，传入objectWatcher和application，这四个监听器我们一个一个来看</p>
<h6 id="ActivityWatcher"><a href="#ActivityWatcher" class="headerlink" title="ActivityWatcher"></a><strong>ActivityWatcher</strong></h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityWatcher</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> application: Application,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : InstallableWatcher &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycleCallbacks =<br>    <span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityDestroyed</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>        reachabilityWatcher.expectWeaklyReachable(<br>          activity, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span><br>        )<br>      &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span> &#123;<br>    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)<span class="hljs-comment">//注册Activity的生命周期监听</span><br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">uninstall</span><span class="hljs-params">()</span></span> &#123;<br>    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，通过Activity生命周期对的Application.ActivityLifecycleCallbacks回调来达到监听Activity的结束。其实就是在Activity快onDestroy的时候调用了Application.ActivityLifecycleCallbacks的onActivityDestroyed。然后在onActivityDestroyed里面调用了reachabilityWatcher的expectWeaklyReachable，reachabilityWatcher就是刚刚创建的时候传进来的，我们返回去看看reachabilityWatcher对expectWeaklyReachable的实现。跟踪发现，传进来的是objectWatcher，点击跟踪</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The [ObjectWatcher] used by AppWatcher to detect retained objects.</span><br><span class="hljs-comment"> * Only set when [isInstalled] is true.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">val</span> objectWatcher = ObjectWatcher(<br>  clock = &#123; SystemClock.uptimeMillis() &#125;,<br>  checkRetainedExecutor = &#123;<br>    check(isInstalled) &#123;<br>      <span class="hljs-string">&quot;AppWatcher not installed&quot;</span><br>    &#125;<br>    mainHandler.postDelayed(it, retainedDelayMillis)<br>  &#125;,<br>  isEnabled = &#123; <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure>

<p>我们这里看到传入时间、一个Executor任务执行器，该任务执行器将传入的任务交给主线程的Handler延时处理，延时retainedDelayMillis就是刚刚初始化AppWatcher默认设置的5秒，看看ObjectWatcher对expectWeaklyReachable的实现，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">expectWeaklyReachable</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  watchedObject: <span class="hljs-type">Any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  description: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (!isEnabled()) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  removeWeaklyReachableObjects()<span class="hljs-comment">//先清空观察区里已经被回收的对象</span><br>  <span class="hljs-keyword">val</span> key = UUID.randomUUID()<br>    .toString()<br>  <span class="hljs-keyword">val</span> watchUptimeMillis = clock.uptimeMillis()<br>  <span class="hljs-keyword">val</span> reference =<br>    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)<br>  SharkLog.d &#123;<br>    <span class="hljs-string">&quot;Watching &quot;</span> +<br>      (<span class="hljs-keyword">if</span> (watchedObject <span class="hljs-keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;instance of <span class="hljs-subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +<br>      (<span class="hljs-keyword">if</span> (description.isNotEmpty()) <span class="hljs-string">&quot; (<span class="hljs-variable">$description</span>)&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>) +<br>      <span class="hljs-string">&quot; with key <span class="hljs-variable">$key</span>&quot;</span><br>  &#125;<br><br>  watchedObjects[key] = reference<br>  checkRetainedExecutor.execute &#123;<br>    moveToRetained(key)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实之前仿写的LeakCanary有点故意模仿LeakCanary的意思，这不LeakCanary里面也有观察区和留存区，只不过我们为了好获取泄漏对象而用了一个列表存储，这里没有列表存储，而是直接回调出去通知。每次观测之前先清除观察区已经被回收的对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeWeaklyReachableObjects</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span><br>  <span class="hljs-comment">// reachable. This is before finalization or garbage collection has actually happened.</span><br>  <span class="hljs-keyword">var</span> ref: KeyedWeakReference?<br>  <span class="hljs-keyword">do</span> &#123;<br>    ref = queue.poll() <span class="hljs-keyword">as</span> KeyedWeakReference?<br>    <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//不为空说明已经被回收</span><br>      watchedObjects.remove(ref.key)<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (ref != <span class="hljs-literal">null</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后就和我们刚仿写的差不多，生成一个唯一的UUID，将弱引用引用对象，再登记，只不过这里它记录了时间。最后执行moveToRetained(key)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveToRetained</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> &#123;<br>  removeWeaklyReachableObjects()<br>  <span class="hljs-keyword">val</span> retainedRef = watchedObjects[key]<br>  <span class="hljs-keyword">if</span> (retainedRef != <span class="hljs-literal">null</span>) &#123;<br>    retainedRef.retainedUptimeMillis = clock.uptimeMillis()<br>      <span class="hljs-comment">//责任链模式</span><br>    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这时候如果还有对象存在观察区，说明已经是可能内存泄漏的对象，然后记录此时的时间，再回调监听，onObjectRetainedListeners在哪设置的呢，在刚刚的核心组件里面，等会分析。</p>
<p>至此我们分析完LeakCanary是如何监听Activity生命周期和检测是否泄露的。接下来看Fragment和Viewmodel</p>
<h6 id="FragmentAndViewModelWatcher"><a href="#FragmentAndViewModelWatcher" class="headerlink" title="FragmentAndViewModelWatcher"></a><strong>FragmentAndViewModelWatcher</strong></h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentAndViewModelWatcher</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> application: Application,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : InstallableWatcher &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentDestroyWatchers: List&lt;(Activity) -&gt; <span class="hljs-built_in">Unit</span>&gt; = run &#123;<br>    <span class="hljs-keyword">val</span> fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; <span class="hljs-built_in">Unit</span>&gt;()<br><br>      <span class="hljs-comment">//版本的适配</span><br>    <span class="hljs-keyword">if</span> (SDK_INT &gt;= O) &#123;<br>      fragmentDestroyWatchers.add(<br>        AndroidOFragmentDestroyWatcher(reachabilityWatcher)<br>      )<br>    &#125;<br><br>    getWatcherIfAvailable(<br>      ANDROIDX_FRAGMENT_CLASS_NAME,<br>      ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<span class="hljs-comment">//对应androidx版本</span><br>      reachabilityWatcher<br>    )?.let &#123;<br>      fragmentDestroyWatchers.add(it)<br>    &#125;<br><br>    getWatcherIfAvailable(<br>      ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,<br>      ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,<span class="hljs-comment">//对应之前的老版本</span><br>      reachabilityWatcher<br>    )?.let &#123;<br>      fragmentDestroyWatchers.add(it)<br>    &#125;<br>    fragmentDestroyWatchers<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycleCallbacks =<br>    <span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        activity: <span class="hljs-type">Activity</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        savedInstanceState: <span class="hljs-type">Bundle</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">      )</span></span> &#123;<br>          <span class="hljs-comment">//不同版本的fragmentDestroyWatcher进行监听注册</span><br>        <span class="hljs-keyword">for</span> (watcher <span class="hljs-keyword">in</span> fragmentDestroyWatchers) &#123;<br>          watcher(activity)<br>        &#125;<br>      &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span> &#123;<br>    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">uninstall</span><span class="hljs-params">()</span></span> &#123;<br>    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)<br>  &#125;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这里给activity注册一个监听，然后遍历里面的fragmentwatcher调用incoke设置fragment的监听，其他版本的fragmentDestroyWatcher就不看了和ActivityWatcher差不多，我们看看AndroidXFragmentDestroyWatcher</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidXFragmentDestroyWatcher</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : (Activity) -&gt; <span class="hljs-built_in">Unit</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentLifecycleCallbacks = <span class="hljs-keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentCreated</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      fragment: <span class="hljs-type">Fragment</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      savedInstanceState: <span class="hljs-type">Bundle</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        <span class="hljs-comment">//监听viewmodel相关</span><br>      ViewModelClearedWatcher.install(fragment, reachabilityWatcher)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentViewDestroyed</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      fragment: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      <span class="hljs-keyword">val</span> view = fragment.view<br>      <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">//对view泄漏的回调</span><br>        reachabilityWatcher.expectWeaklyReachable(<br>          view, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback &quot;</span> +<br>          <span class="hljs-string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span><br>        )<br>      &#125;<br>    &#125;<br><br>      <span class="hljs-comment">//和activitywatcher一样，不多说</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentDestroyed</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      fragment: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      reachabilityWatcher.expectWeaklyReachable(<br>        fragment, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback&quot;</span><br>      )<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">is</span> FragmentActivity) &#123;<br>      <span class="hljs-keyword">val</span> supportFragmentManager = activity.supportFragmentManager<br>        <span class="hljs-comment">//通过fragmentmanager监听fragment生命周期</span><br>      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="hljs-literal">true</span>)<br>        <span class="hljs-comment">//初始化viewmodel</span><br>      ViewModelClearedWatcher.install(activity, reachabilityWatcher)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实跟activity的差不多，不过是通过activity设置fragment的监听，这里可能有个高阶函数大家没见过，也是invoke的一种用法吧，可以了解一下。好，我们现在来看看对viewmodel的监听过程：</p>
<h6 id="ViewModelClearedWatcher"><a href="#ViewModelClearedWatcher" class="headerlink" title="ViewModelClearedWatcher"></a><strong>ViewModelClearedWatcher</strong></h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModelClearedWatcher</span>(<br>  storeOwner: ViewModelStoreOwner,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : ViewModel() &#123;<br><br>  <span class="hljs-comment">// We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,</span><br>  <span class="hljs-comment">// however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0</span><br>  <span class="hljs-comment">// does not have ViewModelStore#keys. All versions currently have the mMap field.</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModelMap: Map&lt;String, ViewModel&gt;? = <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//通过反射获取viewmodelstore</span><br>    <span class="hljs-keyword">val</span> mMapField = ViewModelStore::<span class="hljs-keyword">class</span>.java.getDeclaredField(<span class="hljs-string">&quot;mMap&quot;</span>)<br>    mMapField.isAccessible = <span class="hljs-literal">true</span><br>    <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>    mMapField[storeOwner.viewModelStore] <span class="hljs-keyword">as</span> Map&lt;String, ViewModel&gt;<br>  &#125; <span class="hljs-keyword">catch</span> (ignored: Exception) &#123;<br>    <span class="hljs-literal">null</span><br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-comment">//当此viewmodel销毁时，意味着viewmodelstore里其他的viewmodel也将被销毁</span><br>    viewModelMap?.values?.forEach &#123; viewModel -&gt;<br>      reachabilityWatcher.expectWeaklyReachable(<br>        viewModel, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;viewModel::class.java.name&#125;</span> received ViewModel#onCleared() callback&quot;</span><br>      )<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      storeOwner: <span class="hljs-type">ViewModelStoreOwner</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      reachabilityWatcher: <span class="hljs-type">ReachabilityWatcher</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        <span class="hljs-comment">//这就很巧妙，通过将自己插入viewmodelstore来监控通一宿主的viewmodel</span><br>      <span class="hljs-keyword">val</span> provider = ViewModelProvider(storeOwner, <span class="hljs-keyword">object</span> : Factory &#123;<br>        <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : ViewModel?&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(modelClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T =<br>          ViewModelClearedWatcher(storeOwner, reachabilityWatcher) <span class="hljs-keyword">as</span> T<br>      &#125;)<br>      provider.<span class="hljs-keyword">get</span>(ViewModelClearedWatcher::<span class="hljs-keyword">class</span>.java)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们发现它居然是个viewmodel，而且它还把它自己插入了宿主的viewmodelstore。把自己当作间谍插入敌军来达到监听的目的。具体viewmodestore是如何管理同一宿主的多个viewmodel的这里就不解释了，大家可以看看viewmodel的源码（其实是我不会）。</p>
<p>好，再来看看rootView</p>
<h6 id="RootViewWatcher"><a href="#RootViewWatcher" class="headerlink" title="RootViewWatcher"></a><strong>RootViewWatcher</strong></h6><p>有人可能会问rootview也会发生内存泄露吗？会的，只是不常见，比如，此时我自定义了一个Toast弹窗，弹的是xml的布局，然后Toast被我声明成了静态方法，这时候如果我一弹窗，消失，之后LeakCanary就提醒你了，内存泄漏。自定义的toast代码如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> ToastUtil &#123;<br>    <span class="hljs-keyword">var</span> mToast: Toast? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> inflater = LayoutInflater.from(App.appContext)<br>        <span class="hljs-keyword">val</span> toastView: View = inflater.inflate(R.layout.toast, <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">if</span> (mToast == <span class="hljs-literal">null</span>) &#123;<br>            mToast = Toast(App.appContext)<br>        &#125;<br>        mToast!!.setGravity(Gravity.TOP, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        mToast!!.duration = Toast.LENGTH_SHORT<br>        mToast!!.view = toastView<br>        mToast!!.show()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样的自定义Toast工具是内存泄漏的，为什么捏，因为object单例内部的变量是静态的，所以mToast是静态的，而它又引用了toastView，而toastView是rootView绘制的xml布局（原理见view的绘制），因此一系列下来导致弹完吐司之后，rootView绘制完了而还在被mToastView引用导致内存泄漏。事实上，你会发现，mToast.view已经被废弃，谷歌官方也不建议我们自定义toast，因为这样确实容易造成内存泄漏，更推荐我们自定义snackBar。</p>
<p>我们再看RootViewWatcher</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RootViewWatcher</span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : InstallableWatcher &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> listener = OnRootViewAddedListener &#123; rootView -&gt;<br>    ...<br>    <span class="hljs-keyword">if</span> (trackDetached) &#123;<br>      rootView.addOnAttachStateChangeListener(<span class="hljs-keyword">object</span> : OnAttachStateChangeListener &#123;<br><br>        <span class="hljs-keyword">val</span> watchDetachedView = Runnable &#123;<br>          reachabilityWatcher.expectWeaklyReachable(<br>            rootView, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;rootView::class.java.name&#125;</span> received View#onDetachedFromWindow() callback&quot;</span><br>          )<br>        &#125;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> &#123;<br>          mainHandler.removeCallbacks(watchDetachedView)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> &#123;<br>          mainHandler.post(watchDetachedView)<br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span> &#123;<br>    Curtains.onRootViewsChangedListeners += listener<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">uninstall</span><span class="hljs-params">()</span></span> &#123;<br>    Curtains.onRootViewsChangedListeners -= listener<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也不过是对rootview注册监听，具体的原理不说了，跟Activity的方式差不多。</p>
<h6 id="ServiceWatcher"><a href="#ServiceWatcher" class="headerlink" title="ServiceWatcher"></a><strong>ServiceWatcher</strong></h6><p>我们再看看ServiceWatcher</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceWatcher</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher) : InstallableWatcher &#123;<br>    ...<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span> &#123;<br>    checkMainThread()<br>    check(uninstallActivityThreadHandlerCallback == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-string">&quot;ServiceWatcher already installed&quot;</span><br>    &#125;<br>    check(uninstallActivityManager == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-string">&quot;ServiceWatcher already installed&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// hook ActivityThread 里面的 mH 的 mCallback</span><br>      swapActivityThreadHandlerCallback &#123; mCallback -&gt;<br>        uninstallActivityThreadHandlerCallback = &#123;<br>          swapActivityThreadHandlerCallback &#123;<br>            mCallback<br>          &#125;<br>        &#125;<br>        <span class="hljs-comment">// 代理对象，替换原来的Callback</span><br>        Handler.Callback &#123; msg -&gt;<br>          <span class="hljs-comment">// https://github.com/square/leakcanary/issues/2114</span><br>          <span class="hljs-comment">// On some Motorola devices (Moto E5 and G6), the msg.obj returns an ActivityClientRecord</span><br>          <span class="hljs-comment">// instead of an IBinder. This crashes on a ClassCastException. Adding a type check</span><br>          <span class="hljs-comment">// here to prevent the crash.</span><br>          <span class="hljs-keyword">if</span> (msg.obj !<span class="hljs-keyword">is</span> IBinder) &#123;<br>            <span class="hljs-keyword">return</span><span class="hljs-symbol">@Callback</span> <span class="hljs-literal">false</span><br>          &#125;<br><br>          <span class="hljs-comment">// 拦截 STOP_SERVICE 消息，这里主要是预处理获取到即将要被 destroy 的 service 对象</span><br>          <span class="hljs-keyword">if</span> (msg.what == STOP_SERVICE) &#123;<br>            <span class="hljs-keyword">val</span> key = msg.obj <span class="hljs-keyword">as</span> IBinder<br>            activityThreadServices[key]?.let &#123;<br>              onServicePreDestroy(key, it)<br>            &#125;<br>          &#125;<br>          <span class="hljs-comment">// 执行原有逻辑</span><br>          mCallback?.handleMessage(msg) ?: <span class="hljs-literal">false</span><br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// hook 替换原来的ActivityManageService 对象</span><br>      swapActivityManager &#123; activityManagerInterface, activityManagerInstance -&gt;<br>        uninstallActivityManager = &#123;<br>          swapActivityManager &#123; _, _ -&gt;<br>            activityManagerInstance<br>          &#125;<br>        &#125;<br>        <span class="hljs-comment">// 动态代理对象</span><br>        Proxy.newProxyInstance(<br>          activityManagerInterface.classLoader, arrayOf(activityManagerInterface)<br>        ) &#123; _, method, args -&gt;<br>          <span class="hljs-comment">// hook 到 service 真正 destroy 的时机，这里没法获取到servcie对象，所以要前面的预操作：onServicePreDestroy</span><br>          <span class="hljs-keyword">if</span> (METHOD_SERVICE_DONE_EXECUTING == method.name) &#123;<br>            <span class="hljs-keyword">val</span> token = args!![<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> IBinder<br>            <span class="hljs-keyword">if</span> (servicesToBeDestroyed.containsKey(token)) &#123;<br>              <span class="hljs-comment">// 回调监测</span><br>              onServiceDestroyed(token)<br>            &#125;<br>          &#125;<br>          <span class="hljs-comment">// 执行原有逻辑</span><br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span>) &#123;<br>              method.invoke(activityManagerInstance)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              method.invoke(activityManagerInstance, *args)<br>            &#125;<br>          &#125; <span class="hljs-keyword">catch</span> (invocationException: InvocationTargetException) &#123;<br>            <span class="hljs-keyword">throw</span> invocationException.targetException<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (ignored: Throwable) &#123;<br>      SharkLog.d(ignored) &#123; <span class="hljs-string">&quot;Could not watch destroyed services&quot;</span> &#125;<br>    &#125;<br>  &#125;<br>    ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceDestroyed</span><span class="hljs-params">(token: <span class="hljs-type">IBinder</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 通过 token 匹配到预处理时获取到的 service 对象</span><br>    servicesToBeDestroyed.remove(token)?.also &#123; serviceWeakReference -&gt;<br>      serviceWeakReference.<span class="hljs-keyword">get</span>()?.let &#123; service -&gt;<br>      <span class="hljs-comment">// 将 service 对象加入到 watchedObjects 里面，之后就和activity一样了</span><br>        reachabilityWatcher.expectWeaklyReachable(<br>          service, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;service::class.java.name&#125;</span> received Service#onDestroy() callback&quot;</span><br>        )<br>      &#125;<br>    &#125;<br>  &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对Service的监控可能就比较奇怪了，因为Service没有对外公开Service生命周期的监听方式，所以只能hook ，所以这里面就涉及了Service的底层原理和hook技术，要真正理解的话得知道Service的底层原理的hook，这里简单说一下：启动Service的时候，在ActivityThread里面都会有记录，启动的Service都会存进mServices里面，onDestory的时候，AMS会用Handler发给ActivityThread告诉某某Service要销毁了，此时ActivityThread就会通过IActivityManger回调Service的onDestory方法，IActivityManger存储了四大组件的周期函数，所以通过它来调用Service的周期函数。因此原理也是这样，通过hook AMS发过来Service onDestory的信息记录Service，进而在IActivityManger回调Service onDestory的时候找到这个Service并监测。</p>
<h5 id="监听之后是怎么处理的呢？"><a href="#监听之后是怎么处理的呢？" class="headerlink" title="监听之后是怎么处理的呢？"></a>监听之后是怎么处理的呢？</h5><p>现在几个监测的类讲完了，那么第二个问题也解决了，接下来我们看看刚刚还没呢分析的核心组件</p>
<h6 id="InternalLeakCanary"><a href="#InternalLeakCanary" class="headerlink" title="InternalLeakCanary"></a><strong>InternalLeakCanary</strong></h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@JvmOverloads</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manualInstall</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  application: <span class="hljs-type">Application</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  retainedDelayMillis: <span class="hljs-type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>)</span></span>,<span class="hljs-comment">//对检测对象延迟5秒检测</span><br>  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)<span class="hljs-comment">//默认的一些观察器</span><br>) &#123;<br>  checkMainThread()<br>  <span class="hljs-keyword">if</span> (isInstalled) &#123;<br>    <span class="hljs-keyword">throw</span> IllegalStateException(<br>      <span class="hljs-string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause<br>    )<br>  &#125;<br>  check(retainedDelayMillis &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-string">&quot;retainedDelayMillis <span class="hljs-variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span><br>  &#125;<br>  <span class="hljs-keyword">this</span>.retainedDelayMillis = retainedDelayMillis<br>  <span class="hljs-keyword">if</span> (application.isDebuggableBuild) &#123;<br>    LogcatSharkLog.install()<span class="hljs-comment">//日志的初始化</span><br>  &#125;<br>  <span class="hljs-comment">//核心组件，用于检测泄漏和对堆转储(head dump)的分析</span><br>  LeakCanaryDelegate.loadLeakCanary(application)<br><br>  <span class="hljs-comment">//对每一个检测器进行初始化</span><br>  watchersToInstall.forEach &#123;<br>    it.install()<br>  &#125;<br>  <span class="hljs-comment">// Only install after we&#x27;re fully done with init.</span><br>  installCause = RuntimeException(<span class="hljs-string">&quot;manualInstall() first called here&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看看LeakCanaryDelegate.loadLeakCanary(application)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> LeakCanaryDelegate &#123;<br><br>  <span class="hljs-meta">@Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>  <span class="hljs-keyword">val</span> loadLeakCanary <span class="hljs-keyword">by</span> lazy &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//通过反射实例化InternalLeakCanary，并调用了invoke方法</span><br>      <span class="hljs-keyword">val</span> leakCanaryListener = Class.forName(<span class="hljs-string">&quot;leakcanary.internal.InternalLeakCanary&quot;</span>)<br>      leakCanaryListener.getDeclaredField(<span class="hljs-string">&quot;INSTANCE&quot;</span>)<br>        .<span class="hljs-keyword">get</span>(<span class="hljs-literal">null</span>) <span class="hljs-keyword">as</span> (Application) -&gt; <span class="hljs-built_in">Unit</span><br>    &#125; <span class="hljs-keyword">catch</span> (ignored: Throwable) &#123;<br>      NoLeakCanary<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">object</span> NoLeakCanary : (Application) -&gt; <span class="hljs-built_in">Unit</span>, OnObjectRetainedListener &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onObjectRetained</span><span class="hljs-params">()</span></span> &#123;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为什么要通过反射实例化咧？因为InternalLeakCanary在另一个模块，而他又是internal，所以只能通过反射了。那我们看看InternalLeakCanary复写的invoke方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(application: <span class="hljs-type">Application</span>)</span></span> &#123;<br>  _application = application<span class="hljs-comment">//传入application</span><br><br>  checkRunningInDebuggableBuild()<br><br>    <span class="hljs-comment">//哦~原来是在这设置的OnObjectRetainedListener</span><br>  AppWatcher.objectWatcher.addOnObjectRetainedListener(<span class="hljs-keyword">this</span>)<br><br>    <span class="hljs-comment">//创建gc触发器，这样的GC更容易触发垃圾回收</span><br>  <span class="hljs-keyword">val</span> gcTrigger = GcTrigger.Default<br><br>  <span class="hljs-keyword">val</span> configProvider = &#123; LeakCanary.config &#125;<br><br>  <span class="hljs-keyword">val</span> handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)<br>  handlerThread.start()<br>  <span class="hljs-keyword">val</span> backgroundHandler = Handler(handlerThread.looper)<br><br>    <span class="hljs-comment">// 创建分析heap dump的启动器,heap dump堆转储，上面提过</span><br>  heapDumpTrigger = HeapDumpTrigger(<br>    application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger,<br>    configProvider<br>  )<br>    <span class="hljs-comment">// 应用前后台监听，前后台监听逻辑差异化处理</span><br>  application.registerVisibilityListener &#123; applicationVisible -&gt;<br>    <span class="hljs-keyword">this</span>.applicationVisible = applicationVisible<br>    heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)<br>  &#125;<br>  registerResumedActivityListener(application)<br>    <span class="hljs-comment">//桌面添加图标</span><br>  addDynamicShortcut(application)<br><br>  <span class="hljs-comment">// We post so that the log happens after Application.onCreate()</span><br>  mainHandler.post &#123;<br>    <span class="hljs-comment">// https://github.com/square/leakcanary/issues/1981</span><br>    <span class="hljs-comment">// We post to a background handler because HeapDumpControl.iCanHasHeap() checks a shared pref</span><br>    <span class="hljs-comment">// which blocks until loaded and that creates a StrictMode violation.</span><br>    backgroundHandler.post &#123;<br>      SharkLog.d &#123;<br>        <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()) &#123;<br>          <span class="hljs-keyword">is</span> Yup -&gt; application.getString(R.string.leak_canary_heap_dump_enabled_text)<br>          <span class="hljs-keyword">is</span> Nope -&gt; application.getString(<br>            R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()<br>          )<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原来我们之前在moveToRetain里回调的方法在这注册的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveToRetained</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> &#123;<br>  removeWeaklyReachableObjects()<br>  <span class="hljs-keyword">val</span> retainedRef = watchedObjects[key]<br>  <span class="hljs-keyword">if</span> (retainedRef != <span class="hljs-literal">null</span>) &#123;<br>    retainedRef.retainedUptimeMillis = clock.uptimeMillis()<br>      <span class="hljs-comment">//责任链模式</span><br>    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那我们看看InternalLeakCanary对onObjectRetained()的实现，发现其调用的是scheduleRetainedObjectCheck()</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>::heapDumpTrigger.isInitialized) &#123;<br>    heapDumpTrigger.scheduleRetainedObjectCheck()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用的是scheduleRetainedObjectCheck()</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  delayMillis: <span class="hljs-type">Long</span> = <span class="hljs-number">0</span>L</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  <span class="hljs-keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt<br>  <span class="hljs-keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//通过记录时间戳来避免重复检测</span><br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  checkScheduledAt = SystemClock.uptimeMillis() + delayMillis<span class="hljs-comment">//记录时间</span><br>  backgroundHandler.postDelayed(&#123;<br>    checkScheduledAt = <span class="hljs-number">0</span><br>    checkRetainedObjects()<span class="hljs-comment">//检测留存的对象</span><br>  &#125;, delayMillis)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过记录时间避免重复检测，然后向子线程post了一Runnable，瞅瞅checkRetainedObjects</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkRetainedObjects</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//是否能够heap dump</span><br>  <span class="hljs-keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()<br><br>  <span class="hljs-keyword">val</span> config = configProvider()<br><br>  <span class="hljs-keyword">if</span> (iCanHasHeap <span class="hljs-keyword">is</span> Nope) &#123;<br>    <span class="hljs-keyword">if</span> (iCanHasHeap <span class="hljs-keyword">is</span> NotifyingNope) &#123;<span class="hljs-comment">//发送一个通知，用户点击后通过</span><br>      <span class="hljs-comment">// Before notifying that we can&#x27;t dump heap, let&#x27;s check if we still have retained object.</span><br>        <span class="hljs-keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount<br><br>        <span class="hljs-keyword">if</span> (retainedReferenceCount &gt; <span class="hljs-number">0</span>) &#123;<br>          gcTrigger.runGc()<span class="hljs-comment">//分析前再确保一次是否真的泄漏，调用一次GC</span><br>          retainedReferenceCount = objectWatcher.retainedObjectCount<br>        &#125;<br><br>        <span class="hljs-keyword">val</span> nopeReason = iCanHasHeap.reason()<br>        <span class="hljs-comment">//主要是判断是否达到阈值，前台的时候是&gt;=5个会触发，后台是&gt;=1个就会触发</span><br>        <span class="hljs-keyword">val</span> wouldDump = !checkRetainedCount(<br>          retainedReferenceCount, config.retainedVisibleThreshold, nopeReason<br>        )<br><br>        <span class="hljs-keyword">if</span> (wouldDump) &#123;<br>          <span class="hljs-keyword">val</span> uppercaseReason = nopeReason[<span class="hljs-number">0</span>].toUpperCase() + nopeReason.substring(<span class="hljs-number">1</span>)<br>          onRetainInstanceListener.onEvent(DumpingDisabled(uppercaseReason))<br>          showRetainedCountNotification(<span class="hljs-comment">//通知</span><br>            objectCount = retainedReferenceCount,<br>            contentText = uppercaseReason<br>          )<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      SharkLog.d &#123;<br>        application.getString(<br>          R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()<br>        )<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><span class="hljs-comment">//如果不能堆转储，进行了一些列操作，然后再尝试分析</span><br>  <span class="hljs-keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount<br><br>  <span class="hljs-keyword">if</span> (retainedReferenceCount &gt; <span class="hljs-number">0</span>) &#123;<br>    gcTrigger.runGc()<br>    retainedReferenceCount = objectWatcher.retainedObjectCount<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">val</span> now = SystemClock.uptimeMillis()<br>  <span class="hljs-keyword">val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis<br>  <span class="hljs-keyword">if</span> (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;<br>    onRetainInstanceListener.onEvent(DumpHappenedRecently)<br>    showRetainedCountNotification(<br>      objectCount = retainedReferenceCount,<br>      contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)<br>    )<br>    scheduleRetainedObjectCheck(<br>      delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis<br>    )<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  dismissRetainedCountNotification()<br>  <span class="hljs-keyword">val</span> visibility = <span class="hljs-keyword">if</span> (applicationVisible) <span class="hljs-string">&quot;visible&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;not visible&quot;</span><br>    <span class="hljs-comment">//分析hprof文件</span><br>  dumpHeap(<br>    retainedReferenceCount = retainedReferenceCount,<br>    retry = <span class="hljs-literal">true</span>,<br>    reason = <span class="hljs-string">&quot;<span class="hljs-variable">$retainedReferenceCount</span> retained objects, app is <span class="hljs-variable">$visibility</span>&quot;</span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先看看能不能堆转储，如果可以，就发送通知，如果不能，做了一系列操作，再尝试分析，其实这跟MAT有点类似，MAT也是不能直接就解析hprof文件，最后你会发现，最终调用的都是dumpHeap()方法，我们看dumpHeap方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">HeapDumpTrigger.kt<br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpHeap</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  retainedReferenceCount: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  retry: <span class="hljs-type">Boolean</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  reason: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  <span class="hljs-keyword">val</span> directoryProvider =<br>    InternalLeakCanary.createLeakDirectoryProvider(InternalLeakCanary.application)<br>  <span class="hljs-keyword">val</span> heapDumpFile = directoryProvider.newHeapDumpFile()<span class="hljs-comment">//创建导出的文件夹</span><br><br>  <span class="hljs-keyword">val</span> durationMillis: <span class="hljs-built_in">Long</span><br>  <span class="hljs-keyword">if</span> (currentEventUniqueId == <span class="hljs-literal">null</span>) &#123;<br>    currentEventUniqueId = UUID.randomUUID().toString()<br>  &#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>    InternalLeakCanary.sendEvent(DumpingHeap(currentEventUniqueId!!))<br>    <span class="hljs-keyword">if</span> (heapDumpFile == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">&quot;Could not create heap dump file&quot;</span>)<br>    &#125;<br>    saveResourceIdNamesToMemory()<br>    <span class="hljs-keyword">val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()<br>    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis<br>    durationMillis = measureDurationMillis &#123;<br>      configProvider().heapDumper.dumpHeap(heapDumpFile)<span class="hljs-comment">//主要方法，用系统导出堆转储文件</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (heapDumpFile.length() == <span class="hljs-number">0L</span>) &#123;<br>      <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">&quot;Dumped heap file is 0 byte length&quot;</span>)<br>    &#125;<br>    lastDisplayedRetainedObjectCount = <span class="hljs-number">0</span><br>    lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()<br>    objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)<br>    currentEventUniqueId = UUID.randomUUID().toString()<br>      <span class="hljs-comment">//将导出情况回调出去，根据失败和成功给用户弹通知（一般是成功）</span><br>    InternalLeakCanary.sendEvent(HeapDump(currentEventUniqueId!!, heapDumpFile, durationMillis, reason))<br>  &#125; <span class="hljs-keyword">catch</span> (throwable: Throwable) &#123;<br>    InternalLeakCanary.sendEvent(HeapDumpFailed(currentEventUniqueId!!, throwable, retry))<br>    <span class="hljs-keyword">if</span> (retry) &#123;<br>      scheduleRetainedObjectCheck(<br>        delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS<br>      )<br>    &#125;<br>    showRetainedCountNotification(<br>      objectCount = retainedReferenceCount,<br>      contentText = application.getString(<br>        R.string.leak_canary_notification_retained_dump_failed<br>      )<br>    )<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先创建了文件夹然后是保存时间，ID啊一些的操作，最主要的是configProvider().heapDumper.dumpHeap(heapDumpFile)，查找它的实现其实就是</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> AndroidDebugHeapDumper : HeapDumper &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dumpHeap</span><span class="hljs-params">(heapDumpFile: <span class="hljs-type">File</span>)</span></span> &#123;<br>    Debug.dumpHprofData(heapDumpFile.absolutePath)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用系统的Debug工具调出hprof文件。之后我们看导出成功回调做了什么事情</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> RemoteWorkManagerHeapAnalyzer : EventListener &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> REMOTE_SERVICE_CLASS_NAME = <span class="hljs-string">&quot;leakcanary.internal.RemoteLeakCanaryWorkerService&quot;</span><br><br>  <span class="hljs-keyword">internal</span> <span class="hljs-keyword">val</span> remoteLeakCanaryServiceInClasspath <span class="hljs-keyword">by</span> lazy &#123;<span class="hljs-comment">//返回true</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      Class.forName(REMOTE_SERVICE_CLASS_NAME)<br>      <span class="hljs-literal">true</span><br>    &#125; <span class="hljs-keyword">catch</span> (ignored: Throwable) &#123;<br>      <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(event: <span class="hljs-type">Event</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">is</span> HeapDump) &#123;<br>      <span class="hljs-keyword">val</span> application = InternalLeakCanary.application<br>      <span class="hljs-keyword">val</span> heapAnalysisRequest =<span class="hljs-comment">//构建一个workmanagerRequest，执行一次</span><br>        OneTimeWorkRequest.Builder(RemoteHeapAnalyzerWorker::<span class="hljs-keyword">class</span>.java).apply &#123;<br>          <span class="hljs-keyword">val</span> dataBuilder = Data.Builder()<br>            .putString(ARGUMENT_PACKAGE_NAME, application.packageName)<br>            .putString(ARGUMENT_CLASS_NAME, REMOTE_SERVICE_CLASS_NAME)<br>          setInputData(event.asWorkerInputData(dataBuilder))<br>          with(WorkManagerHeapAnalyzer) &#123;<span class="hljs-comment">//任务内容在WorkManagerHeapAnalyzer里面</span><br>            addExpeditedFlag()<br>          &#125;<br>        &#125;.build()<br>      SharkLog.d &#123; <span class="hljs-string">&quot;Enqueuing heap analysis for <span class="hljs-subst">$&#123;event.file&#125;</span> on WorkManager remote worker&quot;</span> &#125;<br>      <span class="hljs-keyword">val</span> workManager = WorkManager.getInstance(application)<br>      workManager.enqueue(heapAnalysisRequest)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们发现根据回调的Event类型，回调到了这里，传进来的Event就是HeapDump，可以看到用WorkManager创建了一个异步任务WorkManagerHeapAnalyzer，然后执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteHeapAnalyzerWorker</span>(appContext: Context, workerParams: WorkerParameters) :<br>  RemoteListenableWorker(appContext, workerParams) &#123;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startRemoteWork</span><span class="hljs-params">()</span></span>: ListenableFuture&lt;Result&gt; &#123;<br>    <span class="hljs-keyword">val</span> heapDump = inputData.asEvent&lt;HeapDump&gt;()<br>    <span class="hljs-keyword">val</span> result = SettableFuture.create&lt;Result&gt;()<br>    heapAnalyzerThreadHandler.post &#123;<span class="hljs-comment">//开启子线程执行分析任务</span><br>      <span class="hljs-keyword">val</span> doneEvent = AndroidDebugHeapAnalyzer.runAnalysisBlocking(heapDump, isCanceled = &#123;<br>        result.isCancelled<br>      &#125;) &#123; progressEvent -&gt;<br>        <span class="hljs-keyword">if</span> (!result.isCancelled) &#123;<span class="hljs-comment">//将分析进度发送出去</span><br>          InternalLeakCanary.sendEvent(progressEvent)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (result.isCancelled) &#123;<br>        SharkLog.d &#123; <span class="hljs-string">&quot;Remote heap analysis for <span class="hljs-subst">$&#123;heapDump.file&#125;</span> was canceled&quot;</span> &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        InternalLeakCanary.sendEvent(doneEvent)<span class="hljs-comment">//结束</span><br>        result.<span class="hljs-keyword">set</span>(Result.success())<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getForegroundInfoAsync</span><span class="hljs-params">()</span></span>: ListenableFuture&lt;ForegroundInfo&gt; &#123;<br>    <span class="hljs-keyword">return</span> applicationContext.heapAnalysisForegroundInfoAsync()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>heapAnalyzerThreadHandler实际上就是开启一个子线程然后执行runAnalysisBlocking，runAnalysisBlocking里面就是把文件交给了HeapAnalyzer去分析，HeapAnalyzer然后用Shark 分析hprof文件，具体Shark分析的原理就不说了，我也没怎么研究过，我觉得也没有用，会用就行了。Shark是LeakCanary的一个分析hprof文件的模块，因此我们也可以用shark开发一个用于线上的SDK，LeakCanary现在是不支持线上检测的。</p>
<p>用一张图总结一下它的原理其实就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sequence">AppWatcher -&gt; objectWatcher:检测到泄漏<br>objectWatcher -&gt; InternalLeakCanary:5秒后gc还是没回收<br>InternalLeakCanary-&gt;HeapDumpTrigger:scheduleRetainedObjectCheck()<br>HeapDumpTrigger-&gt;HeapAnalyzerThreadHandler:再强制GC一次，还是泄漏<br>HeapAnalyzerThreadHandler-&gt;HeapAnalyzer:dumpHeap()<br>HeapAnalyzer-&gt;Shark分析:<br>Shark分析 -&gt; dataBase:发出通知，数据存进数据库<br><br></code></pre></td></tr></table></figure>

<p>可能还有人会疑另一个叫Leaks的app图标怎么生成的，其实它也不算是个app，它是你app的一部分，不信你把Leaks卸载了，你的app也会跟着卸载。实现这个很简单，用<activity-alias>标签就能实现。示例如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">    <span class="hljs-attr">.</span> <span class="hljs-attr">.</span> <span class="hljs-attr">.</span>&gt;</span><br>    <br>    . . .<br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.SecondActivity&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activity-alias</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.jason.demo.dynamicshortcut.ShortcutLauncherActivity&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_alias&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;ActivityAlias&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:targetActivity</span>=<span class="hljs-string">&quot;.SecondActivity&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">activity-alias</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>其中，<code>android:targetActivity</code> 指定所必须的打开的目标 Activity，对应着一个在 <code>AndroidManifest.xml</code> 中申明的 <code>&lt;activity&gt;</code>。<code>android:name</code> 是别名的唯一名称，<strong>不引用实际类</strong>。<code>android:icon</code> 以及 <code>android:label</code> 指定一个新的图标和标签给用户。之后就能看见你的app生成了两个图标。</p>
<p>你如果不想LeakCanary自动初始化也是可以的。设置如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bool</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;leak_canary_watcher_auto_install&quot;</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后在你想要初始化的地方AppWatcher.manualInstall即可</p>
<p>好了，LeakCanary源码算简单分析了一下，不算细致，可以借鉴一下。下面是一些常见的内存泄漏</p>
<ol>
<li><p>单例模式引发的内存泄漏</p>
<p>原因：单例模式里的静态实例持有对象的引用，导致对象无法被回收，常见为持有Activity的引用</p>
<p>优化：改为持有Application的引用，或者不持有使用的时候传递。</p>
</li>
<li><p>集合操作不当引发的内存泄漏</p>
<p>原因：集合只增不减</p>
<p>优化：有对应的删除或卸载操作</p>
</li>
<li><p>线程的操作不当引发的内存泄漏</p>
<p>原因：线程持有对象的引用在后台执行，与对象的生命周期不一致</p>
<p>优化：静态实例+弱引用(WeakReference)方式，使其生命周期一致</p>
</li>
<li><p>匿名内部类&#x2F;非静态内部类操作不当引发的内存泄漏</p>
<p>原因：内部类持有对象引用，导致无法释放，比如各种回调</p>
<p>优化：保持生命周期一致，改为静态实例+对象的弱引用方式（WeakReference）</p>
</li>
<li><p>常用的资源未关闭回收引发的内存泄漏</p>
<p>原因：BroadcastReceiver，File，Cursor，IO流，Bitmap等资源使用未关闭</p>
<p>优化：使用后有对应的关闭和卸载机制</p>
</li>
<li><p>Handler使用不当造成的内存泄漏</p>
<p>原因：Handler持有Activity的引用，其发送的Message中持有Handler的引用，当队列处理Message的时间过长会导致Handler无法被回收</p>
<p>优化：静态实例+弱引用(WeakReference)方式</p>
</li>
</ol>
<h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><p>在上一章我们说activity在onCreate的时候会绘制布局，这也是性能优化很重要的一个点。</p>
<p>通过学习view的绘制流程我们知道，对于屏幕刷新频率60hz的手机来说，如果在1000&#x2F;60&#x3D;16.67ms内没有把这一帧的任务执行完毕，就会发生丢帧的现象，丢帧是造成界面卡顿的直接原因，渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout等计算操作，GPU负责Rasterization（栅格化）操作。</p>
<p>所谓栅格化，就是将矢量图形转换为位图的过程，手机上显示是按照一个个像素来显示的，比如将一个Button、TextView等组件拆分成一个个像素显示到手机屏幕上。而UI渲染优化的目的就是减轻CPU、GPU的压力，除去不必要的操作，保证每帧16ms以内处理完所有的CPU与GPU的计算、绘制、渲染等等操作，使UI顺滑、流畅的显示出来。</p>
<h4 id="过度绘制"><a href="#过度绘制" class="headerlink" title="过度绘制"></a>过度绘制</h4><p>UI渲染优化的第一步就是找到Overdraw（过度绘制），即描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在重叠的UI布局中，如果不可见的UI也在做绘制的操作或者后一个控件将前一个控件遮挡，会导致某些像素区域被绘制了多次，从而增加了CPU、GPU的压力。</p>
<p>那么如何找出布局中Overdraw的地方呢？很简单，就是打开手机里开发者选项，然后将调试GPU过度绘制的开关打开即可，然后就可以看到应用的布局是否被Overdraw，比如我打开了调试过度绘制的开关，然后看QQ是这样的<br><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220712_174301.jpg" srcset="/img/loading.gif" lazyload style="zoom: 25%;" /><br>蓝色、淡绿、淡红、深红代表了4种不同程度的Overdraw情况，1x、2x、3x和4x分别表示同一像素上同一帧的时间内被绘制了多次，1x就表示一次(最理想情况)，4x表示4次(最差的情况)，而我们做性能优化时，考虑消除的就是3x和4x。</p>
<p>其次是自定义view时的过度绘制，我们知道，自定义View的时候有时会重写onDraw方法，但是Android系统是无法检测onDraw里面具体会执行什么操作，从而系统无法为我们做一些优化。这样对编程人员要求就高了，如果View有大量重叠的地方就会造成CPU、GPU资源的浪费，此时我们可以使用canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视，还有clipPath()也是可以减少过度绘制的，只不过可能效果甚微。</p>
<h4 id="合理布局"><a href="#合理布局" class="headerlink" title="合理布局"></a>合理布局</h4><p>在Android种系统对View进行测量、布局和绘制时，都是通过对View树的遍历来进行操作的。如果一个View树的高度太高就会严重影响测量、布局和绘制的速度。Google设计嵌套View最多是10层否则会崩溃。现在版本种Google使用RelativeLayout替代LineraLayout作为默认根布局，目的就是降低LineraLayout嵌套产生布局树的高度，从而提高UI渲染的效率。一下是合理布局的一些建议</p>
<ol>
<li>布局重用，对于多次重用的布局使用<include>标签来达到重用的目的，对于根布局一样的，可使用<merge>标签取消冗余的viewgroup。比如我我们使用<include>标签的时候可能include里面的布局最外层是<LinearLayout>，而在外部的外层布局也是<LinearLayout>，这时候就可以用<merge>标签替换里面的<LinearLayout>，然后系统就会把include的布局放到外部的LinearLayout而忽视merge，从而减少一层嵌套。</li>
<li>对于一些复杂的布局我们有时候是不需要一来就全部加载的，这时候就可以用<ViewStub>标签来实现延迟加载，那有人可能会问，我直接设置控件的visible和invisible不行吗，是可以。但是设置visibility属性布局依然会被加载，只是不显示罢了，而VeiwStub只有被设置成visible时才会被加载。</li>
<li>减少布局层级当布局层级太多的时候可以考虑Constranlayout，这个布局性能很好，适配好还能减少布局间的嵌套，其次可以考虑RelaticeLayout。</li>
<li>减少不必要的背景设置，减少复杂shape等。能用父布局的背景，子布局就没必要再设置背景。</li>
</ol>
<p>那么怎样更直观地看自己App的布局层级呢？AS已经为我们集成了这么一个工具，具体打开的地方（需启动一个app）：</p>
<p>Tools -&gt; Layout Inspector</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220712180704.png" srcset="/img/loading.gif" lazyload></p>
<p>左边是你app的布局树，中间是布局预览，右边是布局属性。借此可以全局分析你的app布局，就没必要再去每一个xml布局去看了。</p>
<h3 id="WebVeiw优化"><a href="#WebVeiw优化" class="headerlink" title="WebVeiw优化"></a>WebVeiw优化</h3><p>WebView也是UI的一个部分，虽然html界面布局我们改变不了，但是我们可以通过WebView的用法去提高webview的性能。</p>
<h4 id="webview提前初始化"><a href="#webview提前初始化" class="headerlink" title="webview提前初始化"></a><strong>webview提前初始化</strong></h4><p>我们知道每个页面在打开时都会调用setContentView()方法 -&gt; inflate() -&gt; createViewFromTag()，也就是说都会调用view的构造函数，webview也不例外，但是不同的是webview的首次构造耗时比较长。我们可以测试一下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        findViewById&lt;Button&gt;(R.id.button).setOnClickListener &#123;<br>            test()<br>            test()<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> start = System.currentTimeMillis()<br>        WebView(App.appContext)<br>        <span class="hljs-keyword">val</span> stop = System.currentTimeMillis()<br>        Log.d(<span class="hljs-string">&quot;RQ&quot;</span>, <span class="hljs-string">&quot;test: <span class="hljs-subst">$&#123;stop - start&#125;</span>&quot;</span>)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">07</span>-<span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">15</span>:<span class="hljs-number">07</span>.<span class="hljs-number">432</span> <span class="hljs-number">29656</span>-<span class="hljs-number">29656</span>/com.example.improvetest D/RQ: test: <span class="hljs-number">167</span><br><span class="hljs-attribute">2022</span>-<span class="hljs-number">07</span>-<span class="hljs-number">12</span> <span class="hljs-number">20</span>:<span class="hljs-number">15</span>:<span class="hljs-number">07</span>.<span class="hljs-number">435</span> <span class="hljs-number">29656</span>-<span class="hljs-number">29656</span>/com.example.improvetest D/RQ: test: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>可以看到第二次初始化webview的时间远小于第一次，这是为什么捏？因为它要加载Webview内核，这是一个重量级的操作，内核是以apk的形式存在。而内核加载后在同一页面是共享的，因此后续的初始化时间就很少了。</p>
<p>那知道了这个我们可以提前初始化一个webview，减少后续webview初始化的时间。</p>
<h4 id="WebView硬件加速致使页面渲染闪烁"><a href="#WebView硬件加速致使页面渲染闪烁" class="headerlink" title="WebView硬件加速致使页面渲染闪烁"></a><strong>WebView硬件加速致使页面渲染闪烁</strong></h4><p>4.0以上的系统我们开启硬件加速后，WebView渲染页面更加快速，拖动也更加顺滑。但有个反作用就是，但有的时候可能会出现页面闪烁的情况，解决这个问题的方法是在闪烁前将WebView的硬件加速临时关闭，之后再开启，代码以下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;<br>	<span class="hljs-comment">//关闭硬件加速</span><br>	<span class="hljs-comment">//webview.setLayerType(View.LAYER_TYPE_SOFTWARE, null)</span><br>	<span class="hljs-comment">//开启硬件加速</span><br>    <span class="hljs-comment">//webview.setLayerType(View.LAYER_TYPE_HARDWARE, null)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="增加进度条"><a href="#增加进度条" class="headerlink" title="增加进度条"></a><strong>增加进度条</strong></h4><p>在网络不是很好的情况下，加载页面会出现白屏的情况，虽然我们不能改变，但是我们可以增加一个进度条来让用户知道加载进度，这也算是提升了性能了吧。具体代码如下:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">webView.webChromeClient = <span class="hljs-keyword">object</span> :WebChromeClient()&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onProgressChanged</span><span class="hljs-params">(view: <span class="hljs-type">WebView</span>?, newProgress: <span class="hljs-type">Int</span>)</span></span> &#123;<br>                <span class="hljs-keyword">if</span>(newProgress==<span class="hljs-number">100</span>)&#123;<br>                    pg1.setVisibility(View.GONE);<span class="hljs-comment">//加载完网页进度条消失</span><br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    pg1.setVisibility(View.VISIBLE);<span class="hljs-comment">//开始加载网页时显示进度条</span><br>                    pg1.setProgress(newProgress);<span class="hljs-comment">//设置进度值</span><br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>如果webveiw在你的应用中占比很高，很重要，还可以将webview做成一个独立进程（如果有能力），然后用aidl，messager，content provider，广播等来跨进程通信，这样webview就不会影响原app的性能。比如QQ，微信，微信的第一次重构就将webview做成了独立的进程。</p>
<p>webview我用的也不是很多，把一些我们可能用得上一些问题的做法给大家分享了一些，如果还觉得不够细致，具体可看看<a target="_blank" rel="noopener" href="https://juejin.cn/post/6857701249295810568">Android WebView 优化梳理 - 掘金 (juejin.cn)</a></p>
<h2 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h2><p>卡顿优化其实前面也分析过了，UI绘制卡顿呐，启动慢导致的卡顿呐等等，具体见启动优化和渲染优化。这里说说卡顿到极致—-ANR之后如何解决。</p>
<h4 id="ANR问题分析"><a href="#ANR问题分析" class="headerlink" title="ANR问题分析"></a>ANR问题分析</h4><p>ANR(Application Not responding)问题一般出现在Activtiy5秒之内无法响应屏幕触摸事件或者键盘输入事件，而BroadcastReceiver如果10秒之内还未执行完操作也会ANR。在实际开发中，ANR是很难从代码上发现的，那么我们应该怎么定位问题呢？其实，当一个进程发生ANR以后，系统会在&#x2F;data&#x2F;anr目录下创建记录ANR问题的文件，通过分析这些文件就能定位ANR的位置。</p>
<p>这里我们模拟一下ANR，主界面就一个按钮，然后给按钮注册监听：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        <span class="hljs-keyword">val</span> button = findViewById&lt;Button&gt;(R.id.button)<br>        button.setOnClickListener &#123;<br>            testANR()<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testANR</span><span class="hljs-params">()</span></span> &#123;<br>        Thread.sleep(<span class="hljs-number">30</span>*<span class="hljs-number">1000</span>)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>之后点击按钮两次你就会看到ANR或者直接崩溃。之后我们就假装不知道ANR的位置，开始分析问题。</p>
<p>在老版本系统（<code>Android8.1</code>以下）的手机上，可以直接利用<code>adb pull /data/anr/traces.txt</code> 命令进行日志导出。</p>
<p>在新系统中用这个命令是无法导出的，它会提示你权限不够。那么怎么办呢，我们可以通过<code>adb bugreport [导出目录]</code>进行导出，这个会导出一大堆东西（我们只挑选有用的）。比如在控制台执行<code>adb bugreport E:\test</code> ，他会从手机中导出一个<code>zip</code>包到电脑的<code>E:\test</code>目录，会有导出进度显示：</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220708215247.png" srcset="/img/loading.gif" lazyload alt="D"></p>
<p>导出完成：</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708215035.png" srcset="/img/loading.gif" lazyload alt="D"></p>
<p>随后找到导出的文件，解压缩，在<code>/FS/data/anr</code>目录下可以找到程序中的ANR日志。</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708215416.png" srcset="/img/loading.gif" lazyload alt="A"></p>
<p>打开日志文件大致浏览一下：</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220708220207.png" srcset="/img/loading.gif" lazyload></p>
<p>可以很明显看到是MainActivtiy里面的onCreate里面的按钮的点击事件的testANR方法里面的Thread.sleep造成的ANR，于是我们就可以痛快地解决问题啦。</p>
<p>当然，实际问题可能比这个更复杂，这里只是告诉大家这么一个方法，到时候就具体问题具体分析。 这里列出一些常见的ANR原因</p>
<ul>
<li>主线程阻塞或主线程数据读取</li>
</ul>
<blockquote>
<p>解决办法：避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。尽量避免在主线程query provider、<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://weishu.me/2016/10/13/sharedpreference-advices/">不要滥用SharePreferenceS</a></p>
</blockquote>
<ul>
<li>CPU满负荷，I&#x2F;O阻塞</li>
</ul>
<blockquote>
<p>解决办法：文件读写或数据库操作放在子线程异步操作。</p>
</blockquote>
<ul>
<li>内存不足</li>
</ul>
<blockquote>
<p>解决办法：<code>AndroidManifest.xml</code>文件<applicatiion>中可以设置 <code>android:largeHeap=&quot;true&quot;</code>，以此增大App使用内存。不过<strong>不建议使用此法</strong>，从根本上防止内存泄漏，优化内存使用才是正道。</p>
</blockquote>
<ul>
<li>各大组件ANR</li>
</ul>
<blockquote>
<p>各大组件生命周期中也应避免耗时操作，注意BroadcastReciever的onRecieve()、后台Service和ContentProvider也不要执行太长时间的任务。</p>
</blockquote>
<h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><p>App的网络连接对于用户来说, 影响很多, 且多数情况下都很直观, 直接影响用户对这个App的使用体验. 其中较为重要的两点：</p>
<ul>
<li><strong>流量</strong> ：App的流量消耗对用户来说是比较敏感的，毕竟流量是花钱的嘛.。现在大部分人的手机上都有安装流量监控的工具App，用来监控App的流量使用。如果我们的App这方面没有控制好，会给用户不好的使用体验。</li>
<li><strong>用户等待</strong> ：也就是用户体验，良好的用户体验，才是我们留住用户的第一步。如果App请求等待时间长，会给用户网络卡，应用反应慢的感觉，如果有对比，有替代品，我们的App很可能就会被用户无情抛弃。</li>
</ul>
<h4 id="如何监测app的网络情况"><a href="#如何监测app的网络情况" class="headerlink" title="如何监测app的网络情况"></a>如何监测app的网络情况</h4><p>监测app网络的工具有很多，比如AS自带的，Fiddler代理工具等等。代理工具就不说了，有很多。这里介绍AS自带的工具如何使用。</p>
<p>启动地方 AS -&gt; App Inspection</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/AAA.png" srcset="/img/loading.gif" lazyload alt="A"></p>
<p>然后就是这样的</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220712233902.png" srcset="/img/loading.gif" lazyload></p>
<p>中间的是网络监听状况，左边的是数据库监听状况，最右边的是后台服务的监听状况，看英文应该也好理解。数据库监听是这样的</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220712234246.jpg" srcset="/img/loading.gif" lazyload alt="A"></p>
<p>什么表名啊，列都有，存的内容也有。网络监听是这样的</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/QQ%E5%9B%BE%E7%89%8720220712234418.jpg" srcset="/img/loading.gif" lazyload alt="A"></p>
<p>蓝色的是下载文件的速度，橙色的是上传文件的速度。后台服务的就不展示了，大家可以试试看。</p>
<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><h5 id="合理使用网络缓存"><a href="#合理使用网络缓存" class="headerlink" title="合理使用网络缓存"></a>合理使用网络缓存</h5><p>适当的使用缓存，不仅可以让我们的应用看起来更快，也能避免一些不必要的流量消耗，带来更好的用户体验，我们可以对设备的使用状态进行监听，在wifi下可以缓存一部分图片。比方说Splash闪屏广告图片，我们可以在连接到Wifi时下载缓存到本地；新闻类的App可以在Wifi状态下做离线缓存</p>
<h5 id="限制访问次数"><a href="#限制访问次数" class="headerlink" title="限制访问次数"></a>限制访问次数</h5><p>我们在开发app过程中有的时候会设置一个按钮，然后点击按钮发送请求，这样其实不是最优做法，如果我点击很多次按钮，就会在短时间内发送多次请求，那么就会浪费流量，也很消耗app的性能。所以我们需要限制访问次数，两种方案</p>
<ol>
<li>限制按钮的点击次数</li>
<li>封装网络请求框架，在框架里限制同一时间访问的次数</li>
</ol>
<h5 id="不同状态展现不同页面"><a href="#不同状态展现不同页面" class="headerlink" title="不同状态展现不同页面"></a>不同状态展现不同页面</h5><p>加载时显示好康的动画，留住用户，加载失败也要展现好康的动画给用户看（别直接崩溃了）。</p>
<p>其实说了这么多，一个好的网络请求框架就可以解决这些网络优化的问题，把这些解决方案封装在自己的网络请求框架里是最好的选择。</p>
<h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><p>现今，我们可能对流量都不是很缺，而且基本每家都有wifi，相较与流量我觉得一个app的耗电对用户更加敏感，现在市面上的手机基本上都有监控每个app的耗电功能，比如我的</p>
<img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/Screenshot_20220713_140120.jpg" srcset="/img/loading.gif" lazyload style="zoom:25%;" />

<p>可以看到QQ后台耗电多，抖音前台耗电多，但是这是QQ，没办法都得用，如果我们自己的app可能就被卸载了。那么我们先来分析一下为什么会耗电，盗用网上一张图就是</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d23d65e12d34ad396b8826de6bf2d35~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>事实上就是软件调用硬件而产生了耗电，那有哪些硬件是可以控制的捏？</p>
<img src="https://img-blog.csdnimg.cn/img_convert/451499b3b9f8131b8396c7870d76670a.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 50%;" />

<p>有这么这么多，我们就看几个常用的，CPU、GPU、Video、Audio、GPS、Network</p>
<h5 id="Video、Audio"><a href="#Video、Audio" class="headerlink" title="Video、Audio"></a>Video、Audio</h5><p>在使用这些功能的使用时候，他牵涉的不单单一个元器件的问题，而是更多，所以我们在使用这些功能的时候要做到离开即刻关闭释放。这两个组件用的最多的可能就是短视频和直播app了，如果出现这部分耗电严重，可以看看这些解决方案：</p>
<ol>
<li>线程数是否暴增。</li>
<li>弹幕是否做到复用了，是否存在内存泄露问题。</li>
<li>动画特效是否及时释放，执行效率是否很快。</li>
<li>承载功能的实例是否存在多份。</li>
<li>检查内存、cpu使用情况。</li>
</ol>
<h5 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h5><p>无线网络包括移动网络和wifi两种情况。移动网络是比wifi更加耗电的。</p>
<p><strong>移动网络</strong></p>
<p>移动网络数据传输有3种状态：</p>
<p>高功率状态：网络激活，允许设备以最大传输速率进行传输。</p>
<p>低功率状态：传输速率低于15kbps，耗电是高功率状态的一半，一般不能直接从程序中进入该状态，而是由高功率状态降级进入。</p>
<p>空闲状态：没有数据连接需要传输，耗电最少。可以看出，三种状态耗电不同，要使耗电最低应该尽量保持状态在空闲或低功率下。从空闲状态转换到高功率状态大概需要2s，从低功率状态转换到高功率状态需要1.5s。</p>
<p>应用中每创建一个网络连接，网络射频都会转到高功率状态，数据传输完毕降回低功率状态，降回过程需要5s，这5s耗电量保持在高功率状态，低功率降回到空闲状态需要12s，期间一直保持低功率状态。所以每次的数据传输都将导致将近20s电量的消耗。</p>
<p><strong>WIFI网络</strong></p>
<p>WIFI在active状态下有4种模式：低功率、高功率、低传输、高传输。</p>
<p>当从低(高)功率状态传输数据时，WIFI会暂时进入相应的低(高)传输状态，一旦数据传输完毕就回到初始状态。WIFI耗电是受包率(每秒接收和发送的数据包)和网速因素影响的。如果因素良好，即网络良好时，数据传输的很快，所以WIFI的高功率状态维持时间很短。这也就是为什么说移动网络耗电高于WIFI耗电，因为同样的数据大小传输时，移动网络固定状态转换就需要近20s的电量消耗。通过上面了解了网络连接过程，应该心里有了大概的优化建议。</p>
<p><strong>网络耗电优化方案：</strong></p>
<ol>
<li>文本和文件压缩传输。 不管发送还是请求数据，在数据传输过程中使用gzip（Gzip是传输时将文件压缩传输的一种技术，okhttp默认是使用了gzip的）将数据进行压缩。经过压缩的数据需要更短的时间传输即可完成，这样使得无线所处的高功率状态时间更短，从而减少了耗电。</li>
<li>精简文本文件，去掉文本中空行、空格、注释等无意义内容。</li>
<li>请求一个图片时，客户端提供一个分辨率大小，服务器根据分辨率把裁剪缩放后的图片给客户端返回，采用使用webp图片。（节省传输时间）</li>
</ol>
<h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><strong>CPU</strong></h5><p>cpu作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。通过上面的两个概念我们大概知道，一个我们负责设备运算和控制的元器件，一个是程序运算调度的最小单位。</p>
<p>CPU被高频次使用大概有以下几个原因：</p>
<ol>
<li><p>程序运算复杂(高运算量)，例如高精度等，导致CPU满负荷运载，这里优化可能就设计数据结构、算法啥的。</p>
</li>
<li><p>程序线程短时间内无规则抢占CPU资源。</p>
</li>
<li><p>wakelock唤醒。wakelock是什么？</p>
<blockquote>
<p>为了延长电池的使用寿命，Android设备会在一段时间后使屏幕变暗，然后关闭屏幕显示，最后停止CPU。WakeLock是一个电源管理系统服务功能，应用程序可以使用它来控制设备的电源状态。</p>
<p>WakeLock可以用来保持CPU运行，避免屏幕变暗和关闭，以及避免键盘背光灯熄灭。</p>
</blockquote>
</li>
<li><p>定时器（AlarmManager）。</p>
</li>
</ol>
<h5 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a><strong>其他</strong></h5><p>我们用的多是GPS定位、Sensor遥感，只有当我们需要的时候才去打开这些硬件资源，并且及时释放，就能做到电量使用最优了。</p>
<p>接下来介绍一下AS对手机电量监控的工具，具体打开方式：AS -&gt; Profiler -&gt; Energy</p>
<p><img src="https://rq527-1310352304.cos.ap-chongqing.myqcloud.com/20220713002246.png" srcset="/img/loading.gif" lazyload></p>
<p>其实跟之前看CPU和内存差不多，鼠标放上去能看到CPU、Network、Location的耗电程度，大致分为None、Light（轻）、Medium（中）、Heavy（严重）</p>
<p>当然，还有个更好的检测软件，叫Battery Historian，这里就不演示了，可自行上网查询。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对性能优化的学习，我发现他涉及的知识是方方面面的，像AMS、PMS、WMS、hook、启动流程等等等等，所以我觉得要真正做到性能优化，对这些一定要很了解的，不然完全不知道从哪下手。同时，这篇文章肯定还存在不足，可能也有错误，如果大家发现了都可以提出来。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Android/">#Android</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Android性能优化</div>
      <div>http://example.com/2022/08/11/Android性能优化/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>August 11, 2022</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/27/Retrofit&amp;RxJava/" title="Android网络请求">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android网络请求</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/08/%E8%87%AA%E5%AE%9A%E4%B9%89View/" title="View相关">
                        <span class="hidden-mobile">View相关</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
