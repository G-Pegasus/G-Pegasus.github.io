

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="自定义View与动画一、自定义View1、为什么要自定义？ 一句话：官方的控件满足不了产品想要的效果 ( 但其实，官方控件已经能满足绝大多数需求了，正常情况下自定义 View 是下下策，因为造自定义 View 的轮子是一件很耗时也很耗精力的事。 这里分享一下我大一暑假时遇到的事情，当时共 5 个组分开做积分商城，产品给了一个积分商城的设计图，其中主页有一个上滑展开的需求，我们组（我和钟智），我就负">
<meta property="og:type" content="article">
<meta property="og:title" content="View相关">
<meta property="og:url" content="http://example.com/2022/08/08/%E8%87%AA%E5%AE%9A%E4%B9%89View/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="自定义View与动画一、自定义View1、为什么要自定义？ 一句话：官方的控件满足不了产品想要的效果 ( 但其实，官方控件已经能满足绝大多数需求了，正常情况下自定义 View 是下下策，因为造自定义 View 的轮子是一件很耗时也很耗精力的事。 这里分享一下我大一暑假时遇到的事情，当时共 5 个组分开做积分商城，产品给了一个积分商城的设计图，其中主页有一个上滑展开的需求，我们组（我和钟智），我就负">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320161207313.png">
<meta property="og:image" content="c:/Users/%E9%83%AD%E7%A5%A5%E7%91%9E/AppData/Roaming/Typora/typora-user-images/image-20220320144121673.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320144833039.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320144833039.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320163052101.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320164459116.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320164844556.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320165148269.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320195658810.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321194906364.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321225743926.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321230004519.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321230432739.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321230936516.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321231555746.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321231735164.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321232502431.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321233030377.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321233713916.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321234733578.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321234928364.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321235408579.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321235709470.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000124439.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000411111.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000630000.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000826091.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000941813.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322001506870.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322002054498.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322002252433.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322002424079.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322003418726.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321230936516.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322180055610.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326185016280.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322180533094.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322180809792.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322190910124.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322191150701.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322191527878.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323223301814.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323224318637.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323230405944.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323230713647.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323231300755.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323234144858.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323234305639.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325141248013.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325141438062.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325133455931.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325133728477.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325134213260.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325135853586.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325135808864.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326231305660.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326231921252.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326234300251.png">
<meta property="og:image" content="d:/Typora/img/image-20220326234410761.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326234634838.png">
<meta property="og:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325155039418.png">
<meta property="article:published_time" content="2022-08-08T06:44:33.000Z">
<meta property="article:modified_time" content="2022-10-20T01:03:09.479Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320161207313.png">
  
  
  
  <title>View相关 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="View相关"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-08 14:44" pubdate>
          August 8, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          65k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          545 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">View相关</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="自定义View与动画"><a href="#自定义View与动画" class="headerlink" title="自定义View与动画"></a>自定义View与动画</h1><h2 id="一、自定义View"><a href="#一、自定义View" class="headerlink" title="一、自定义View"></a>一、自定义View</h2><h3 id="1、为什么要自定义？"><a href="#1、为什么要自定义？" class="headerlink" title="1、为什么要自定义？"></a>1、为什么要自定义？</h3><blockquote>
<p>一句话：官方的控件满足不了产品想要的效果 (</p>
<p>但其实，官方控件已经能满足绝大多数需求了，正常情况下自定义 View 是下下策，因为造自定义 View 的轮子是一件很耗时也很耗精力的事。</p>
<p>这里分享一下我大一暑假时遇到的事情，当时共 5 个组分开做积分商城，产品给了一个积分商城的设计图，其中主页有一个上滑展开的需求，我们组（我和钟智），我就负责做这个上滑的界面。当时我花了好像 3、4 天的时间去设计一个自定义 View（原谅我当时还不知道协调者布局这个东西），结果啊，产品改需求了，靠</p>
<p>经过上面的这个故事后，相信大家应该理解到了选择自定义 View 会面临的风险</p>
<p>后来我又花了接近一周的时间还是用自定义 View 写出了产品的新需求，限于当时我的能力，现在去看当时写的代码，存在一些耦合的地方，算是给以后学弟留坑了😁</p>
<p>OK，回到这里，自定义 View 确实是下下策，不止会影响你的心情，如果你的代码设计得不好的话（比如耦合度很高，代码逻辑混乱），还会影响以后维护代码人的心情。（说个笑话：听说代码写得越烂，越不容易被辞退 :）</p>
</blockquote>
<h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><blockquote>
<p>这里自定义 View 是一个习惯性的统称</p>
<p>如果按照类型来分：</p>
<ul>
<li><p>自定义 View</p>
<blockquote>
<p>指直接或间接继承于 View 的控件，如：TextView、Button</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">View</span> &#123;&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TextView</span> &#123;&#125;<br></code></pre></td></tr></table></figure>


</blockquote>
</li>
<li><p>自定义 ViewGroup</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ViewGroup</span> &#123;&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FrameLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ViewGroup</span> &#123;&#125;<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>如果按照学习的内容来分，大致分为以下内容</p>
<ul>
<li><p>View 的测量与布局</p>
<blockquote>
<p>测量就是与 Measure 相关的方法，如：<code>onMeasure()</code></p>
<p>布局就是与 Layout 相关的方法，如：<code>onLayout()</code></p>
<p>这两个一般是在一起调用的，并且通常是在 自定义 ViewGroup 中才会涉及到（View 中也可以实现，比如 TextView 就重写了 <code>onLayout()</code> 方法）</p>
</blockquote>
</li>
<li><p>View 的绘制</p>
<blockquote>
<p>绘制就是与 Draw 相关的方法，如：<code>onDraw()</code></p>
<p>为什么要列出绘制？</p>
<p>因为很多动画都是依靠重写绘制来实现的，所以绘制也比较重要</p>
</blockquote>
</li>
<li><p>事件分发</p>
<blockquote>
<p>一般指触摸事件的分发</p>
<p>这个应该是自定义 View 中最难也最重要的内容了，如果你想设计出一些很炫酷的界面，就得精通事件分发</p>
<p>事件分发会在下下节课讲解</p>
</blockquote>
</li>
</ul>
<p>接下来就是正式开始讲解自定义 View 的时间，由于时间原因，在加上你们的现阶段能力的原因，本节课更偏向于讲解如何使用自定义 View，而不是讲解底层内容，底层内容以博客的形式分享</p>
</blockquote>
<h3 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h3><blockquote>
<p>该部分内容参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/angeldevil/p/3479431.html#three">https://www.cnblogs.com/angeldevil/p/3479431.html#three</a></p>
<p>View 一共有四个构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span> &#123;<br><span class="hljs-comment">// 这个用于在代码中直接 new 一个 View，这个 context 一般都是 activity，代表上下文</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(Context context)</span><br><br><span class="hljs-comment">// 这个用于在 xml 中书写，系统自动将你写在 xml 中的属性装换为一个 AttributeSet 对象，然后调用这个函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">Context context, </span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> AttributeSet attrs</span><br><span class="hljs-params">)</span><br><br><span class="hljs-comment">// 这个一般用于设置默认属性，使用的情况较少</span><br><span class="hljs-comment">// 系统不会主动调用，一般是开发者自己设置</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">Context context, </span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> AttributeSet attrs, </span><br><span class="hljs-params"><span class="hljs-type">int</span> defStyleAttr</span><br><span class="hljs-params">)</span><br><br><span class="hljs-comment">// 这个与上面的类似，也是设置默认属性，使用的情况也较少，且只支持 Android 5.0 以上</span><br><span class="hljs-comment">// 系统不会主动调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">Context context, </span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> AttributeSet attrs, </span><br><span class="hljs-params"><span class="hljs-type">int</span> defStyleAttr, </span><br><span class="hljs-params"><span class="hljs-type">int</span> defStyleRes</span><br><span class="hljs-params">)</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>前面两个构造函数各位应该都能看懂，关键在于后面两个，他们与设置默认属性相关，在讲解前我们先得知道一个 View 可以通过哪些方式设置属性</p>
</blockquote>
<h4 id="1、直接写在-XML-中"><a href="#1、直接写在-XML-中" class="headerlink" title="1、直接写在 XML 中"></a>1、直接写在 XML 中</h4><blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.cardview.widget.CardView</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:cardBackgroundColor</span>=<span class="hljs-string">&quot;@android:color/darker_gray&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:cardCornerRadius</span>=<span class="hljs-string">&quot;8dp&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>这样就会给当前 View 设置属性</p>
<p>原理是系统自动把这些属性写入到 AttributeSet 类里面，然后调用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> View(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)<br></code></pre></td></tr></table></figure>

<p>来生成 View 对象</p>
</blockquote>
<h4 id="2、使用-style-设置属性"><a href="#2、使用-style-设置属性" class="headerlink" title="2、使用 @style 设置属性"></a>2、使用 @style 设置属性</h4><blockquote>
<p>在 <code>style.xml</code> 中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myCardView_style&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cardBackgroundColor&quot;</span>&gt;</span>@android:color/darker_gray<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cardCornerRadius&quot;</span>&gt;</span>8dp<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在 <code>layout.xml</code> 中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.cardview.widget.CardView</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/myCardView_style&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>这个一般用于多个相同控件复用属性的时候</p>
<p>原理与上一个是一样的，它会把 <code>style=&quot;@style/MyCardView&quot;</code> 里写的属性一起写入 AttributeSet 类里面</p>
<blockquote>
<p>问题：如果 <code>style=&quot;@style/MyCardView&quot;</code> 与 xml 中有相同属性它会怎么处理呢？</p>
<p>经过测试后，xml 中定义的属性会覆盖 <code>style=&quot;@style/MyCardView&quot;</code> 中定义的属性</p>
</blockquote>
</blockquote>
<h4 id="3、在-theme-中设置某种控件的默认属性"><a href="#3、在-theme-中设置某种控件的默认属性" class="headerlink" title="3、在 theme 中设置某种控件的默认属性"></a>3、在 theme 中设置某种控件的默认属性</h4><blockquote>
<p>在 <code>theme.xml</code> 中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MyAppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-comment">&lt;!--下面这个 @style/MyCardView 就是前面写的 &lt;style name=&quot;MyCardView&quot;&gt;--&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cardViewStyle&quot;</span>&gt;</span>@style/myCardView_style<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这里 <code>name=&quot;cardViewStyle&quot;</code> 意思是定义 CardView 的默认属性<br>这个默认属性是如何生效的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原因在于 CardView 的构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CardView</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-meta">@NonNull</span> Context context, </span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> AttributeSet attrs</span><br><span class="hljs-params">)</span> &#123;<br><span class="hljs-built_in">this</span>(context, attrs, R.attr.cardViewStyle);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CardView</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-meta">@NonNull</span> Context context, </span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> AttributeSet attrs, </span><br><span class="hljs-params"><span class="hljs-type">int</span> defStyleAttr</span><br><span class="hljs-params">)</span> &#123;<br><span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们可以发现，两个参数的构造函数使用了 <code>this(context, attrs, R.attr.cardViewStyle)</code> 调用了三个参数的构造函数，其中他给第三个参数传入了一个值 <code>R.attr.cardViewStyle</code>，我们去扒它源码，看下这是什么东西（直接点击导包中的 <code>import androidx.cardview.R</code> 就可以跳到源码中）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;reference&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cardViewStyle&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这里可能你们会看不懂，我简单讲一下：这个 <code>format=&quot;reference&quot;</code> 代表这个属性接受的类型，而 <code>reference</code> 表示接受的类型为一个引用值，比如：<code>@style/xxx</code>、<code>@color/xxx</code>、<code>@drawable/xxx</code> 就是引用值</p>
<p>然后 <code>name=&quot;cardViewStyle&quot;</code> 代表这个属性的唯一名字</p>
<p>这个 attr 的引用就是 CardView 可以在 theme 中设置默认属性的原因，因为系统调用 CardView 两个参数的构造函数，然后它这个构造函数主动调用了三个参数的构造函数，并且传入了 <code>R.attr.cardViewStyle</code>，所以构造函数的第三个参数对应的是一个<code>style</code> 格式的引用，但需要你自己在 View 中指定名字</p>
<p>引用 <code>theme.xml</code> 有以下几种方式：</p>
<ul>
<li><p>全局引用，所有 View 都会使用该配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/MyAppTheme&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>某个 Activity 引用，当前 Activity 内使用该配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.section3.test.TestActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/MyAppTheme&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>某个 Activity 使用代码引用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setTheme(R.style.MyAppTheme)<br>    setContentView(R.layout.layout_card0)<br>&#125;<br><span class="hljs-comment">// 注意在 Activity 中使用必须在 setContentView 之前</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>单个 View 使用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.cardview.widget.CardView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/MyAppTheme&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>看到这里你可能有点晕，我们简单梳理一下流程：</p>
<pre><code class=" mermaid">graph TB
id1(&quot;系统读取你写的 xml&quot;)--&gt;id2
id2[&quot;生成 AttributeSet，然后调用两个参数的构造函数&quot;]--&gt;id3
id3[&quot;两个参数的调用三个参数的，并传入 R.attr.cardViewStyle&quot;]--&gt;id4
id4[&quot;View 开始从 theme 中读取属性&quot;]--&gt;id5
id5[&quot;View 在 theme 中发现 name=cardViewStyle&gt;xxxx&lt; 的定义&quot;]--&gt;id6
id6(&quot;读取 @style/MyCardView 里面的属性&quot;)
</code></pre>


</blockquote>
<h4 id="4、调用构造函数的-defStyleRes"><a href="#4、调用构造函数的-defStyleRes" class="headerlink" title="4、调用构造函数的 defStyleRes"></a>4、调用构造函数的 defStyleRes</h4><blockquote>
<p>由于 CardView 没有重写第四个构造函数（可能是为了兼容 Android 5.0 以下？），所以这里我用 FrameLayout 来演示</p>
<p>先在 <code>style.xml</code> 中定义属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myFrameLayout&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_width&quot;</span>&gt;</span>match_parent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:layout_height&quot;</span>&gt;</span>match_parent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:background&quot;</span>&gt;</span>@android:color/black<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后在代码中这样使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> frameLayout = FrameLayout(<span class="hljs-keyword">this</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, R.style.myFrameLayout_style)<br></code></pre></td></tr></table></figure>

<p>当你不能在 xml 中申明，只能在代码中动态生成时，就可以使用这种写法，有个优点就是使用 <code>style.xml</code> 可以进行属性的复用，但一般都用不到复用，这时候就可以使用 LayoutParams 和调用对应方法来代替：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> frameLayout = FrameLayout(<span class="hljs-keyword">this</span>)<br><span class="hljs-comment">// Android 第一节课我们讲过，父布局可以给子布局设置属性</span><br><span class="hljs-comment">// 且属性都以 layout_ 开头，所以 layout_width 和 layout_height </span><br><span class="hljs-comment">// 对应由 LayoutParams 来设置</span><br>frameLayout.layoutParams = ViewGroup.LayoutParams(<br> ViewGroup.LayoutParams.MATCH_PARENT,<br> ViewGroup.LayoutParams.MATCH_PARENT<br>)<br><span class="hljs-comment">// background 属于 View 自身属性，所以对应 View 自身方法</span><br>frameLayout.setBackgroundColor(Color.BLACK)<br><br><span class="hljs-comment">// 但这样写有一个缺点就是：LayoutParams 这东西只能设置少量的属性，</span><br><span class="hljs-comment">// 而且 LayoutParams 有很多个，具体选择那个需要看你的 View 被添加到</span><br><span class="hljs-comment">// 哪种父布局里，如果是 LinearLayout，就是 LinearLayout.LayoutParams(...)</span><br></code></pre></td></tr></table></figure>

<p>可能有人不知道 LayoutParams 是什么东西，你暂时可以把它看成是用来保存 View 中有关<strong>父布局属性</strong>的一个数据类，供父布局使用，后面会再次讲解</p>
<p>除了上面这种动态生成时传入默认属性，你也可以在构造器中设置你的自定义 View 的默认属性：</p>
<p>一般是这样定义构造器的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 由于 java 是基础，我先用 java 来定义构造器，后面再使用 kt 来优化写法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Section3View</span> <span class="hljs-title">extends</span> <span class="hljs-title">View</span> &#123;<br> <span class="hljs-keyword">public</span> Section3View(Context context) &#123;<br>     <span class="hljs-comment">// 注意这里调用的是 this，而不是 super</span><br>     <span class="hljs-keyword">this</span>(context, <span class="hljs-literal">null</span>);<br> &#125;<br><br> <span class="hljs-keyword">public</span> Section3View(<br>     Context context, <br>     <span class="hljs-meta">@Nullable</span> AttributeSet attrs<br> ) &#123;<br>     <span class="hljs-comment">// 注意这里调用的是 this，而不是 super</span><br>     <span class="hljs-keyword">this</span>(context, attrs, R.attr.mySection3View_attrs);<br> &#125;<br><br> <span class="hljs-keyword">public</span> Section3View(<br>     Context context, <br>     <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <br>     int defStyleAttr<br> ) &#123;<br>     <span class="hljs-comment">// 注意这里调用的是 this，而不是 super</span><br>     <span class="hljs-comment">// 这里就是设置默认属性</span><br>     <span class="hljs-keyword">this</span>(<br>         context, <br>         attrs, <br>         defStyleAttr, <br>         R.style.mySection3View_defaultAttrs<br>     );<br> &#125;<br><br> <span class="hljs-keyword">public</span> Section3View(<br>     Context context, <br>     <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <br>     int defStyleAttr, <br>     int defStyleRes<br> ) &#123;<br>     <span class="hljs-comment">// 直到这里才调用 super</span><br>     <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中 <code>R.attr.mySection3View_attrs</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--value/attrs.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mySection3View_attrs&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;reference&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>其中 <code>R.style.mySection3View_defaultAttrs</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--value/style.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mySection3View_defaultAttrs&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:background&quot;</span>&gt;</span>@android:color/black<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>如果你去对照官方控件的写法，你会发现他们的构造函数也是这样写的，前三个都是调用 <code>this()</code>，只有最后一个调用   <code>super()</code>，但他们一般只设置了 <code>R.attr.mySection3View_attrs</code>，用于开发者在 theme 中定义全局属性（[第三点](#3、在 theme 中设置某种控件的默认属性)），而 <code>R.style.mySection3View_defaultAttrs</code> 在官网控件中一般没设置，都是写个 0，代表没得默认属性</p>
<blockquote>
<p>为什么有两个默认属性？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">Context context, </span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> AttributeSet attrs, </span><br><span class="hljs-params"><span class="hljs-type">int</span> defStyleAttr, </span><br><span class="hljs-params"><span class="hljs-type">int</span> defStyleRes</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>

<p>你会发现第三个参数 <code>defStyleAttr</code> 和第四个 <code>defStyleRes</code> 都是设置默认参数，但为什么要同时存在两个呢？</p>
<p>原因：<code>defStyleAttr</code> 是从 theme 中读取默认值，但如果我们只能动态生成 View，又需要多次用到一些属性，在 Android 5.0 之前要么每次都手动调用方法来设置，要么写在 theme 中，但这样未免麻烦了些，在 Android 5.0 后增加了这个 <code>defStyleRes</code> 参数，就可以直接把属性写在 <code>style.xml</code> 中，方便复用</p>
<p><strong>但这里有很重要的一点：</strong>使用 <code>defStyleRes</code> 时不能设置 <code>defStyleAttr</code>，给 <code>defStyleAttr</code> 填入 0 或者 theme 中不设置对应的属性即可</p>
</blockquote>
<p>回到这里，前面 java 的写法确实感觉有些臃肿了，我们来看看 kt 的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 必须添加 @JvmOverloads，不然 java 层无法使用该构造器</span><br><span class="hljs-comment">// 会导致 xml 中的 View 无法生成</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Section3ViewKt</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context,<br>    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = R.attr.mySection3View_attrs,<br>    defStyleRes: <span class="hljs-built_in">Int</span> = R.style.mySection3View_defaultAttrs<br>) : View(context, attrs, defStyleAttr, defStyleRes) &#123;<br>&#125;<br><span class="hljs-comment">// 如果你没得 R.attr.mySection3View 或 R.style.MySection3View_defaultAttrs</span><br><span class="hljs-comment">// 可以直接赋值为 0，就是没得默认属性设置</span><br></code></pre></td></tr></table></figure>

<p><strong>讲到这里，构造函数中的四个参数各位应该知道有什么作用了，这里我们总结一下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(Context context)</span><br><span class="hljs-comment">// 用于在代码中动态生成自定义 View</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">    Context context, </span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> AttributeSet attrs</span><br><span class="hljs-params">)</span><br><span class="hljs-comment">// 用于写在 xml 里面系统调用</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">    Context context,</span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> AttributeSet attrs, </span><br><span class="hljs-params">    <span class="hljs-type">int</span> defStyleAttr</span><br><span class="hljs-params">)</span><br><span class="hljs-comment">// 用于设置全局默认属性值，通常是通过上面两个参数的构造函数来间接调用</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">View</span><span class="hljs-params">(</span><br><span class="hljs-params">    Context context, </span><br><span class="hljs-params">    <span class="hljs-meta">@Nullable</span> AttributeSet attrs, </span><br><span class="hljs-params">    <span class="hljs-type">int</span> defStyleAttr, </span><br><span class="hljs-params">    <span class="hljs-type">int</span> defStyleRes</span><br><span class="hljs-params">)</span><br><span class="hljs-comment">// 也是用于设置默认属性值，只是不用写在 theme 中，通常用于动态生成代码中或自己自定义 View 的时候</span><br></code></pre></td></tr></table></figure>

<p>前面讲了 4 种方式来设置属性，还有一种方式也可以来设置属性</p>
</blockquote>
<h4 id="5、直接在-theme-中定义属性"><a href="#5、直接在-theme-中定义属性" class="headerlink" title="5、直接在 theme 中定义属性"></a>5、直接在 theme 中定义属性</h4><blockquote>
<p>这个与第三点：[在 theme 中设置某种控件的默认属性](#3、在 theme 中设置某种控件的默认属性) 有些类似，但它值允许直接写在 theme 中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span> <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Theme.CustomViewWithAnimStudy&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--如果你加了这行代码，你会发现应用大部分控件变成黑色了--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;android:background&quot;</span>&gt;</span>@android:color/black<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>但是，</strong>这个是不分控件的给全部 View 设置属性，一般不会使用到它，只有设置整个应用的主题时会用到</p>
<p>比如你可以试试把这几个属性改一下，就会发现应用的标题栏颜色从紫色改成了你设置的颜色</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/purple_500<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryVariant&quot;</span>&gt;</span>@color/purple_700<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorOnPrimary&quot;</span>&gt;</span>@color/white<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorSecondary&quot;</span>&gt;</span>@color/teal_200<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorSecondaryVariant&quot;</span>&gt;</span>@color/teal_700<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorOnSecondary&quot;</span>&gt;</span>@color/black<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这些属性对应了某种具体位置的颜色，可以看看这篇博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/smartzzg/article/details/104788412">https://blog.csdn.net/smartzzg/article/details/104788412</a></p>
<h3 id="五种属性定义方法的顺序"><a href="#五种属性定义方法的顺序" class="headerlink" title="五种属性定义方法的顺序"></a>五种属性定义方法的顺序</h3><blockquote>
<p>我们讲了有 5 种不同的属性定义，如果定义了相同属性，他们存在一个优先级顺序：</p>
<p>[1、直接写在 XML 中](#1、直接写在 XML 中)</p>
<p>[2、使用 @style 设置属性](#2、使用 @style 设置属性)</p>
<p>[3、在 theme 中设置某种控件的默认属性](#3、在 theme 中设置某种控件的默认属性)</p>
<p>[4、调用构造函数的 defStyleRes](#4、调用构造函数的 defStyleRes)</p>
<p>[5、直接在 theme 中定义属性](#5、直接在 theme 中定义属性)</p>
<p>这里注意：使用 <code>defStyleRes </code> 时不能设置 <code>defStyleAttr</code>，给 <code>defStyleAttr</code> 填入 0 或者 theme 中不设置对应的属性即可</p>
</blockquote>
<p><strong>到这里 View 的四个构造函数基本分析完毕了，接下来我们开始讲解里面的方法</strong></p>
</blockquote>
<h3 id="4、onDraw"><a href="#4、onDraw" class="headerlink" title="4、onDraw()"></a>4、onDraw()</h3><blockquote>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对 View 进行绘制</p>
<h3 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h3><ul>
<li>[Canvas 画布](#1、Canvas 画布)</li>
<li>[Paint 画笔](#2、Paint 画笔)</li>
<li>[Path 路径](#3、Path 路径)</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 该方法是一个回调，为什么是回调，在之后的 invalidate() 会进行讲解</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br><span class="hljs-keyword">super</span>.onDraw(canvas)<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里讲一个小技巧：可以把 <code>Canvas?</code> 中的 <code>?</code> 为去掉</p>
<p>因为在 kt 重写 <code>onDraw()</code> 方法时，源代码 java 层中并没有给参数 <code>canvas</code> 加上 <code>@NonNull</code>，导致 kt 不知道它会不会为空，但我们作为开发者肯定是知道它不会为空的，所以去掉 <code>?</code>，可以减少后续的判断，不然很可能写出这样的代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onDraw(canvas)<br>    canvas?.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>    canvas?.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>    canvas?.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>    canvas?.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>    canvas?.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>    canvas?.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看着好像没得什么问题，不就多打了一个 <code>?</code> 吗？</p>
<p>确实看着没有什么问题，但你把 kt 转成 java，你就会发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Canvas canvas)</span> &#123;<br>   <span class="hljs-built_in">super</span>.onDraw(canvas);<br>   <span class="hljs-keyword">if</span> (canvas != <span class="hljs-literal">null</span>) &#123;<br>      canvas.drawRect(<span class="hljs-number">0.0F</span>, <span class="hljs-number">0.0F</span>, <span class="hljs-number">100.0F</span>, <span class="hljs-number">200.0F</span>, <span class="hljs-built_in">this</span>.mBlackPaint);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (canvas != <span class="hljs-literal">null</span>) &#123;<br>      canvas.drawRect(<span class="hljs-number">0.0F</span>, <span class="hljs-number">0.0F</span>, <span class="hljs-number">100.0F</span>, <span class="hljs-number">200.0F</span>, <span class="hljs-built_in">this</span>.mBlackPaint);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (canvas != <span class="hljs-literal">null</span>) &#123;<br>      canvas.drawRect(<span class="hljs-number">0.0F</span>, <span class="hljs-number">0.0F</span>, <span class="hljs-number">100.0F</span>, <span class="hljs-number">200.0F</span>, <span class="hljs-built_in">this</span>.mBlackPaint);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (canvas != <span class="hljs-literal">null</span>) &#123;<br>      canvas.drawRect(<span class="hljs-number">0.0F</span>, <span class="hljs-number">0.0F</span>, <span class="hljs-number">100.0F</span>, <span class="hljs-number">200.0F</span>, <span class="hljs-built_in">this</span>.mBlackPaint);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (canvas != <span class="hljs-literal">null</span>) &#123;<br>      canvas.drawRect(<span class="hljs-number">0.0F</span>, <span class="hljs-number">0.0F</span>, <span class="hljs-number">100.0F</span>, <span class="hljs-number">200.0F</span>, <span class="hljs-built_in">this</span>.mBlackPaint);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (canvas != <span class="hljs-literal">null</span>) &#123;<br>      canvas.drawRect(<span class="hljs-number">0.0F</span>, <span class="hljs-number">0.0F</span>, <span class="hljs-number">100.0F</span>, <span class="hljs-number">200.0F</span>, <span class="hljs-built_in">this</span>.mBlackPaint);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>每个 canvas 都单独判断了一遍是否为空，不知道你们怎么想，但我的强迫症不允许出现这种情况，所以建议各位写自定义 View 时，把方法参数中可以去掉 <code>?</code> 的顺手给去掉</p>
<p>除了 <code>onDraw()</code> 以外，还有 <code>override fun onTouchEvent(event: MotionEvent?)</code> 的 <code>?</code> 也可以去掉</p>
<blockquote>
<p>怎么看 kt 转成的 java 代码？</p>
 <img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320161207313.png" srcset="/img/loading.gif" lazyload alt="image-20220320161207313" style="zoom:50%;" />

 <img src="C:/Users/%E9%83%AD%E7%A5%A5%E7%91%9E/AppData/Roaming/Typora/typora-user-images/image-20220320144121673.png" srcset="/img/loading.gif" lazyload alt="image-20220320144121673" style="zoom:50%;" />
</blockquote>
<p>接下来我们开始讲解 <code>onDraw()</code> 需要的其他知识</p>
</blockquote>
</blockquote>
<h4 id="1、Canvas-画布"><a href="#1、Canvas-画布" class="headerlink" title="1、Canvas 画布"></a>1、Canvas 画布</h4><blockquote>
<p>由于时间原因，这里不会讲得很详细，你们可以在这些地方进行学习：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://carsonho.blog.csdn.net/article/details/60598775">https://carsonho.blog.csdn.net/article/details/60598775</a></li>
<li><a target="_blank" rel="noopener" href="https://qijian.blog.csdn.net/article/details/50995268">https://qijian.blog.csdn.net/article/details/50995268</a></li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>canvas</strong></em></td>
<td>Canvas</td>
<td>字面翻译是“帆布”，你可以看成是系统底层给了你一张“画布”（canvas），然后你在这张画布上进行绘图</td>
</tr>
</tbody></table>
<p>那怎么进行画图呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这个 paint 你可以把它看成是“画笔”</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mBlackPaint = Paint().apply &#123;<br>color = Color.BLACK <span class="hljs-comment">// 设置画笔颜色为黑色</span><br>&#125;<br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br><span class="hljs-keyword">super</span>.onDraw(canvas)<br><span class="hljs-comment">// 画一个 (0, 0) - (100, 200) 的黑色矩形</span><br>canvas.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上面代码，调用 <code>canvas.drawRect()</code> 就可以画一个黑色矩形在 View 里面</p>
<p>接下来，我们看一下效果：</p>
<img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320144833039.png" srcset="/img/loading.gif" lazyload alt="image-20220320144833039" style="zoom:50%;float:left" />

<p>如果你没有自定义 View 基础的话，可能会觉得有些奇怪</p>
<p>我们从小学开始学的坐标系第一象限不是向上为 Y 正半轴，向右为 X 正半轴，那么按照惯性思维，(0, 0) - (100, 200) 为什么不是下图这样的？</p>
<img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320144833039.png" srcset="/img/loading.gif" lazyload alt="image-20220320144833039" style="zoom:50%;transform:rotateX(180deg);float:left" />

<p>其实原因在于 View 中坐标系的 y 轴是反过来的，我猜测是因为：为了设配手机的特点，比如我们看一些列表，都是手指往上滑动，查看下面的内容，所以为了好开发，View 中的坐标原点就设置在了左上角，向下为 Y 正半轴，向右为 X 正半轴</p>
<p>这个算是基础内容了，如果不知道的话，可以去看看这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/56009827">https://blog.csdn.net/carson_ho/article/details/56009827</a></p>
<p>Canvas 里面不止有绘制矩形的方法，还有绘制圆的方法，绘制文字的方法······，这里不会去讲解这些基础内容，可以去下面这些地方去查看：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/graphics/Canvas?hl=en">https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/graphics/Canvas?hl=en</a></li>
</ul>
</blockquote>
<h4 id="2、Paint-画笔"><a href="#2、Paint-画笔" class="headerlink" title="2、Paint 画笔"></a>2、Paint 画笔</h4><blockquote>
<p>前面的代码演示中出现了 <code>Paint</code>，这个类主要是管画笔的，除了设置颜色以外，他还可以设置线的粗细等</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这是我的某个自定义 View 设置的 Paint</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mCircleBackgroundPaint <span class="hljs-keyword">by</span> lazyUnlock &#123;<br>    Paint().apply &#123;<br>        color = mCircleBackground<br>        style = Paint.Style.FILL<br>        isAntiAlias = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Paint 的方法有很多，这里给出文章，你们有时间可以去看看，那本自定义黑书对于 Paint 的内容有点少，建议去看书作者写的文章，里面有很多其他高级用法</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://qijian.blog.csdn.net/article/details/50995268">https://qijian.blog.csdn.net/article/details/50995268</a></li>
</ul>
</blockquote>
<h4 id="3、Path-路径"><a href="#3、Path-路径" class="headerlink" title="3、Path 路径"></a>3、Path 路径</h4><blockquote>
<p>Path 表示路径，常用于绘制曲线，绘制不规则的图形等</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这是我的某个自定义 View 设置的 Path</span><br><span class="hljs-comment">// 主要是写了根据变化的 offset 值来计算圆的半径，最后绘制一个圆</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">drawFirstCircle</span><span class="hljs-params">(path: <span class="hljs-type">Path</span>, offset: <span class="hljs-type">Float</span>, total: <span class="hljs-type">Float</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> radio = abs(offset / total)<br>    <span class="hljs-keyword">val</span> startMove = <span class="hljs-number">0.6F</span><br>    <span class="hljs-keyword">val</span> k = <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> - startMove)<br>    <span class="hljs-keyword">val</span> b = <span class="hljs-number">1</span> - k<br>    <span class="hljs-keyword">val</span> y = offset / abs(offset) * max(<span class="hljs-number">0F</span>, k * radio + b) * total<br>    <span class="hljs-keyword">val</span> r = getNewRadius(y)<br>    <span class="hljs-keyword">val</span> dx = (outerX - abs(y)) / (outerR + r) * r<br>    <span class="hljs-keyword">val</span> dy = outerY / (outerR + r) * r<br>    firstPointX = <span class="hljs-keyword">if</span> (offset &gt; <span class="hljs-number">0</span>) dx + y <span class="hljs-keyword">else</span> -dx + y<br>    firstPointY = dy<br>    path.addCircle(y, <span class="hljs-number">0F</span>, r, Path.Direction.CCW)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法有很多，这里不进行讲解，给出下面文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/graphics/Path?hl=en">https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/graphics/Path?hl=en</a></li>
<li><a target="_blank" rel="noopener" href="https://carsonho.blog.csdn.net/article/details/60597923">https://carsonho.blog.csdn.net/article/details/60597923</a></li>
<li><a target="_blank" rel="noopener" href="https://qijian.blog.csdn.net/article/details/50995268">https://qijian.blog.csdn.net/article/details/50995268</a></li>
</ul>
</blockquote>
<h4 id="4、其他东西"><a href="#4、其他东西" class="headerlink" title="4、其他东西"></a>4、其他东西</h4><blockquote>
<p>上面并没有列完基础知识，因为基础知识实在是太多了，这里是写不下的，接下来我讲一些其他经验性的东西</p>
</blockquote>
<h5 id="1、onDraw-里面禁止-new-对象"><a href="#1、onDraw-里面禁止-new-对象" class="headerlink" title="1、onDraw() 里面禁止 new 对象"></a>1、onDraw() 里面禁止 new 对象</h5><blockquote>
<p>很多初学者在刚开始写的时候很喜欢在 <code>onDraw()</code> 里面 new 对象，之前 <code>canvas.drawRect()</code> 不是要传入一个画笔吗？就会有人这样写</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br> <span class="hljs-keyword">super</span>.onDraw(canvas)<br> <span class="hljs-keyword">val</span> blackPaint = Paint()<br> blackPaint.color = Color.BLACK<br> canvas.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, blackPaint)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样写时 AS 还会报一个黄，告诉你这样写是不对的，但你知道为什么不对吗？</p>
<p>原因：<code>onDraw()</code> 在一直刷新视图时，在 60 帧的手机上会每隔 16 毫秒回调一次，90 帧的手机上每隔 11 毫秒回调一次（1000 ÷ 90），所以在一秒钟，60 帧的手机会生成 60 个 Paint 对象，90 帧手机生成 90 个对象，这样疯狂 new 对象，会让手机出现卡顿，这跟上节课讲的 <code>onBindViewHolder()</code> 不要写点击监听一样，但这个会比它更严重</p>
<p>但 AS 的智能提示并不是能发现所有的问题，比如下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br> <span class="hljs-keyword">super</span>.onDraw(canvas)<br> <span class="hljs-keyword">set</span> &#123; <br>     <span class="hljs-comment">// ...</span><br> &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">set</span><span class="hljs-params">(func: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br> func.invoke()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种情况较难发现，这样写每次都会生成一个匿名内部类，建议加上 <code>inline</code> 关键字</p>
<p><strong>该禁令同样适用于 <code>onMeasure()</code>、<code>onLayout()</code>！</strong></p>
</blockquote>
<h5 id="2、不要在-onDraw-里面进行耗时操作"><a href="#2、不要在-onDraw-里面进行耗时操作" class="headerlink" title="2、不要在 onDraw() 里面进行耗时操作"></a>2、不要在 onDraw() 里面进行耗时操作</h5><blockquote>
<p>原因跟上面一样</p>
<p><strong>该禁令同样适用于 <code>onMeasure()</code>、<code>onLayout()</code>！</strong></p>
</blockquote>
<h5 id="3、不要持有-canvas-对象"><a href="#3、不要持有-canvas-对象" class="headerlink" title="3、不要持有 canvas 对象"></a>3、不要持有 canvas 对象</h5><blockquote>
<p>每次回调的 canvas 对象并不是一定是同一个（大部分情况下是同一个），而且每次的回调只能表示当前帧的状态，比如我们来个违规操作：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br> <span class="hljs-keyword">super</span>.onDraw(canvas)<br> <span class="hljs-comment">// 开一个线程模拟持有 canvas 对象</span><br> thread &#123;<br>     <span class="hljs-comment">// 延迟 20 毫秒才绘图</span><br>     sleep(<span class="hljs-number">20</span>)<br>     canvas.drawRect(<span class="hljs-number">0F</span>, <span class="hljs-number">0F</span>, <span class="hljs-number">100F</span>, <span class="hljs-number">200F</span>, mBlackPaint)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>你可能猜都猜不到它把图绘制到哪里去了</p>
<img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320163052101.png" srcset="/img/loading.gif" lazyload alt="image-20220320163052101" style="zoom:50%;float:left" />

<p>好家伙，它竟然把图绘制到标题栏上了，这里猜测原因如下（没有去查看源码找真正原因）：</p>
<ul>
<li>整个应用共用了同一个 canvas 对象</li>
<li>因开启线程后 sleep，所以 canvas 是整个应用绘制完成后再调用的 <code>canvas.drawRect()</code></li>
<li><strong>标题栏是在最后进行绘制的</strong>，此时的 canvas 的坐标系是以标题栏为准的</li>
</ul>
<p>这怎么验证呢？</p>
<blockquote>
<p>你把开发者模式模式的 <code>显示布局边界</code> 给打开，你会看到下面这种图：</p>
<img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320164459116.png" srcset="/img/loading.gif" lazyload alt="image-20220320164459116" style="zoom: 67%;float:left" />

<p>这里说明标题栏的文字是一个 View 来显示的</p>
<p>那我们试试把标题栏给去掉会发生什么？</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--theme.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320164844556.png" srcset="/img/loading.gif" lazyload alt="image-20220320164844556" style="zoom: 67%;float:left" />

<p>嘿，去掉标题栏后绘制的位置对了，所以这里我提出猜测：标题栏是在最后进行绘制的</p>
<p>其实我们可以验证一下这个猜测，写一个在它后面绘制的 View 验证下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.ndhzs.lib.section4.MySection4ViewCanvas</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;300dp&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;300dp&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320165148269.png" srcset="/img/loading.gif" lazyload alt="image-20220320165148269" style="zoom: 67%;float:left" />

<p>果然，我的猜测应该是合理的</p>
</blockquote>
</blockquote>
<h5 id="4、自定义-View-和-ViewGroup-在绘制中的不同"><a href="#4、自定义-View-和-ViewGroup-在绘制中的不同" class="headerlink" title="4、自定义 View 和 ViewGroup 在绘制中的不同"></a>4、自定义 View 和 ViewGroup 在绘制中的不同</h5><blockquote>
<p>在自定义 ViewGroup 中，一般不会重写 <code>onDraw()</code>，因为 ViewGroup 对 <code>onDraw()</code> 进行了处理，只有在<strong>有背景图时</strong>，才会调用 <code>onDraw()</code>，所以在自定义 ViewGroup 时想绘图一般是重写 <code>dispatchDraw(Canvas canvas)</code>，这个方法也可以决定是绘制在子 View 上层还是子 View 下层，具体的你们自己去实践一下吧，这里给出文章链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/89efaf8bd3dd">https://www.jianshu.com/p/89efaf8bd3dd</a></p>
</blockquote>
<h4 id="5、onDraw-的绘制流程"><a href="#5、onDraw-的绘制流程" class="headerlink" title="5、onDraw() 的绘制流程"></a>5、onDraw() 的绘制流程</h4><blockquote>
<p>这东西属于高阶内容，限于时间关系，这里我就不讲了，可以看看这些文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/56011153">https://blog.csdn.net/carson_ho/article/details/56011153</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Idtk/Blog/blob/master/Blog/9%E3%80%81Invalidate.md">https://github.com/Idtk/Blog/blob/master/Blog/9%E3%80%81Invalidate.md</a></li>
</ul>
</blockquote>
<h3 id="5、invalidate"><a href="#5、invalidate" class="headerlink" title="5、invalidate()"></a>5、invalidate()</h3><blockquote>
<p>这东西你目前只需要记住以下几点就可以了：</p>
<ul>
<li>调用后会在<strong>下一帧回调</strong> <code>onDraw()</code> 进行刷新</li>
<li>下一帧是指下一次屏幕刷新的时候</li>
</ul>
<p>如果你想探究源码的话，我只能丢文章出来了：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7017452765672636446">https://juejin.cn/post/7017452765672636446</a></li>
</ul>
<p>OK，这个方法讲完了，因为往深了讲，会涉及到 Handler 机制、ViewRootImpl 等 Framwork 层源码</p>
<p>哦，想起了，还要一点，除了 <code>invalidate()</code> 外还有一个 <code>postInvalidate()</code> 用于在其他线程里刷新</p>
<p>但考虑到可能会有其他学长来听课，我还是画一个简单的流程图</p>
<pre><code class=" mermaid">graph TB
id1(&quot;View&quot;)--&gt;id2
id2[&quot;调用invalidate()刷新&quot;]--&gt;id3
id3&#123;&quot;parent == null&quot;&#125;--不为 null--&gt;id4
id4[&quot;告诉父布局有子布局要重绘&quot;]--&gt;id3--为 null--&gt;id5
id5[&quot;传递到了 ViewRootImpl (一个管理布局的类)&quot;]--&gt;id6
id6[&quot;ViewRootImpl 调用 mChoreographer 发送一个 post (一个专门监听屏幕刷新的类)&quot;]-.-&gt;id7
id7[&quot;屏幕刷新了，回调 ViewRootImpl，开始重新走 View 测量和绘图流程&quot;]--&gt;id8
id8(&quot;从顶部布局最后回调到 View 的 onDraw()&quot;)
</code></pre>

<p>其实还有亿点细节，这里我就不讲述了，自己看下面图，其实这图仍有许多没有画上</p>
<pre><code class=" mermaid">sequenceDiagram
View-&gt;&gt;View: invalidate()
View-&gt;&gt;ViewGroup: invalidateChild()
alt 如果是硬件加速
	ViewGroup-&gt;&gt;other ViewGroups: onDescendantInvalidated()
	other ViewGroups-&gt;&gt;DecorView: onDescendantInvalidated()
	DecorView-&gt;&gt;ViewRootImpl: onDescendantInvalidated()
	ViewRootImpl-&gt;&gt;ViewRootImpl: invalidate()
else 如果是软件加速
	ViewGroup-&gt;&gt;other ViewGroups: invalidateChildInParent()
	other ViewGroups-&gt;&gt;DecorView: invalidateChildInParent()
	DecorView-&gt;&gt;ViewRootImpl: invalidateChildInParent()
	ViewRootImpl-&gt;&gt;ViewRootImpl: invalidateRectOnScreen()
end
ViewRootImpl-&gt;&gt;ViewRootImpl: scheduleTraversals()
ViewRootImpl-&gt;&gt;Choreographer: postCallback(mTraversalRunnable)
Choreographer-&gt;&gt;Handler: sendMessage*()
Handler-&gt;&gt;Handler: 等到下一次屏幕刷新
Handler-&gt;&gt;ViewRootImpl: mTraversalRunnable.run()
ViewRootImpl-&gt;&gt;ViewRootImpl: doTraversal()
ViewRootImpl-&gt;&gt;ViewRootImpl: performTraversals()
ViewRootImpl-&gt;&gt;ViewRootImpl: performDraw()
ViewRootImpl-&gt;&gt;DecorView: draw()
DecorView-&gt;&gt;other ViewGroups: draw()
other ViewGroups-&gt;&gt;ViewGroup: draw()
ViewGroup-&gt;&gt;View: draw()
View-&gt;&gt;View: onDraw()
</code></pre>

<p>END</p>
</blockquote>
<h3 id="6、自定义属性-AttributeSet"><a href="#6、自定义属性-AttributeSet" class="headerlink" title="6、自定义属性 AttributeSet"></a>6、自定义属性 AttributeSet</h3><blockquote>
<p>前面我们提到系统会把你 xml 中写得属性装换为一个 AttributeSet 对象，那我们怎么自定义自己的属性呢？</p>
<p>首先，需要新建一个 <code>res/value/attrs.xml</code> 文件，比如我想要自定义一个圆半径的属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br> <span class="hljs-comment">&lt;!--这个 name 是 View 的类名--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MySection6View&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--这个 name 是自定义属性的名称，formate 是接受的类型--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my6_circleRadius&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>如上述代码，这里有需要注意的一点：</p>
<ul>
<li>自定义属性的名称不能与官方的重复，而且建议加上前缀，与官方的进行区分，比如我就加上了 <code>my6_</code></li>
</ul>
<p><code>formate</code> 有下面几种类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>用法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>dimension</strong></em></td>
<td>长度值</td>
<td>“1dp”、”1px”、”@dimen&#x2F;xxx”</td>
<td>这里无所谓 dp、px，系统会最终装换成 px</td>
</tr>
<tr>
<td><em><strong>reference</strong></em></td>
<td>引用值</td>
<td>“@drawable&#x2F;xxx”、”@style&#x2F;xxx”</td>
<td></td>
</tr>
<tr>
<td><em><strong>color</strong></em></td>
<td>颜色值</td>
<td>“#FFFFFFFF”、”@color&#x2F;xxx”</td>
<td></td>
</tr>
<tr>
<td><em><strong>float</strong></em></td>
<td>小数</td>
<td>“1.0”</td>
<td></td>
</tr>
<tr>
<td><em><strong>boolean</strong></em></td>
<td>布尔类型</td>
<td>“true”、”@bool&#x2F;xxx”</td>
<td></td>
</tr>
<tr>
<td><em><strong>interger</strong></em></td>
<td>整数</td>
<td>“1”、”@interget&#x2F;xxx”</td>
<td></td>
</tr>
<tr>
<td><em><strong>string</strong></em></td>
<td>字符串</td>
<td>“string”、”@string&#x2F;xxx”</td>
<td></td>
</tr>
<tr>
<td><em><strong>fraction</strong></em></td>
<td>百分数</td>
<td>“50%”、”@fraction&#x2F;xxx”</td>
<td></td>
</tr>
<tr>
<td><em><strong>enum</strong></em></td>
<td>枚举</td>
<td><a href="#enum">看下文</a></td>
<td></td>
</tr>
<tr>
<td><em><strong>flag</strong></em></td>
<td>位运算</td>
<td><a href="#flag">看下文</a></td>
<td></td>
</tr>
</tbody></table>
<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--比如我设置圆的位置属性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my6_circleGravity&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;enum&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure>

<img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220320195658810.png" srcset="/img/loading.gif" lazyload alt="image-20220320195658810" style="zoom:50%;float:left" />

<p>设置后在使用时它的属性就只能选择你填写的那几个</p>
</blockquote>
<h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><blockquote>
<p>就是进行位运算，这里我们以 FrameLayout 的 <code>layout_gravity</code> 为例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;layout_gravity&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--0011 0000--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;top&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x30&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--0101 0000--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bottom&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x50&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--0000 0011--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x03&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--0000 0101--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x05&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--0001 0000--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center_vertical&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x10&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--0000 0001--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x01&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--0001 0001--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x11&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;start&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x00800003&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">flag</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;end&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x00800005&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>你是否还记得你曾经这样使用过？</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;top|left&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里你会发现它把 <code>top|left</code> 报黄了，原因在于它推荐你使用 <code>start</code> 去代替 <code>left</code>，因为在部分国家是从右边往左边阅读文字的，所以，Android 为了国际化，就设计出了 <code>start</code> 代替 <code>left</code>，<code>end</code> 代替 <code>right</code></p>
</blockquote>
</blockquote>
<h3 id="类型的混用"><a href="#类型的混用" class="headerlink" title="类型的混用"></a>类型的混用</h3><blockquote>
<p>比如 <code>android:layout_width</code> 是这样定义的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;layout_width&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fill_parent&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;-1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;match_parent&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;-1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;-2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>还有 <code>android:background</code> 是这样定义的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;background&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;reference|color&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>所以你传入 <code>@drawable/xxx</code> 和 <code>#FFFFFFFF</code>，它都可以获取，只是填入颜色值时使用 <code>TypedValue#getDrawable()</code> 得到是 ColorDrawable</p>
<p>也支持这样混用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--这是 View 的一个属性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;focusable&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;boolean|enum&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;auto&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0x00000010&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>但这样使用只能手动去判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFocusableAttribute</span><span class="hljs-params">(TypedArray attributes)</span> &#123;<br>    <span class="hljs-type">TypedValue</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypedValue</span>();<br>    <span class="hljs-keyword">if</span> (attributes.getValue(com.android.internal.R.styleable.View_focusable, val)) &#123;<br>        <span class="hljs-keyword">if</span> (val.type == TypedValue.TYPE_INT_BOOLEAN) &#123;<br>            <span class="hljs-keyword">return</span> (val.data == <span class="hljs-number">0</span> ? NOT_FOCUSABLE : FOCUSABLE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> val.data;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> FOCUSABLE_AUTO;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>前面讲了类型的定义，那我们怎么获取这些属性呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mCircleRadius = <span class="hljs-number">100</span><br><span class="hljs-comment">// 这个 enum 属性更建议使用枚举来保存，官方通常使用的注解，但 kt 很怪，注解不起作用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mCircleGravity = <span class="hljs-number">0</span><br><span class="hljs-keyword">init</span> &#123;<br>    <span class="hljs-keyword">if</span> (attrs != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 主要就是调用下面这个方法去获取属性</span><br>        <span class="hljs-keyword">val</span> ty = context.obtainStyledAttributes(attrs, R.styleable.MySection6View)<br>        mCircleRadius = ty.getDimensionPixelSize(<br>            R.styleable.MySection6View_my6_circleRadius,<br>            mCircleRadius<br>        )<br>        mCircleGravity = ty.getInt(<br>            R.styleable.MySection6View_my6_circleGravity,<br>            mCircleGravity<br>        )<br>        ty.recycle()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里还好只有两个属性，但如果有多达上百个属性这样写未免太占行数了，所以，秉持着少写代码的原则，我使用了 kt 扩展函数来优化（下面是我写的课表自定义 View）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 先把属性的读取单独提取到一个类中</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NetLayout</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span>(<br>    context: Context,<br>    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = R.attr.netLayoutStyle,<br>    defStyleRes: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : ViewGroup(context, attrs, defStyleAttr, defStyleRes), INetLayout &#123;<br>    <span class="hljs-comment">// 属性值</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> mNetAttrs: NetLayoutAttrs = NetLayoutAttrs.newInstance(<span class="hljs-keyword">this</span>, attrs)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 我把属性单独写在了一个类里面</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NetLayoutAttrs</span>(<br>    rowCount: <span class="hljs-built_in">Int</span>,<br>    columnCount: <span class="hljs-built_in">Int</span><br>) : BaseViewAttrs &#123;<br><br>    <span class="hljs-keyword">var</span> rowCount = rowCount<br>        <span class="hljs-keyword">internal</span> <span class="hljs-keyword">set</span><br>    <span class="hljs-keyword">var</span> columnCount = columnCount<br>        <span class="hljs-keyword">internal</span> <span class="hljs-keyword">set</span><br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newInstance</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            view: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            attrs: <span class="hljs-type">AttributeSet</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">            defStyleAttr: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            defStyleRes: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>: NetLayoutAttrs &#123;<br>            <span class="hljs-keyword">return</span> newAttrs(<br>                view,<br>                attrs,<br>                R.styleable.NetLayout,<br>                defStyleAttr,<br>                defStyleRes<br>            ) &#123;<br>                <span class="hljs-comment">// 这里你就会看到直接使用 R.styleable.xxx.int() 来获取属性，这样写起来舒服多了</span><br>                NetLayoutAttrs(<br>                    R.styleable.NetLayout_net_rowCount.int(ROW_COUNT),<br>                    R.styleable.NetLayout_net_columnCount.int(COLUMN_COUNT)<br>                )<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ROW_COUNT = <span class="hljs-number">4</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> COLUMN_COUNT = <span class="hljs-number">4</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这是定义扩展函数的接口</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BaseViewAttrs</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">newAttrs</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        view: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        attrs: <span class="hljs-type">AttributeSet</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@StyleableRes</span></span></span><br><span class="hljs-params"><span class="hljs-function">        styleableId: <span class="hljs-type">IntArray</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        defStyleAttr: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        defStyleRes: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        func: <span class="hljs-type">Typedef</span>.() -&gt; <span class="hljs-type">T</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: T = BaseViewAttrs.newAttrs(view, attrs, styleableId, defStyleAttr, defStyleRes, func)<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">newAttrs</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            view: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            attrs: <span class="hljs-type">AttributeSet</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-meta">@StyleableRes</span></span></span><br><span class="hljs-params"><span class="hljs-function">            styleableId: <span class="hljs-type">IntArray</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            defStyleAttr: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            defStyleRes: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            func: <span class="hljs-type">Typedef</span>.() -&gt; <span class="hljs-type">T</span></span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>: T &#123;<br>            <span class="hljs-keyword">val</span> ty = view.context.obtainStyledAttributes(attrs, styleableId, defStyleAttr, defStyleRes)<br>            <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;<br>                <span class="hljs-comment">// 这是保存在 Debug 模式中能看到的信息，具体怎么查看，你可以去看看这个方法的源码</span><br>                view.saveAttributeDataForStyleable(<br>                    view.context, styleableId, attrs, ty, defStyleAttr, defStyleRes)<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> Typedef(ty, view.context).func()<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                ty.recycle()<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Typedef</span>(<span class="hljs-keyword">val</span> ty: TypedArray, <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> context: Context) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">int</span><span class="hljs-params">(defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.int(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">color</span><span class="hljs-params">(defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.color(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">colorById</span><span class="hljs-params">(<span class="hljs-meta">@ColorRes</span> defValueId: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.color(<br>            ContextCompat.getColor(context, defValueId))<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">dimens</span><span class="hljs-params">(defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.dimens(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">dimens</span><span class="hljs-params">(defValue: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> = <span class="hljs-keyword">this</span>.dimens(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">layoutDimens</span><span class="hljs-params">(defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.layoutDimens(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">dimensById</span><span class="hljs-params">(<span class="hljs-meta">@DimenRes</span> defValueId: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span><br>        .dimens(context.resources.getDimensionPixelSize(defValueId))<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">string</span><span class="hljs-params">(defValue: <span class="hljs-type">String</span>? = <span class="hljs-literal">null</span>)</span></span>: String = <span class="hljs-keyword">this</span>.string(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">boolean</span><span class="hljs-params">(defValue: <span class="hljs-type">Boolean</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = <span class="hljs-keyword">this</span>.boolean(ty, defValue)<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">float</span><span class="hljs-params">(defValue: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> = <span class="hljs-keyword">this</span>.float(ty, defValue)<br>        <span class="hljs-keyword">internal</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> E: RuntimeException&gt;</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">intOrThrow</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            attrsName: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">this</span>.intOrThrow&lt;E&gt;(ty, attrsName)<br>        <span class="hljs-keyword">internal</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> E: RuntimeException&gt;</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">stringOrThrow</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            attrsName: <span class="hljs-type">String</span>)</span></span>: String = <span class="hljs-keyword">this</span>.stringOrThrow&lt;E&gt;(ty, attrsName)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">int</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getInt(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">color</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getColor(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">dimens</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getDimensionPixelSize(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">dimens</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getDimension(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">layoutDimens</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getLayoutDimension(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">string</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">String</span>? = <span class="hljs-literal">null</span>)</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> ty.getString(<span class="hljs-keyword">this</span>) ?: defValue ?: <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">boolean</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Boolean</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getBoolean(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">float</span><span class="hljs-params">(ty: <span class="hljs-type">TypedArray</span>, defValue: <span class="hljs-type">Float</span>)</span></span>: <span class="hljs-built_in">Float</span> &#123;<br>    <span class="hljs-keyword">return</span> ty.getFloat(<span class="hljs-keyword">this</span>, defValue)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> E: RuntimeException&gt;</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">intOrThrow</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    ty: <span class="hljs-type">TypedArray</span>, attrsName: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">if</span> (!ty.hasValue(<span class="hljs-keyword">this</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> E::<span class="hljs-keyword">class</span>.java.getConstructor(String::<span class="hljs-keyword">class</span>.java)<br>            .newInstance(<span class="hljs-string">&quot;属性 <span class="hljs-variable">$attrsName</span> 没有被定义！&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.int(ty, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> E: java.lang.RuntimeException&gt;</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">stringOrThrow</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    ty: <span class="hljs-type">TypedArray</span>, attrsName: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: String &#123;<br>    <span class="hljs-keyword">if</span> (!ty.hasValue(<span class="hljs-keyword">this</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> E::<span class="hljs-keyword">class</span>.java.getConstructor(String::<span class="hljs-keyword">class</span>.java)<br>            .newInstance(<span class="hljs-string">&quot;属性 <span class="hljs-variable">$attrsName</span> 没有被定义！&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.string(ty)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="自定义-layout-属性"><a href="#自定义-layout-属性" class="headerlink" title="自定义 layout_ 属性"></a>自定义 layout_ 属性</h3><p>之前在我给大家上的 Android 第一节课讲过，父 View 是可以给子 View 额外添加属性的，且属性名以 <code>layout_</code> 开头</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--比如说这个里面所有 layout_ 开头的都是父 View 给子 View 添加的额外属性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;top|left&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>那如何自定义 ViewGroup 如何设置自己想要的属性？</p>
<p>比如我给它添加一个表示子 View 位置的属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--注意：这种属性的设置必须以 _Layout 结尾，这是官方的规范！--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;My6ViewGroup_Layout&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--注意：属性名建议带有 layout_ 开头的标识--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my6VG_layout_position&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;integer&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后在 xml 中写得时候，AS 会进行智能提示</p>
<img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321194906364.png" srcset="/img/loading.gif" lazyload alt="image-20220321194906364" style="zoom:67%;" />

<p>那怎么获取这个属性呢？</p>
<p>这个我们留到 <a href="#1%E3%80%81LayoutParams">LayoutParams</a> 再讲解</p>
</blockquote>
<h3 id="7、onMeasure"><a href="#7、onMeasure" class="headerlink" title="7、onMeasure()"></a>7、onMeasure()</h3><blockquote>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>测量自身和子控件大小</p>
<h3 id="涉及知识"><a href="#涉及知识" class="headerlink" title="涉及知识"></a>涉及知识</h3><ul>
<li><code>MeasureSpecs</code></li>
<li><code>LayoutParams</code></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 与上面讲的 onDraw() 一样，也是一个回调，该回调的作用是由 requestLayout() 触发</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(widthMeasureSpec: <span class="hljs-type">Int</span>, heightMeasureSpec: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="主要用法"><a href="#主要用法" class="headerlink" title="主要用法"></a>主要用法</h3><ul>
<li>调用 <code>setMeasuredDimension()</code>，设置自身宽和高</li>
<li>遍历子 View，再调用 <code>child.measure()</code>，设置子 View 的宽和高</li>
</ul>
<pre><code class=" mermaid">graph LR
id1(&quot;ViewRootImpl 开始测量&quot;)--&gt;id2
id2[&quot;ViewGroup#mearsure()&quot;]--&gt;id3
id3[&quot;ViewGroup#onMeasure()&quot;]--&gt;id4
id4[&quot;View#measure()&quot;]--&gt;id5(&quot;View#onMeasure()&quot;)
</code></pre>


</blockquote>
<h4 id="1、LayoutParams"><a href="#1、LayoutParams" class="headerlink" title="1、LayoutParams"></a>1、LayoutParams</h4><blockquote>
<p>这就是一个很简单的数据类，用于在子 View 中保存父类需要的信息</p>
<p>我们直接来看一下 FrameLayout 的 LayoutParams</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 你会发现这 LayoutParams 很简单</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LayoutParams</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MarginLayoutParams</span> &#123;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对应 layout_gravity 属性没有被设置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNSPECIFIED_GRAVITY</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这就是 layout_gravity 属性的保存值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> android.view.Gravity</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@attr</span> ref android.R.styleable#FrameLayout_Layout_layout_gravity</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">gravity</span> <span class="hljs-operator">=</span> UNSPECIFIED_GRAVITY;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LayoutParams</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context c, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> &#123;<br>        <span class="hljs-built_in">super</span>(c, attrs);<br>        <span class="hljs-comment">// 看到这里你应该就能回答之前留下的问题了</span><br>        <span class="hljs-comment">// 父 View 读取子 View 中的属性是在 LayoutParams 中获取的</span><br>        <span class="hljs-comment">// 可能你会奇怪于 View 是什么时候开始加载 LayoutParams</span><br>        <span class="hljs-comment">// 这个留到后面讲 setContentView 再讲解</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">TypedArray</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> c.obtainStyledAttributes(attrs, R.styleable.FrameLayout_Layout);<br>        gravity = a.getInt(R.styleable.FrameLayout_Layout_layout_gravity, UNSPECIFIED_GRAVITY);<br>        a.recycle();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LayoutParams</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> &#123;<br>        <span class="hljs-built_in">super</span>(width, height);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LayoutParams</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">int</span> gravity)</span> &#123;<br>        <span class="hljs-built_in">super</span>(width, height);<br>        <span class="hljs-built_in">this</span>.gravity = gravity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LayoutParams</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup.LayoutParams source)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LayoutParams</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup.MarginLayoutParams source)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LayoutParams</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutParams source)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>        <span class="hljs-built_in">this</span>.gravity = source.gravity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要想使用这个 <code>LayoutParams</code> 还得重写这几个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这个是检查 LayoutParams 是否是你想要的 LayoutParams</span><br><span class="hljs-comment">// 注意：这个 LayoutParams 是需要打个 ? 的，因为存在传入一个 null 的情况</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkLayoutParams</span><span class="hljs-params">(p: <span class="hljs-type">LayoutParams</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-comment">// 这是惯用写法</span><br>    <span class="hljs-keyword">return</span> p <span class="hljs-keyword">is</span> NetLayoutParams<br>&#125;<br><br><span class="hljs-comment">// 这个是通过 AttributeSet 得到你自己的 LayoutParmas</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">generateLayoutParams</span><span class="hljs-params">(attrs: <span class="hljs-type">AttributeSet</span>)</span></span>: LayoutParams &#123;<br>    <span class="hljs-keyword">return</span> NetLayoutParams(context, attrs)<br>&#125;<br><br><span class="hljs-comment">// 这个是装换 LayoutParms</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">generateLayoutParams</span><span class="hljs-params">(lp: <span class="hljs-type">LayoutParams</span>)</span></span>: LayoutParams &#123;<br>    <span class="hljs-comment">// 这也是惯用写法，注意：要把你 LayoutParams 的所有父类都要写完</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (lp) &#123;<br>        <span class="hljs-keyword">is</span> NetLayoutParams -&gt; NetLayoutParams(lp)<br>        <span class="hljs-keyword">is</span> MarginLayoutParams -&gt; NetLayoutParams(lp)<br>        <span class="hljs-keyword">else</span> -&gt; NetLayoutParams(lp)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这个是得到默认的 LayoutParams</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">generateDefaultLayoutParams</span><span class="hljs-params">()</span></span>: LayoutParams &#123;<br>    <span class="hljs-keyword">return</span> NetLayoutParams(<br>        NetLayoutParams.UNSET,<br>        NetLayoutParams.UNSET,<br>        NetLayoutParams.UNSET,<br>        NetLayoutParams.UNSET<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这几个方法会在什么时候被调用，我们会在后面的 <a href="#1%E3%80%81LayoutInflater">LayoutInflater</a> 讲解</p>
</blockquote>
<h4 id="2、MeasureSpecs"><a href="#2、MeasureSpecs" class="headerlink" title="2、MeasureSpecs"></a>2、MeasureSpecs</h4><blockquote>
<p>推荐文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1260a98a09e9">https://www.jianshu.com/p/1260a98a09e9</a></p>
<p>它保存了测量模式和测量大小</p>
<p>比如上面代码中的：<code>widthMeasureSpec</code> 和 <code>heightMeasureSpec</code></p>
<p>可能你会比较疑惑它是怎么用一个 int 来保存的，其实原理很简单，它使用高 2 位保存测量模式，后 30 为测量大小</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用方式，原理就是位运算</span><br><span class="hljs-keyword">val</span> wSize = MeasureSpec.getSize(widthMeasureSpec)<br><span class="hljs-keyword">val</span> wMode = MeasureSpec.getMode(widthMeasureSpec)<br></code></pre></td></tr></table></figure>

<p>测量模式有以下三种：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>EXACTLY</strong></em></td>
<td>有具体值时</td>
<td>一般对应 <code>match_parent</code> 和具体的值</td>
</tr>
<tr>
<td><em><strong>AT_MOST</strong></em></td>
<td>自适应大小</td>
<td>一般对应 <code>wrap_content</code></td>
</tr>
<tr>
<td><em><strong>UNSPECIFIED</strong></em></td>
<td>可任意取值</td>
<td>只出现于 <code>ScrollView</code>、<code>ListView</code> 这类控件中</td>
</tr>
</tbody></table>
<p>重写 ViewGroup 时就是通过这些来判断子 View 应该取得的高度的</p>
<p>关于怎么取，可以看这个在 ViewGroup 中的方法，里面是常见情况时的取法，该方法在很多官方控件中被使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> spec 子 View 能得到的 MeasureSpecs，一般是父 View 的测量模式 + 想给出的大小</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> padding 间距值，一般这样填入：layoutParams.leftMargin + layoutParams.rightMargin</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> childDimension 子 View 的宽或者高，固定填入：child.width 或者 child.height</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getChildMeasureSpec</span><span class="hljs-params">(<span class="hljs-type">int</span> spec, <span class="hljs-type">int</span> padding, <span class="hljs-type">int</span> childDimension)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(spec); <span class="hljs-comment">// 测量模式</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">specSize</span> <span class="hljs-operator">=</span> MeasureSpec.getSize(spec); <span class="hljs-comment">// 测量长度</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, specSize - padding); <span class="hljs-comment">// 先减去间距值得到的最大长度</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">resultSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 保存最后的长度值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">resultMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 保存最后的测量，模式</span><br><br>    <span class="hljs-keyword">switch</span> (specMode) &#123;<br>    <span class="hljs-comment">// 如果测量模式是具体值，即一般对应父 View 为 match_parent 或者 确定值</span><br>    <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>        <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 假设子 View 固定为 100dp</span><br>            resultSize = childDimension;<br>            resultMode = MeasureSpec.EXACTLY;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>            <span class="hljs-comment">// 子 View 是 match_parent</span><br>            resultSize = size; <span class="hljs-comment">// 那结果值就是最大值</span><br>            resultMode = MeasureSpec.EXACTLY; <span class="hljs-comment">// 测量模式保持一样，为具体值</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>            <span class="hljs-comment">// 子 View 是 wrap_content</span><br>            resultSize = size;<br>            resultMode = MeasureSpec.AT_MOST; <span class="hljs-comment">// 改变测量模式为自适应大小</span><br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 如果测量模式是自适应大小，即一般对应父 View 为 wrap_content</span><br>    <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>        <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 假设子 View 固定为 100dp</span><br>            resultSize = childDimension;<br>            resultMode = MeasureSpec.EXACTLY;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>            <span class="hljs-comment">// 子 View 是 match_parent</span><br>            <span class="hljs-comment">// 这里比较重要</span><br>            <span class="hljs-comment">// 这里对应父 View 为 wrap_content，但子 View 却为 match_parent</span><br>            resultSize = size; <span class="hljs-comment">// 这里的意思是给出子 View 能得到的最大值</span><br>            resultMode = MeasureSpec.AT_MOST;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>            <span class="hljs-comment">// 子 View 是 wrap_content</span><br>            resultSize = size;<br>            resultMode = MeasureSpec.AT_MOST;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// 如果测量模式是可任意取值，即一般对应父 View 为 ScrollView</span><br>    <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>        <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 假设子 View 固定为 100dp</span><br>            resultSize = childDimension;<br>            resultMode = MeasureSpec.EXACTLY;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>            <span class="hljs-comment">// 子 View 是 match_parent</span><br>            <span class="hljs-comment">// 这个 sUseZeroUnspecifiedMeasureSpec 变量用于兼容 Android 旧版本</span><br>            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;<br>            resultMode = MeasureSpec.UNSPECIFIED;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>            <span class="hljs-comment">// 子 View 是 wrap_content</span><br>            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;<br>            resultMode = MeasureSpec.UNSPECIFIED;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果你以后开发自定义 ViewGroup，在给子 View 测量时我更推荐使用该方法，遵循官方的写法可以提高可读性</p>
</blockquote>
<h4 id="3、onMeasure-源码相关分析"><a href="#3、onMeasure-源码相关分析" class="headerlink" title="3、onMeasure() 源码相关分析"></a>3、onMeasure() 源码相关分析</h4><h5 id="1、FrameLayout-的-onMeasure-源码分析"><a href="#1、FrameLayout-的-onMeasure-源码分析" class="headerlink" title="1、FrameLayout 的 onMeasure() 源码分析"></a>1、FrameLayout 的 onMeasure() 源码分析</h5><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接下来是起飞环节</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> getChildCount();<br><br> <span class="hljs-comment">// 判断自身是否有一边不是具体值，作用如下：</span><br> <span class="hljs-comment">// 比如 FrameLayout 的宽是 wrap_content，但其中一个子 View 宽为 match_parent</span><br> <span class="hljs-comment">// 那么这个时候 FrameLayout 是不知道该给这个子 View 宽度多少的</span><br> <span class="hljs-comment">// 但我们可以通过其他 View 来判断 FrameLayout 能得到的宽度</span><br> <span class="hljs-comment">// 这个时候就知道 FraneLayout 宽度值能取多少了</span><br> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">measureMatchParentChildren</span> <span class="hljs-operator">=</span><br>         MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||<br>         MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;<br> <span class="hljs-comment">// 这个是保存上述所说的那种子 View，用于二次测量</span><br> mMatchParentChildren.clear(); <br><br> <span class="hljs-type">int</span> <span class="hljs-variable">maxHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <span class="hljs-type">int</span> <span class="hljs-variable">maxWidth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <span class="hljs-comment">// 状态值，用来记录子 View 是否得到了想要的大小，用的很少，忽略即可</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">childState</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br><br> <span class="hljs-comment">// 遍历所有子 View</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getChildAt(i);<br>     <span class="hljs-comment">// 这个 mMeasureAllChildren 是一个属性，作用：是否忽略 Gone 的影响</span><br>     <span class="hljs-comment">// child.getVisibility() != GONE：Gone 时不测量子 View</span><br>     <span class="hljs-comment">// 这个 Gone 时再自己写自定义 View 建议也判断上</span><br>     <span class="hljs-keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;<br>         <span class="hljs-comment">// measureChildWithMargins() 里面调用了测量子 View 的方法</span><br>         <span class="hljs-comment">// 之后会提到该方法，你只需要知道调用后可以得到子 View 测量的宽和高</span><br>         <span class="hljs-comment">// 但这个宽和高不是 width 和 height，而是 measuredWidth 和 measuredHeight</span><br>         measureChildWithMargins(child, widthMeasureSpec, <span class="hljs-number">0</span>, heightMeasureSpec, <span class="hljs-number">0</span>);<br>         <span class="hljs-comment">// 得到 LayoutParams，主要是从里面取得定义的 Margin 值</span><br>         <span class="hljs-keyword">final</span> <span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (LayoutParams) child.getLayoutParams();<br>         <span class="hljs-comment">// 保存子 View 中最大的宽度</span><br>         maxWidth = Math.max(maxWidth,<br>                 child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);<br>         <span class="hljs-comment">// 保存子 View 中最大的高度</span><br>         maxHeight = Math.max(maxHeight,<br>                 child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);<br>         <span class="hljs-comment">// 状态值，忽略即可，在 ViewRootImpl 中有使用，一般情况下自定义 View 不用</span><br>         childState = combineMeasuredStates(childState, child.getMeasuredState());<br>         <span class="hljs-comment">// 最开始的那个 boolean 值，用来保存是 match_parent 的 View</span><br>         <span class="hljs-keyword">if</span> (measureMatchParentChildren) &#123;<br>             <span class="hljs-keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||<br>                     lp.height == LayoutParams.MATCH_PARENT) &#123;<br>                 mMatchParentChildren.add(child);<br>             &#125;<br>         &#125;<br>     &#125;<br> &#125;<br><br> <span class="hljs-comment">// 最大值加上 padding 值</span><br> <span class="hljs-comment">// getPadding*WithForeground() 是内部方法，我们自己用时是使用 getPadding*() 代替</span><br> maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();<br> maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();<br><br> <span class="hljs-comment">// 检查最小值的设置</span><br> <span class="hljs-comment">// View 都自带了一个 android:minHeight 属性，自己自定义 View 时建议把这个适配一下</span><br> maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());<br> maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());<br><br> <span class="hljs-comment">// 得到前台的背景图，再与最大值比较</span><br> <span class="hljs-keyword">final</span> <span class="hljs-type">Drawable</span> <span class="hljs-variable">drawable</span> <span class="hljs-operator">=</span> getForeground();<br> <span class="hljs-keyword">if</span> (drawable != <span class="hljs-literal">null</span>) &#123;<br>     maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());<br>     maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());<br> &#125;<br><br> <span class="hljs-comment">// 关键方法，调用 setMeasuredDimension() 设置自身宽和高</span><br> setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),<br>         resolveSizeAndState(maxHeight, heightMeasureSpec,<br>                 childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));<br><br> <span class="hljs-comment">// 在上面那个调用过后，就能得到自身的宽和高了</span><br> <span class="hljs-comment">// 然后这里再重写测量为 match_parent 的 View</span><br> count = mMatchParentChildren.size();<br> <span class="hljs-comment">// 这个 count 判断我个人感觉有点问题</span><br> <span class="hljs-comment">// count 是指为 match_parent View 的数量，</span><br> <span class="hljs-comment">// 而如果我只有一个 View 是 match_parent，那它不是就不会重新测量了吗？</span><br> <span class="hljs-comment">// 真奇怪，我感觉该用 childCount</span><br> <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> mMatchParentChildren.get(i);<br>         <span class="hljs-keyword">final</span> <span class="hljs-type">MarginLayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (MarginLayoutParams) child.getLayoutParams();<br><br>         <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> childWidthMeasureSpec;<br>         <span class="hljs-keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;<br>             <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, getMeasuredWidth()<br>                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()<br>                        - lp.leftMargin - lp.rightMargin);<br>                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(<br>                        width, MeasureSpec.EXACTLY);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,<br>                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +<br>                        lp.leftMargin + lp.rightMargin,<br>                        lp.width);<br>            &#125;<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> childHeightMeasureSpec;<br>            <span class="hljs-keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, getMeasuredHeight()<br>                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()<br>                        - lp.topMargin - lp.bottomMargin);<br>                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(<br>                        height, MeasureSpec.EXACTLY);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,<br>                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +<br>                        lp.topMargin + lp.bottomMargin,<br>                        lp.height);<br>            &#125;<br>            <span class="hljs-comment">// 这里可以发现 onMeasure() 不止会调用一次，有时候需要调用多次才能测量完成 </span><br>            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>


</blockquote>
<h5 id="2、NestedScrollView-嵌套-Rv-复用失效"><a href="#2、NestedScrollView-嵌套-Rv-复用失效" class="headerlink" title="2、NestedScrollView 嵌套 Rv 复用失效"></a>2、NestedScrollView 嵌套 Rv 复用失效</h5><blockquote>
<p>接下来开始做火箭</p>
<p>我们来分析一下我寒假时多次提到 NestedScrollView 嵌套 Rv，导致 Rv 复用失效的问题，网上我还没有看过很详细的从源码角度来分析的文章</p>
<p>首先我们要想想问什么会失效？</p>
<p>失效说明 Rv 把全部子 View 都测量完了，那说明肯定是 <code>onMeasure()</code> 的问题，ok，那我们来 debug 一下 <code>onMeasure()</code> 的整个流程</p>
<h5 id="首先从-NestedScrollView-的-onMeasure-开始-debug"><a href="#首先从-NestedScrollView-的-onMeasure-开始-debug" class="headerlink" title="首先从 NestedScrollView 的 onMeasure() 开始 debug"></a>首先从 NestedScrollView 的 onMeasure() 开始 debug</h5><blockquote>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321225743926.png" srcset="/img/loading.gif" lazyload alt="image-20220321225743926"></p>
<p>可以发现 NestedScrollView 把测量直接交给了父类 FrameLayout 处理，（你可能会疑惑，不重写 <code>onMeasure()</code> 那 NestedScrollView 是怎么实现不同于其他 View 测量的？这个问题在下面会讲解）</p>
<p>又由于 <code>mFillViewport</code> 为 <code>false</code>，就直接 return 了，至于 <code>mFillViewport</code> 是什么我们后面会讲解</p>
</blockquote>
<h5 id="来到-FrameLayout-的-onMeasure-实现"><a href="#来到-FrameLayout-的-onMeasure-实现" class="headerlink" title="来到 FrameLayout 的 onMeasure() 实现"></a>来到 FrameLayout 的 onMeasure() 实现</h5><blockquote>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321230004519.png" srcset="/img/loading.gif" lazyload alt="image-20220321230004519"></p>
<p>这里只有一个 View，就是 Rv，然后 FrameLayout 调用了 <code>measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0)</code>，这个函数被 NestedScrollView 重写了，然后给出了一个 <code>MeasureSpec.UNSPECIFIED</code>，这就是 NestedScrollView 不同于其他 View 测量的原因</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321230432739.png" srcset="/img/loading.gif" lazyload alt="image-20220321230432739"></p>
<p>仔细看红线处，这里它给出的高度竟然直接为 <code>lp.topMargin + lp.bottomMargin</code>，可能你不会意识到这个有什么问题，我们来看看 NestedScrollView 的孪生兄弟 ScrollView 对于该方法的实现</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321230936516.png" srcset="/img/loading.gif" lazyload alt="image-20220321230936516"></p>
<p>发现不同了吗，ScrollView 有个 <code>parentHeightMeasureSpec</code> 的高度，而 NestedScrollView 只使用了 <code>lp.topMargin + lp.bottomMargin</code>，如果子 View 没得 margin 值，那不就直接给子 View 传入的高度为 0 了？</p>
<p>NestedScrollView 与 ScrollView 在这个方法上的不同，就是造成 Rv 复用失效的直接原因，接下来我们探究一下根本原因</p>
</blockquote>
<h5 id="来到-Rv-的-onMeasure"><a href="#来到-Rv-的-onMeasure" class="headerlink" title="来到 Rv 的 onMeasure"></a>来到 Rv 的 onMeasure</h5><blockquote>
<p>紧接着上面继续 debug，我们来到了 Rv 的 <code>onMeasure()</code> 实现</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321231555746.png" srcset="/img/loading.gif" lazyload alt="image-20220321231555746"></p>
<p>可以发现这里 <code>heightSpec</code> 为 0</p>
</blockquote>
<h5 id="来到-dispatchLayoutStep2-方法"><a href="#来到-dispatchLayoutStep2-方法" class="headerlink" title="来到 dispatchLayoutStep2() 方法"></a>来到 dispatchLayoutStep2() 方法</h5><blockquote>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321231735164.png" srcset="/img/loading.gif" lazyload alt="image-20220321231735164"></p>
<p>前面那个 <code>dispatchLayoutStrp1()</code> 因为不处于 <code>State.STEP_START</code> 而跳过了</p>
</blockquote>
<h5 id="发现-mLayout-onLayoutChildren"><a href="#发现-mLayout-onLayoutChildren" class="headerlink" title="发现 mLayout.onLayoutChildren()"></a>发现 mLayout.onLayoutChildren()</h5><blockquote>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321232502431.png" srcset="/img/loading.gif" lazyload alt="image-20220321232502431"></p>
<p>整个 <code>dispatchLayoutChild2()</code> 一看就只有这个方法是用于布局的，debug 进去试试</p>
</blockquote>
<h5 id="探索-onLayoutChild-方法"><a href="#探索-onLayoutChild-方法" class="headerlink" title="探索 onLayoutChild() 方法"></a>探索 onLayoutChild() 方法</h5><blockquote>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321233030377.png" srcset="/img/loading.gif" lazyload alt="image-20220321233030377"></p>
<p>前面有一堆方法，但其实 Rv 是调用这个 <code>fill()</code> 来给子 View 布局的</p>
</blockquote>
<h5 id="探索-fill"><a href="#探索-fill" class="headerlink" title="探索 fill()"></a>探索 fill()</h5><blockquote>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321233713916.png" srcset="/img/loading.gif" lazyload alt="image-20220321233713916"></p>
<p>这个 while 很重要，就是依靠这个循环来测量子 View 的，虽然你应该看的很懵逼，但请记住这两个东西：</p>
<p><code>layoutState.mInfinite = true</code> 和 <code>remainingSpace = 0</code>，后面的 <code>layoutState.hasMore(state)</code> 是用于判断次数是否达到 ItemCount 的，可以不用管</p>
<p>这里就直接告诉你结论，就是因为这个 <code>layoutState.mInfinite = true</code> 导致它一直执行循环，然后一直到 <code>layoutState.hasMore(state) = false</code> 才结束，即把 ItemCount 个 item 都测量完了</p>
<p>很懵逼是不是，我们来看看如果使用 ScrollView 包裹运行到这里时会怎么样？</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321234733578.png" srcset="/img/loading.gif" lazyload alt="image-20220321234733578"></p>
<p>看到区别了吧，使用 ScrollView 时会不一样，其中 <code>layoutState.mInfinite = false</code> 和 <code>remainingSpace = 1868</code> </p>
<p>如果使用 ScrollView 继续往下走</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321234928364.png" srcset="/img/loading.gif" lazyload alt="image-20220321234928364"></p>
<p>他会在这个地方减少 <code>remainingSpace</code> 的值，最后就可以使 while 循环提前退出了</p>
</blockquote>
<p>OK，基本上根本原因找到了，但为什么那个 <code>layoutState.mInfinite = true</code> 且 <code>remainingSpace = 0</code> 呢？</p>
<p>继续分析</p>
<h5 id="为什么-layoutState-mInfinite-x3D-true"><a href="#为什么-layoutState-mInfinite-x3D-true" class="headerlink" title="为什么 layoutState.mInfinite &#x3D; true ?"></a>为什么 layoutState.mInfinite &#x3D; true ?</h5><blockquote>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321235408579.png" srcset="/img/loading.gif" lazyload alt="image-20220321235408579"></p>
<p>点击 <code>layoutState.mInfinite</code>，我们可以发现 <code>mLayoutState.mInfinite</code> 在这里被赋值</p>
<p>点进去看看它赋的什么值</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321235709470.png" srcset="/img/loading.gif" lazyload alt="image-20220321235709470"></p>
<p>第一个 <code>getMode() == View.MeasureSpec.UNSPECIFIED</code> 肯定是 <code>true</code>，因为外布局是 NestedScrollView 嘛，前面提到了它重写了 FrameLayout 的 <code>measureChildWithMargins()</code> 方法，给的子 View 的测量模式是 <code>MeasureSpec.UNSPECIFIED</code> ，第二个判断 <code>mOrientationHelper.getEnd() == 0</code>，根据 debug 可以得到值也为 <code>true</code></p>
<p>继续跟踪 <code>mOrientationHelper.getEnd() == 0</code> 的原因</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000124439.png" srcset="/img/loading.gif" lazyload alt="image-20220322000124439"></p>
<p>可以发现它直接调用了 <code>mLayoutManger.getHeight()</code>，继续</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000411111.png" srcset="/img/loading.gif" lazyload alt="image-20220322000411111"></p>
<p><code>mHeight</code> 被修改的地方如下</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000630000.png" srcset="/img/loading.gif" lazyload alt="image-20220322000630000"></p>
<p>其中前面两个是 <code>setRecyclerView()</code> 是在 Rv 添加 Adapter 时设置的初始值，肯定不是我们要找的地方，那只能是 <code>setMeasureSpecs()</code> 了</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000826091.png" srcset="/img/loading.gif" lazyload alt="image-20220322000826091"></p>
<p>这里有一个 <code>mHeight = 0</code> 的操作，点击方法名称看看是谁调用了它</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322000941813.png" srcset="/img/loading.gif" lazyload alt="image-20220322000941813"></p>
<p>运气真好，刚好回到了我们之前大的断点前，那只能说明就是在这里调用的，所以 <code>mHeight = 0</code>，导致前面的 <code>mOrientationHelper.getEnd() == 0</code> 为 <code>true</code>，最后导致 <code>layoutState.mInfinite</code> 为 <code>true</code> 了 </p>
</blockquote>
<h5 id="为什么-remainingSpace-x3D-0？"><a href="#为什么-remainingSpace-x3D-0？" class="headerlink" title="为什么 remainingSpace &#x3D; 0？"></a>为什么 remainingSpace &#x3D; 0？</h5><blockquote>
<p>如果你大胆猜测的话，应该能猜到肯定与 <code>mHeight</code> 有关系</p>
<p>先来到这里</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322001506870.png" srcset="/img/loading.gif" lazyload alt="image-20220322001506870"></p>
<p>我们可以知道 <code>remainingSpace</code> 由 <code>layoutState.mAvailable + layoutState.mExtraFillSpace</code> 组成，其中通过查看注释可以知道跟 <code>layoutState.mExtraFillSpace</code> 没有关系，那就去寻找 <code>layoutState.mAvailable</code> 吧</p>
<p>可是 <code>layoutState.mAvailable</code> 被改变的地方有点多，不是很好定位，那我们可以试试给这个变量打上断点，重新走一下流程，接下来就是重新 debug 一遍</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322002054498.png" srcset="/img/loading.gif" lazyload alt="image-20220322002054498"></p>
<p>一下子就找到了，不得不说 debug 确实很方便</p>
<p>点击去看一下 <code>mOrientationHelper.getEndAfterPadding()</code> 方法</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322002252433.png" srcset="/img/loading.gif" lazyload alt="image-20220322002252433"></p>
<p>果然，跟最开始的猜测一样，它与 <code>mHeight</code> 有关系</p>
<p>那 <code>updateLayoutStateToFillEnd()</code> 是在什么时候调用的呢？</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322002424079.png" srcset="/img/loading.gif" lazyload alt="image-20220322002424079"></p>
<p>从调用栈发现原来他在 <code>fill()</code> 方法前被调用了</p>
<p>OK，这下子 NestedScrollView 嵌套 Rv 使复用失效的根本原因和决定性因素都找到了</p>
</blockquote>
<h3 id="如何解决复用失效问题？"><a href="#如何解决复用失效问题？" class="headerlink" title="如何解决复用失效问题？"></a>如何解决复用失效问题？</h3><p>根据上面的流程，我们可以找到下面这几种方法：</p>
<h5 id="1、重写-NestedScrollView-的-measureChildWithMargins-方法"><a href="#1、重写-NestedScrollView-的-measureChildWithMargins-方法" class="headerlink" title="1、重写 NestedScrollView 的 measureChildWithMargins() 方法"></a>1、重写 NestedScrollView 的 <code>measureChildWithMargins()</code> 方法</h5><blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重写该方法的几个原因：</span><br><span class="hljs-comment"> * 1、为了在 UNSPECIFIED 模式下，Rv 也能得到 NestedScrollView 的高度</span><br><span class="hljs-comment"> * 2、NestedScrollView 与 ScrollView 在对于子 View 高度处理时在下面这个方法不一样, 导致</span><br><span class="hljs-comment"> *    NestedScrollView 中子 View 必须使用具体的高度, 设置成 wrap_content 或 match_parent</span><br><span class="hljs-comment"> *    都将无效，具体的可以去看 ScrollView 和 NestedScrollView 中对于这同一方法的源码</span><br><span class="hljs-comment"> * 3、在 NestedScrollView 中嵌套 RecyclerView 会使 RecyclerView 的懒加载失效，直接原因就与</span><br><span class="hljs-comment"> *    这个方法有关，而使用 ScrollView 就不会造成懒加载失效的情况</span><br><span class="hljs-comment"> * 4、至于为什么 NestedScrollView 与 ScrollView 在该方法不同，我猜测原因是为了兼容以前的 Android 版本，</span><br><span class="hljs-comment"> *    在 ViewGroup#getChildMeasureSpec() 方法中可以发现使用了</span><br><span class="hljs-comment"> *    一个静态变量 sUseZeroUnspecifiedMeasureSpec</span><br><span class="hljs-comment"> *    来判断 UNSPECIFIED 模式下子 View 该得到的大小，但可能设计 NestedScrollView “偷懒”了，</span><br><span class="hljs-comment"> *    没有加这个东西，具体原因不知</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">measureChildWithMargins</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    child: <span class="hljs-type">View</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    parentWidthMeasureSpec: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    widthUsed: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    parentHeightMeasureSpec: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    heightUsed: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> lp = child.layoutParams <span class="hljs-keyword">as</span> MarginLayoutParams<br><br>    <span class="hljs-keyword">val</span> childWidthMeasureSpec = getChildMeasureSpec(<br>        parentWidthMeasureSpec,<br>        paddingLeft + paddingRight + lp.leftMargin + lp.rightMargin<br>                + widthUsed, lp.width<br>    )<br>    <span class="hljs-comment">// 这里的写法与 ScrollView 里面的一样</span><br>    <span class="hljs-keyword">val</span> usedTotal = paddingTop + paddingBottom + lp.topMargin + lp.bottomMargin + heightUsed<br>    <span class="hljs-keyword">val</span> childHeightMeasureSpec: <span class="hljs-built_in">Int</span> = MeasureSpec.makeMeasureSpec(<br>        max(<span class="hljs-number">0</span>, MeasureSpec.getSize(parentHeightMeasureSpec) - usedTotal),<br>        MeasureSpec.UNSPECIFIED<br>    )<br><br>    child.measure(childWidthMeasureSpec, childHeightMeasureSpec)<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="2、直接给-Rv-设置固定高度"><a href="#2、直接给-Rv-设置固定高度" class="headerlink" title="2、直接给 Rv 设置固定高度"></a>2、直接给 Rv 设置固定高度</h5><blockquote>
<p>这个方法就可以直接修改 <code>mHeight</code> 的值，从之前的分析中可以得到<code>layoutState.mInfinite</code> 和 <code>remainingSpace</code> 都与 <code>mHeight</code> 有关，所以修改 <code>mHeight</code> 就可以从根源上解决复用失效问题</p>
</blockquote>
<h5 id="3、使用-mFillViewport-属性，但需要-NsetedScrollView-的-layout-height-x3D-match-parent-或-确定值"><a href="#3、使用-mFillViewport-属性，但需要-NsetedScrollView-的-layout-height-x3D-match-parent-或-确定值" class="headerlink" title="3、使用 mFillViewport 属性，但需要 NsetedScrollView 的 layout_height &#x3D; match_parent 或 确定值"></a>3、使用 mFillViewport 属性，但需要 NsetedScrollView 的 layout_height &#x3D; match_parent 或 确定值</h5><blockquote>
<p>前面在 <code>onMeasure()</code> 提到了一个 <code>mFillViewport</code> 变量</p>
<p>这是它的官方解释：</p>
<blockquote>
<p>设置此 ScrollView 是否应拉伸其内容高度以填充视口</p>
</blockquote>
<p>它对应这个属性：</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322003418726.png" srcset="/img/loading.gif" lazyload alt="image-20220322003418726"></p>
<p>但再次之前我们先看一下，设置为 <code>true</code> 后 <code>onMeasure()</code> 干了些什么东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);<br>    <span class="hljs-comment">// mFillViewport 为 true 不会被 return 了</span><br>    <span class="hljs-keyword">if</span> (!mFillViewport) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">heightMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(heightMeasureSpec);<br>    <span class="hljs-keyword">if</span> (heightMode == MeasureSpec.UNSPECIFIED) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (getChildCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getChildAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">final</span> NestedScrollView.<span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (LayoutParams) child.getLayoutParams();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">childSize</span> <span class="hljs-operator">=</span> child.getMeasuredHeight();<br>        <br>        <span class="hljs-comment">// 关键在于这里，得到自身的测量高度</span><br>        <span class="hljs-comment">// 这个测量高度是之前调用 super.onMeasure() 而设置的</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parentSpace</span> <span class="hljs-operator">=</span> getMeasuredHeight()<br>                - getPaddingTop()<br>                - getPaddingBottom()<br>                - lp.topMargin<br>                - lp.bottomMargin;<br><br>        <span class="hljs-keyword">if</span> (childSize &lt; parentSpace) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">childWidthMeasureSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(widthMeasureSpec,<br>                    getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin,<br>                    lp.width);<br>            <span class="hljs-comment">// 给子 View 的测量模式使用了 MeasureSpec.EXACTLY</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">childHeightMeasureSpec</span> <span class="hljs-operator">=</span><br>                    MeasureSpec.makeMeasureSpec(parentSpace, MeasureSpec.EXACTLY);<br>            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码我们可以发现，设置 <code>mFillViewport = true</code> 后 NestedScrollView 会使用 <code>MeasureSpec.EXACTLY</code> 模式再次测量子 View，高度使用的是自身的高度</p>
<p>而自身的高度只有在 <code>match_parent</code> 或者 确定值 时才有用，不然，如果你的 <code>layout_height</code> 为 <code>wrap_content</code>，那 <code>NestedScrollView#getMeasuredHeight()</code> 得到仍然是 Rv 全部测量时的高度，所以这时再测量还是会导致 Rv 复用失效</p>
<p>使用 mFillViewport 属性，但需要 NsetedScrollView 的 <strong>layout_height &#x3D; match_parent 或 确定值</strong></p>
<p>但一般都不会使用到这个属性来解决 Rv 复用失效问题，这里只是当个扩展来讲解</p>
</blockquote>
<h5 id="问题：如果给-Rv-外面再包一层，那复用还会失效吗？"><a href="#问题：如果给-Rv-外面再包一层，那复用还会失效吗？" class="headerlink" title="问题：如果给 Rv 外面再包一层，那复用还会失效吗？"></a>问题：如果给 Rv 外面再包一层，那复用还会失效吗？</h5><blockquote>
<p>答案：仍然会失效</p>
<p>首先，我们知道失效的决定因素是 <code>mHeight == 0 &amp;&amp; mode == MeasureSpec.UNSPECIFIED</code>，而 NestedScrollView 在子 View 没有设置 Margin 值时给子 View 传入的高度肯定是 0</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220321230936516.png" srcset="/img/loading.gif" lazyload alt="image-20220321230936516"></p>
<p>而 <code>MeasureSpec.UNSPECIFIED</code> 测量模式具有传递性，前面我们提到 <code>getChildMeasureSpec()</code> 方法（<a href="#2%E3%80%81MeasureSpecs">MeasureSpecs</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果测量模式是可任意取值，即一般对应父 View 为 ScrollView</span><br><span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>    <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 假设子 View 固定为 100dp</span><br>        resultSize = childDimension;<br>        resultMode = MeasureSpec.EXACTLY;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>        <span class="hljs-comment">// 子 View 是 match_parent</span><br>        <span class="hljs-comment">// 这个 sUseZeroUnspecifiedMeasureSpec 变量用于兼容 Android 旧版本</span><br>        resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;<br>        resultMode = MeasureSpec.UNSPECIFIED;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>        <span class="hljs-comment">// 子 View 是 wrap_content</span><br>        resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;<br>        resultMode = MeasureSpec.UNSPECIFIED;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>

<p>可以看到除了 <code>childDimension &gt;= 0</code> 外其他情况测量模式都是 <code>MeasureSpec.UNSPECIFIED</code>，所以你中间夹一层其他布局是解决不了的</p>
</blockquote>
</blockquote>
<h5 id="3、Dialog-根布局设置宽高失效"><a href="#3、Dialog-根布局设置宽高失效" class="headerlink" title="3、Dialog 根布局设置宽高失效"></a>3、Dialog 根布局设置宽高失效</h5><blockquote>
<p>这个东西之前在寒假期间讲过，但才发现当时讲的有些小问题：</p>
<ul>
<li>只有 DialogFragment 才会使外层布局的所有 <code>layout_</code> 属性失效，而 Dialog 则<strong>一般</strong>不会</li>
</ul>
<p>其实也不是一般不会，主要是 DialogFragment 和 Dialog 在一个方法使用上的不同，所以为什么我最开始给那位学弟讲的<img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322180055610.png" srcset="/img/loading.gif" lazyload alt="image-20220322180055610" style="zoom: 50%;" /></p>
<p>原来是我以为 dialog 能设置，那 DialogFragment 也能设置了，原来 DialogFragment 设置是失效的</p>
<p>这里直接先讲原因：</p>
<p>DialogFragment 是使用 <code>setContentView(View view)</code> 来设置根布局的，而 Dialog 一般使用 <code>setContentView(int id)</code> 来设置根布局，这两个方法在底层的调用会有些不同</p>
<p>我们直接从 DialogFragment 开始 debug</p>
<p>DialogFragment 是一个 Fragment，里面夹带了一个 dialog，根据 Fragment 常见的写法，先给 <code>onCreateView()</code> 打上 debug</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326185016280.png" srcset="/img/loading.gif" lazyload alt="image-20220326185016280"></p>
<p>debug 进来发现一堆方法，但如果不了解这些东西的话，确实很难知道它把这个返回的 View 拿来干了什么，其实当时我在给那位学弟找这个问题答案的时候找了很久，最后是从 <code>View#setLayoutParams()</code> 方法入手，在一堆调用栈中发现了答案。这里为了省时间就直接按正向流程讲一遍吧</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322180533094.png" srcset="/img/loading.gif" lazyload alt="image-20220322180533094"></p>
<p>这里它有一个 <code>LiveData</code> 通知观察者</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322180809792.png" srcset="/img/loading.gif" lazyload alt="image-20220322180809792"></p>
<p>DialogFragment 里面对它进行了观察，DialogFragment 是在 <code>onAttach()</code> 的时候开始进行观察的，怪不得我按正常流程走了半天也找不到问题 :( </p>
<p>这里的观察者被通知时调用了 <code>mDialog.setContentView(view)</code>，点击它继续往下走</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322190910124.png" srcset="/img/loading.gif" lazyload alt="image-20220322190910124"></p>
<p>可以发现这里它直接传入了自己的 LayoutParams，这就是为什么所有 <code>layout_</code> 属性全部失效的原因</p>
<p>那普通的 dialog 为什么不会失效呢？</p>
<p>主要原因是 dialog 一般是这样写的：</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322191150701.png" srcset="/img/loading.gif" lazyload alt="image-20220322191150701"></p>
<img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220322191527878.png" srcset="/img/loading.gif" lazyload alt="image-20220322191527878" style="zoom: 50%;" />

<p>可以看到它调用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;mLayoutInflater.inflate(layoutResID, mContentParent);<br></code></pre></td></tr></table></figure>

<p>而不是使用的 <code>setContenView(View view)</code></p>
<p>至于 <code>LayoutInflater</code> 会在后面进行讲解，这里你只需要知道调用了这个方法后，它会读取 xml 文件，并把 xml 中写的 <code>layout_</code> 属性保存在一个 <code>LayoutParams</code> 中供父布局使用，所以这就是 DialogFragment 的 <code>layout_</code> 属性不会失效的原因，当然，只是一般不会失效，如果你非要在 dialog 中调用 <code>setContentView(View view)</code>，那肯定也是一样会失效的</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h5 id="1、在-DialogFragment-的根布局外面再包一层-FrameLayout"><a href="#1、在-DialogFragment-的根布局外面再包一层-FrameLayout" class="headerlink" title="1、在 DialogFragment 的根布局外面再包一层 FrameLayout"></a>1、在 DialogFragment 的根布局外面再包一层 FrameLayout</h5><blockquote>
<p>这样包了一层后就可以让你自己的布局的 <code>layout_</code> 在 FrameLayout 下生效，FrameLayout 的 <code>layout_width</code>、<code>layout_height</code> 任意设置都可以，因为失效了，但我更推荐设置成 <code>wrap_content</code>，这样看起来逻辑要好一点</p>
</blockquote>
<h5 id="2、通过代码设置宽和高"><a href="#2、通过代码设置宽和高" class="headerlink" title="2、通过代码设置宽和高"></a>2、通过代码设置宽和高</h5><blockquote>
<p>可以设置根布局的宽和高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 只有在 onViewCreated() 回调里设置才有效</span><br>override fun <span class="hljs-title function_">onViewCreated</span><span class="hljs-params">(view: View, savedInstanceState: Bundle?)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onViewCreated(view, savedInstanceState)<br>    <span class="hljs-comment">// density 是 dp / px 的转换率，比如：我的手机转换率是 2.75，则 1dp 对应 2.75px</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">density</span> <span class="hljs-operator">=</span> requireContext().resources.displayMetrics.density<br>    <span class="hljs-type">val</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> view.layoutParams<br>    lp.width = (density * <span class="hljs-number">400</span>).toInt()<br>    lp.height = (density * <span class="hljs-number">300</span>).toInt()<br>    <span class="hljs-comment">// 这里只是修改了宽和高，因为 View 还没有被测量布局</span><br>    <span class="hljs-comment">// 所以可以不用调用 view.layoutParams = lp 来刷新，在其他地方使用时是要通过这种方式才能刷新的！</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可以设置 window 的宽和高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 只有在 onViewCreated() 回调里设置才有效</span><br>override fun <span class="hljs-title function_">onViewCreated</span><span class="hljs-params">(view: View, savedInstanceState: Bundle?)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onViewCreated(view, savedInstanceState)<br>    <span class="hljs-comment">// density 是 dp / px 的转换率，比如：我的手机转换率是 2.75，则 1dp 对应 2.75px</span><br>    <span class="hljs-type">val</span> <span class="hljs-variable">density</span> <span class="hljs-operator">=</span> requireContext().resources.displayMetrics.density<br>    dialog?.window?.setLayout(<br>        (density * <span class="hljs-number">400</span>).toInt(),<br>        (density * <span class="hljs-number">300</span>).toInt()<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个 window 其实是 Android 里的 <code>PhoneWindow</code>，听名字就知道是一个管理手机窗口的类，调用这个 <code>setLayout()</code> 最后会重新给 <code>DectorView</code> 设置 <code>LayoutParams</code>，<code>DectorView</code> 是所有窗口的根布局</p>
</blockquote>
<p>上面两种解决方法我更推荐使用第一种，因为在 xml 中定义属性更好修改，不然在代码中修改宽和高，会给以后看代码的人带来疑惑</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>OK，<code>onMeasure()</code> 基本上就讲到这里了</p>
</blockquote>
<h3 id="8、onLayout"><a href="#8、onLayout" class="headerlink" title="8、onLayout()"></a>8、onLayout()</h3><blockquote>
<h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>布局子控件</p>
<h3 id="涉及知识-1"><a href="#涉及知识-1" class="headerlink" title="涉及知识"></a>涉及知识</h3><ul>
<li><code>measureWidth</code> 与 <code>meaasureHeigth</code></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 与上面讲的 onDraw() 一样，也是一个回调，该回调的作用是由 requestLayout() 触发</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> changed 与上次布局相比，是否发生改变</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(                                </span></span><br><span class="hljs-params"><span class="hljs-function">    changed: <span class="hljs-type">Boolean</span>,                                 </span></span><br><span class="hljs-params"><span class="hljs-function">    left: <span class="hljs-type">Int</span>, top: <span class="hljs-type">Int</span>, right: <span class="hljs-type">Int</span>, bottom: <span class="hljs-type">Int</span>      </span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;                                                   <br>    <span class="hljs-keyword">super</span>.onLayout(changed, left, top, right, bottom) <br>&#125;                                                     <br></code></pre></td></tr></table></figure>

<h3 id="主要用法-1"><a href="#主要用法-1" class="headerlink" title="主要用法"></a>主要用法</h3><ul>
<li><p>遍历子 View，再调用 <code>child.layout()</code>，摆放子 View</p>
</li>
<li><p>一般是 ViewGroup 实现</p>
<p>之前提到了 <code>TextView</code> 作为 View 却重写了这个方法，其实它没有干什么，主要是重新设置了文字的位置和大小</p>
<p>为什么需要在这里重写设置呢？</p>
<p>原因：<code>onLayout()</code> 能拿到最终显示的宽度和高度，且一般情况下只会调用一次，所以在有特殊需要时可以在这里面来设置一些东西，比如：一些特殊的自定义 ViewGroup 始终是固定的大小，则可以不用重写 <code>onMeasure()</code>，而是在 <code>onLayout()</code> 中直接给子 View 调用 <code>measure()</code>、<code>layout()</code> 布局</p>
</li>
</ul>
<pre><code class=" mermaid">graph LR
id1(&quot;ViewRootImpl 开始布局&quot;)--&gt;id2
id2[&quot;ViewGroup#layout()&quot;]--&gt;id3
id3[&quot;ViewGroup#onLayout()&quot;]--&gt;id4
id4[&quot;View#layout()&quot;]--&gt;id5(&quot;View#onLayout()&quot;)
</code></pre>


</blockquote>
<h4 id="1、measureWidth-measureHeight-与-width-height"><a href="#1、measureWidth-measureHeight-与-width-height" class="headerlink" title="1、measureWidth (measureHeight) 与 width (height)"></a>1、measureWidth (measureHeight) 与 width (height)</h4><blockquote>
<p><code>measureWidth</code> 代表测量的宽度，其实就是 <code>onMeasure()</code> 中调用 <code>setMeasuredDimension()</code> 设置的宽度</p>
<p><code>width</code> 代表布局后的宽度，是由 <code>layout()</code> 中摆放后通过 <code>right - left</code> 得到的</p>
<p>一般 <code>measureWidth</code> 只用于 <code>layout()</code> 和 <code>onLayout()</code> 中，其他地方不应该使用它</p>
</blockquote>
<h4 id="2、FrameLayout-的-onLayout-源码分析"><a href="#2、FrameLayout-的-onLayout-源码分析" class="headerlink" title="2、FrameLayout 的 onLayout() 源码分析"></a>2、FrameLayout 的 onLayout() 源码分析</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLayout</span><span class="hljs-params">(<span class="hljs-type">boolean</span> changed, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> bottom)</span> &#123;<br>    layoutChildren(left, top, right, bottom, <span class="hljs-literal">false</span> <span class="hljs-comment">/* no force left gravity */</span>);<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">layoutChildren</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> bottom, <span class="hljs-type">boolean</span> forceLeftGravity)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> getChildCount();<br>    <span class="hljs-comment">// 计算子 View 能绘制的边界</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">parentLeft</span> <span class="hljs-operator">=</span> getPaddingLeftWithForeground();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">parentRight</span> <span class="hljs-operator">=</span> right - left - getPaddingRightWithForeground();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">parentTop</span> <span class="hljs-operator">=</span> getPaddingTopWithForeground();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">parentBottom</span> <span class="hljs-operator">=</span> bottom - top - getPaddingBottomWithForeground();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getChildAt(i);<br>        <span class="hljs-comment">// 子 View 为 Gone 时不布局，在自己设计自定义 View 时建议也进行判断</span><br>        <span class="hljs-keyword">if</span> (child.getVisibility() != GONE) &#123;<br>            <span class="hljs-comment">// 取出子 View 身上的 LayoutParams</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (LayoutParams) child.getLayoutParams();<br>            <span class="hljs-comment">// 得到之前测量的宽和高</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> child.getMeasuredWidth();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> child.getMeasuredHeight();<br>            <span class="hljs-type">int</span> childLeft;<br>            <span class="hljs-type">int</span> childTop;<br>            <span class="hljs-comment">// 前面提到的 FrameLayout#LayoutParams</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">gravity</span> <span class="hljs-operator">=</span> lp.gravity;<br>            <span class="hljs-keyword">if</span> (gravity == -<span class="hljs-number">1</span>) &#123;<br>                gravity = DEFAULT_CHILD_GRAVITY;<br>            &#125;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">layoutDirection</span> <span class="hljs-operator">=</span> getLayoutDirection();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">absoluteGravity</span> <span class="hljs-operator">=</span> Gravity.getAbsoluteGravity(gravity, layoutDirection);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">verticalGravity</span> <span class="hljs-operator">=</span> gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;<br>            <span class="hljs-comment">// 下面是根据不同的 gravity 来布局，就是一些简单的计算</span><br>            <span class="hljs-keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;<br>                <span class="hljs-keyword">case</span> Gravity.CENTER_HORIZONTAL:<br>                    childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="hljs-number">2</span> +<br>                    lp.leftMargin - lp.rightMargin;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> Gravity.RIGHT:<br>                    <span class="hljs-keyword">if</span> (!forceLeftGravity) &#123;<br>                        childLeft = parentRight - width - lp.rightMargin;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                <span class="hljs-keyword">case</span> Gravity.LEFT:<br>                <span class="hljs-keyword">default</span>:<br>                    childLeft = parentLeft + lp.leftMargin;<br>            &#125;<br>            <span class="hljs-keyword">switch</span> (verticalGravity) &#123;<br>                <span class="hljs-keyword">case</span> Gravity.TOP:<br>                    childTop = parentTop + lp.topMargin;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> Gravity.CENTER_VERTICAL:<br>                    childTop = parentTop + (parentBottom - parentTop - height) / <span class="hljs-number">2</span> +<br>                    lp.topMargin - lp.bottomMargin;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> Gravity.BOTTOM:<br>                    childTop = parentBottom - height - lp.bottomMargin;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    childTop = parentTop + lp.topMargin;<br>            &#125;<br>            <span class="hljs-comment">// 最后调用 child.layout()</span><br>            child.layout(childLeft, childTop, childLeft + width, childTop + height);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="9、requestLayout"><a href="#9、requestLayout" class="headerlink" title="9、requestLayout()"></a>9、requestLayout()</h3><blockquote>
<p>这东西跟前面的 <code>invalidate()</code> 一样，你们只需要记住以下几点：</p>
<ul>
<li>调用后会在下一帧回调 <code>onMeasure()</code> 和 <code>onMeasure()</code> 进行重新测量和布局</li>
<li>如果你的 View 大小发生改变，它还会调用 <code>onDraw()</code> 进行刷新</li>
</ul>
<p>文章的话，与 <code>invalidate()</code> 的一样：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7017452765672636446">https://juejin.cn/post/7017452765672636446</a></p>
<pre><code class=" mermaid">graph TB
id1(&quot;View&quot;)--&gt;id2
id2[&quot;调用requestLayout()重新布局&quot;]--&gt;id3
id3&#123;&quot;parent == null&quot;&#125;--不为 null--&gt;id4
id4[&quot;告诉父布局有子布局要重布局&quot;]--&gt;id3--为 null--&gt;id5
id5[&quot;传递到了 ViewRootImpl (一个管理布局的类)&quot;]--&gt;id6
id6[&quot;ViewRootImpl 调用 mChoreographer 发送一个 post (一个专门监听屏幕刷新的类)&quot;]-.-&gt;id7
id7[&quot;屏幕刷新了，回调 ViewRootImpl，开始重新走 View 测量和布局流程&quot;]--&gt;id8
id8(&quot;从顶部布局最后回调到 View 的 onMeasure()、onLayout()&quot;)--&gt;id9
id9&#123;&quot;如果宽高改变&quot;&#125;--true--&gt;id10(&quot;调用 onDraw() 回调&quot;)--&gt;id11
id9--false--&gt;id11(&quot;结束&quot;)
</code></pre>


</blockquote>
<h3 id="10、setContentView"><a href="#10、setContentView" class="headerlink" title="10、setContentView"></a>10、setContentView</h3><blockquote>
<p>debug 走起，最后发现它调用了</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323223301814.png" srcset="/img/loading.gif" lazyload alt="image-20220323223301814"></p>
<p>添加布局直接交给了 <code>LayoutInflater</code> 处理，那我们讲解一下 <code>LayoutInflater</code></p>
</blockquote>
<h4 id="1、LayoutInflater"><a href="#1、LayoutInflater" class="headerlink" title="1、LayoutInflater"></a>1、LayoutInflater</h4><blockquote>
<p><code>LayoutInflater</code> 我们常用的就下面这个两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> View <span class="hljs-title function_">inflate</span><span class="hljs-params">(<span class="hljs-meta">@LayoutRes</span> <span class="hljs-type">int</span> resource, <span class="hljs-meta">@Nullable</span> ViewGroup root)</span> &#123;<br>    <span class="hljs-comment">// 可以看到它直接调用了下面那个三个参数的</span><br>	<span class="hljs-keyword">return</span> inflate(resource, root, root != <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resource 布局 id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> root 父布局</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> attachToRoot 是否直接添加到父布局，如果为 true，在解析出 View 后会直接添加到 root 中</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果 attachToRoot 为 true，这返回 root，如果为 false，则返回 xml 中的根布局</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> View <span class="hljs-title function_">inflate</span><span class="hljs-params">(<span class="hljs-meta">@LayoutRes</span> <span class="hljs-type">int</span> resource, <span class="hljs-meta">@Nullable</span> ViewGroup root, <span class="hljs-type">boolean</span> attachToRoot)</span> &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>继续往里面走，其中最主要的代码在这里：</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323224318637.png" srcset="/img/loading.gif" lazyload alt="image-20220323224318637"></p>
<p>上面那个就是之前留下的问题（<a href="#1%E3%80%81LayoutParams">LayoutParams</a>），在 <code>root != null</code> 通过 <code>AttributeSet</code> 得到你自己的 <code>LayoutParmas</code>，然后在 <code>!attchToRoot</code> 时调用 <code>setLayoutParams()</code>，里面会调用 <code>requestLayout()</code>进行重新布局</p>
<p>继续往下面看：</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323230405944.png" srcset="/img/loading.gif" lazyload alt="image-20220323230405944"></p>
<p>这里在 <code>root != null &amp;&amp; attachToRoot</code> 时调用 <code>root.addView()</code>，这就是使用 <code>attachToRoot</code> 的时候</p>
<p>然后在 <code>addView()</code> 里面就调用了之前重写的那两个方法：</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323230713647.png" srcset="/img/loading.gif" lazyload alt="image-20220323230713647"></p>
<p>这就是 <code>LayoutInflater</code> 的简单分析了</p>
<p>之前有学弟问道 <code>LayoutInflater#inflate()</code> 与 <code>View#inflate()</code> 的区别，查看源码你就会发现其实 <code>View#inflate()</code> 就是调用的 <code>LayoutInflater#inflate()</code></p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323231300755.png" srcset="/img/loading.gif" lazyload alt="image-20220323231300755"></p>
<p>还有学弟问过为什么 Rv 的 <code>onCreateView()</code> 使用像下面这样写不行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 其实这个 parent 就是 Rv</span><br>override fun <span class="hljs-title function_">onCreateViewHolder</span><span class="hljs-params">(parent: ViewGroup, viewType: Int)</span>: MyViewHolder &#123;<br>    <span class="hljs-keyword">return</span> MyViewHolder(<br>        <span class="hljs-comment">// 这种写法就是下面这种写法</span><br>        View.inflate(parent.context, R.layout.recycler_item, parent)<br>    )<br>&#125;<br><br>override fun <span class="hljs-title function_">onCreateViewHolder</span><span class="hljs-params">(parent: ViewGroup, viewType: Int)</span>: MyViewHolder &#123;<br>    <span class="hljs-keyword">return</span> MyViewHolder(<br>        LayoutInflater.from(parent.context).inflate(R.layout.recycler_item, parent, <span class="hljs-literal">true</span>)<br>    )<br>&#125;<br><br><span class="hljs-comment">// 上面这两种写法使用后会报错：</span><br><span class="hljs-comment">// java.lang.IllegalStateException: </span><br><span class="hljs-comment">// ViewHolder views must not be attached when created. </span><br><span class="hljs-comment">// Ensure that you are not passing &#x27;true&#x27; to the attachToRoot parameter </span><br><span class="hljs-comment">// of LayoutInflater.inflate(..., boolean attachToRoot)</span><br><span class="hljs-comment">// 意思就是只能在 ViewHolder 开始使用时才能把 View 添加到 parent 中去</span><br></code></pre></td></tr></table></figure>

<p>可能部分有人这样写过，发现 item 的布局无法设置大小，这个问题跟前面讲到的 dialog 根布局宽高失效有点类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">override fun <span class="hljs-title function_">onCreateViewHolder</span><span class="hljs-params">(parent: ViewGroup, viewType: Int)</span>: MyViewHolder &#123;<br>    <span class="hljs-keyword">return</span> MyViewHolder(<br>        <span class="hljs-comment">// 第二个参数传入 null</span><br>        LayoutInflater.from(parent.context).inflate(R.layout.recycler_item, <span class="hljs-literal">null</span>)<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二个参数传入 null 时，按照前面分析的流程，就不会给根布局设置 <code>LayoutParams</code>，那么在 Rv <code>addView()</code>时，会调用 Rv 的 <code>generateDefaultLayoutParams()</code> ，最后调用到 <code>LayoutManger</code> 的 <code>generateDefaultLayoutParams()</code></p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323234144858.png" srcset="/img/loading.gif" lazyload alt="image-20220323234144858"></p>
<p>如果是 <code>LinearLayoutManger</code>，就直接设置成 <code>wrap_content</code> 了，所以在 xml 中写的宽和高根本就没有去读取</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220323234305639.png" srcset="/img/loading.gif" lazyload alt="image-20220323234305639"></p>
</blockquote>
<h3 id="11、发布开源库"><a href="#11、发布开源库" class="headerlink" title="11、发布开源库"></a>11、发布开源库</h3><h4 id="1、创建模块"><a href="#1、创建模块" class="headerlink" title="1、创建模块"></a>1、创建模块</h4><blockquote>
<p>大型项目都会采用多模块开发，每个人只需要负责自己的模块，模块方面的知识我就不讲解了，这里主要是讲解如何创建自定义 View 的模块</p>
<p>首先 new 一个模块</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325141248013.png" srcset="/img/loading.gif" lazyload alt="image-20220325141248013"></p>
<p>然后选着对应的模块</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325141438062.png" srcset="/img/loading.gif" lazyload alt="image-20220325141438062"></p>
<blockquote>
<p>这里简单讲一下：</p>
<p>第一个 <code>Phone &amp; Tablet</code> 也是创建模块，其实与这个 <code>Android Library</code> 主要是在 <code>build.gradle</code> 上的细微不同</p>
<h5 id="1、Phone-amp-Tablet"><a href="#1、Phone-amp-Tablet" class="headerlink" title="1、Phone &amp; Tablet"></a>1、Phone &amp; Tablet</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;com.android.application&#x27;</span><br>&#125;<br><br>android &#123;<br>    defaultConfig &#123;<br>    	applicationId <span class="hljs-string">&quot;com.ndhzs.myapplication&quot;</span><br>    	minSdk <span class="hljs-number">21</span><br>		targetSdk <span class="hljs-number">31</span><br>    	versionCode <span class="hljs-number">1</span><br>	    versionName <span class="hljs-string">&quot;1.0&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2、Android-Library"><a href="#2、Android-Library" class="headerlink" title="2、Android Library"></a>2、Android Library</h5><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;com.android.library&#x27;</span><br>&#125;<br><br>android &#123;<br>    defaultConfig &#123;<br>    	minSdk <span class="hljs-number">21</span><br>		targetSdk <span class="hljs-number">31</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不同之处主要就是上面两处，其他还有 <code>AndroidManifest.xml</code> 都是差不多的</p>
</blockquote>
<p>创建好的模块会少 res 文件夹，自己新建即可，其他地方用法就跟平常写法都一样</p>
<p>在你的 app 模块中使用下面这种写法就可以刚建的模块</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>	implementation project(<span class="hljs-string">&#x27;:lib&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>模块下也是允许再建子模块的，模块化需要学习 gradle 相关的知识，等你们进来接手掌邮了多看几个模块就无师自通了（透漏一下新消息，目前强神还在更新整个掌邮的 gradle，已经重构为 kts 了，估计等你们进来就可以体验协程了）</p>
</blockquote>
<h4 id="2、发布到-jitPack"><a href="#2、发布到-jitPack" class="headerlink" title="2、发布到 jitPack"></a>2、发布到 jitPack</h4><blockquote>
<p>很多时候发布到开源库方便我们在其他项目中引用，接下来我们将讲解如何发布到 <code>jitPack</code>，为什么不发布到 <code>Maven Central</code>，因为 <code>Maven Central</code> 要申请文件，很麻烦，而 <code>jitPack</code> 直接傻瓜式操作一步到位</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 在 lib 的 build.gradle 中</span><br>plugins &#123;<br>	id <span class="hljs-string">&#x27;maven-publish&#x27;</span><br>&#125;<br><br>android &#123;<br>	publishing &#123;<br>		singleVariant <span class="hljs-string">&quot;release&quot;</span><br>	&#125;<br>&#125;<br><br>afterEvaluate &#123;<br>	publishing &#123;<br>		publications &#123;<br>			release(MavenPublication) &#123;<br>				from components.release<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意是在 lib 的 build.gradle 中，不是在 app 的 build.gradle</strong></p>
<blockquote>
<p><strong>这里是原因的讲解，不想看的话可以跳过</strong></p>
<p>这是我摸索出来的<strong>最新教程</strong>，如果你去那些看那些博客，全是过时教程，这里给出摸索的过程：</p>
<ul>
<li><p>发布开源库的教程先根据 <code>jitPack</code> 官网来：<a target="_blank" rel="noopener" href="https://docs.jitpack.io/android/">https://docs.jitpack.io/android/</a></p>
</li>
<li><p>然后看它官网给出的源码示例：<a target="_blank" rel="noopener" href="https://github.com/jitpack/android-example/blob/master/library/build.gradle">https://github.com/jitpack/android-example/blob/master/library/build.gradle</a></p>
</li>
<li><p>再参考谷歌给的示例：<a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/build/maven-publish-plugin">https://developer.android.google.cn/studio/build/maven-publish-plugin</a></p>
</li>
<li><p>最后看看 gradle 官网每个方法的意思：</p>
<p><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:tasks">https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:tasks</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html#org.gradle.api.publish.maven.MavenPublication">https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html#org.gradle.api.publish.maven.MavenPublication</a></p>
</li>
</ul>
<p>这样基本上能实现了，但在打包时会报一个警告：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">WARNING:Software Components will <span class="hljs-keyword">not</span> be created automatically <span class="hljs-keyword">for</span> Maven publishing <span class="hljs-keyword">from</span> Android Gradle Plugin <span class="hljs-number">8.0</span>. <span class="hljs-keyword">To</span> opt-<span class="hljs-keyword">in</span> <span class="hljs-keyword">to</span> the <span class="hljs-keyword">future</span> behavior, <span class="hljs-keyword">set</span> the Gradle <span class="hljs-keyword">property</span> <br></code></pre></td></tr></table></figure>

<p>最后上 stackoverflow 寻找（因为其他地方找不到）：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/71365373/software-components-will-not-be-created-automatically-for-maven-publishing-from">https://stackoverflow.com/questions/71365373/software-components-will-not-be-created-automatically-for-maven-publishing-from</a></p>
<p>最最后在谷歌找到方法：</p>
<p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/publish-library/configure-pub-variants">https://developer.android.google.cn/studio/publish-library/configure-pub-variants</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/tools/gradle-api/7.1/com/android/build/api/dsl/LibraryPublishing">https://developer.android.google.cn/reference/tools/gradle-api/7.1/com/android/build/api/dsl/LibraryPublishing</a></p>
<p>这里简单讲一下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>	publishing &#123;<br>         <span class="hljs-comment">// 这个是会自动创建下面 publications 中的同名方法</span><br>		singleVariant <span class="hljs-string">&quot;release&quot;</span><br><br>         <span class="hljs-comment">// 比如这个就是下面那个 myRelease(MavenPublication)</span><br>         <span class="hljs-comment">// singleVariant &quot;myRelease&quot;</span><br>	&#125;<br><br>    <span class="hljs-comment">// 这是官方默认自带的东西，就与对不同的包定义不同的设置</span><br>    buildTypes &#123;<br>        release &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br>afterEvaluate &#123;<br>	publishing &#123;<br>		publications &#123;<br>			release(MavenPublication) &#123;<br>                 <span class="hljs-comment">// 这个 components.release 中的 release 是 buildTypes 中的 release</span><br>				from components.release<br>			&#125;<br><br>             <span class="hljs-comment">// 这里这个 myRelease 就对应于上面写的那个 singleVariant &quot;myRelease&quot;</span><br>             <span class="hljs-comment">// myRelease(MavenPublication) &#123;</span><br>			<span class="hljs-comment">//     from components.release</span><br>			<span class="hljs-comment">// &#125;</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果实在看不懂的话就直接按照刚开始给出的抄上去即可，毕竟看懂需要有一定的 gradle 基础</p>
</blockquote>
<p>然后在 github 上发一个 Releases</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325133455931.png" srcset="/img/loading.gif" lazyload alt="image-20220325133455931"></p>
<p>Release 发布好了后，打开 <code>jitPack</code> </p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325133728477.png" srcset="/img/loading.gif" lazyload alt="image-20220325133728477"></p>
<p>这样一个正式包就成功发布出去了，引入的话下面有教程</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325134213260.png" srcset="/img/loading.gif" lazyload alt="image-20220325134213260"></p>
<blockquote>
<p>小插曲：由于 gradle 到 7.0.0 版本以后，引入改位置了</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 在 settings.gradle 里</span><br>dependencyResolutionManagement &#123;<br> repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)<br> repositories &#123;<br>     google()<br>     mavenCentral()<br>     maven &#123; url = <span class="hljs-string">&quot;https://jitpack.io&quot;</span> &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>如果是自己平时开发中用到，每次都发 Releases 显得过于麻烦，<code>jitPack</code> 可以发布快照版本，何为快照，看完下面的教程你就懂了</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325135853586.png" srcset="/img/loading.gif" lazyload alt="image-20220325135853586"></p>
<p>你会发现下面给出的引入写法没有带版本号</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325135808864.png" srcset="/img/loading.gif" lazyload alt="image-20220325135808864"></p>
<p>这个 <code>SNAPSHOP</code> 就是快照的标识，带有快照的版本号在 build 时会自动去检查是否是最新版，以后只需要提交到 main 分支，然后发个快照版本就可以升级了</p>
<p>只有自己使用时更推荐发布快照</p>
</blockquote>
<h4 id="3、发布到阿里的-Maven"><a href="#3、发布到阿里的-Maven" class="headerlink" title="3、发布到阿里的 Maven"></a>3、发布到阿里的 Maven</h4><blockquote>
<p>就在要上课的昨天，艾神来问我怎么发布阿里的 Maven，他掉进坑里卡了一个晚上，于是我去试着解决了一下</p>
<p>果然够坑的，因为 gradle 升到 7.0.0 以后把一个插件给移除了，而阿里官网和其他教程都是过时的，花了一些时间才搞出来，这里就直接给最新的操作教程</p>
<p>首先，去阿里官网注册一下（好像是免费的）：<a target="_blank" rel="noopener" href="https://packages.aliyun.com/maven">https://packages.aliyun.com/maven</a></p>
<p>注册过后，他会给你两个仓库：</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326231305660.png" srcset="/img/loading.gif" lazyload alt="image-20220326231305660"></p>
<p>一个是用于发布稳定版的库，一个是发布快照版的库，上面 <code>jitPack</code> 中也介绍了快照</p>
<p>然后找到这个指南界面</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326231921252.png" srcset="/img/loading.gif" lazyload alt="image-20220326231921252"></p>
<p>这里面有一些基础设置，但这教程过时了，下面我给出最新的写法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// settings.gradle</span><br>dependencyResolutionManagement &#123;<br>    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)<br>    repositories &#123;<br>        google()<br>        mavenCentral()<br>        <span class="hljs-comment">// 这里添加阿里 maven 的仓库地址</span><br>        maven &#123;<br>            url <span class="hljs-string">&#x27;https://maven.aliyun.com/repository/public&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 这是单独写的一个 maven.gradle</span><br><br><span class="hljs-comment">// gradle 7之前使用的 maven 插件，7之后只能使用 maven-publish 了</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;maven-publish&#x27;</span><br><span class="hljs-comment">// 这个是引用我的密码等私密文件，建议把这些单独放在一个文件夹里，并在.gitignore上添加它</span><br>apply <span class="hljs-attr">from:</span> <span class="hljs-string">&quot;$&#123;rootDir&#125;/secret.gradle&quot;</span><br><br>afterEvaluate &#123;<br>    publishing &#123;<br>        publications &#123;<br>            release(MavenPublication) &#123;<br>                from components.release<br>                <span class="hljs-comment">// 版本号，如果末尾加上 -SNAPSHOT 说明是快照版本</span><br>                version = <span class="hljs-string">&#x27;0.0.1-SNAPSHOT&#x27;</span><br>                <span class="hljs-comment">// 项目名称，通常为类库模块名称，也可以任意设置</span><br>                artifactId = <span class="hljs-string">&#x27;example&#x27;</span><br>                <span class="hljs-comment">// 唯一标识，通常为模块包名，也可以任意设置</span><br>                groupId = <span class="hljs-string">&#x27;com.985892345&#x27;</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 这下面的 aliMavenUsername、aliMavenPassword、releaseUrl、snapshotUrl</span><br>        <span class="hljs-comment">// 对应你自己的，在阿里官网那个指南里有</span><br>        repositories &#123;<br>            maven &#123;<br>                credentials &#123;<br>                    username aliMavenUsername<br>                    password aliMavenPassword<br>                &#125;<br>                url releaseUrl<br>            &#125;<br>            maven &#123;<br>                credentials &#123;<br>                    username aliMavenUsername<br>                    password aliMavenPassword<br>                &#125;<br>                url snapshotUrl<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// secret.gradle</span><br><span class="hljs-comment">// 这个没学过 gradle 的话可能看不懂，这里不会讲解，你只管这样写就可以</span><br>ext.aliMavenUsername = <span class="hljs-string">&quot;你的账号&quot;</span><br>ext.aliMavenPassword = <span class="hljs-string">&quot;你的密码&quot;</span><br>ext.releaseUrl = <span class="hljs-string">&quot;你的稳定版本发布地址&quot;</span><br>ext.snapshotUrl = <span class="hljs-string">&quot;你的快照版本发布地址&quot;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// 在你要发布的项目里的 build.gradle</span><br>apply <span class="hljs-attr">from:</span> <span class="hljs-string">&quot;maven.gradle&quot;</span><br><br>android &#123;<br>    <span class="hljs-comment">// 这个东西在之前 jitPack 讲过，这里就不再讲了</span><br>    publishing &#123;<br>        singleVariant <span class="hljs-string">&quot;release&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong>通常你要发布的项目是一个 <code>library</code>，而不是一个 <code>application</code>，因为一般 <code>library</code> 才是给别人使用的，而 <code>application</code> 是一个项目的入口，通常来依赖 <code>library</code></p>
<p>OK，这样就配置完了，刷新一下 gradle，再点击右上角的 gradle 标志</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326234300251.png" srcset="/img/loading.gif" lazyload alt="image-20220326234300251"></p>
<p>点击这个就可以直接运行发布到 maven 的 task</p>
<img src="D:/Typora/img/image-20220326234410761.png" srcset="/img/loading.gif" lazyload alt="image-20220326234410761" style="zoom: 67%;" />

<blockquote>
<p>可能你们有些人找不到这个选项，因为新版的 AS 把这个默认关闭了，我也搞不懂为啥，为了让大家使用命令行运行任务？</p>
<p>在这里进行设置，就能看得到了</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220326234634838.png" srcset="/img/loading.gif" lazyload alt="image-20220326234634838"></p>
</blockquote>
</blockquote>
<h3 id="12、分享一些东西"><a href="#12、分享一些东西" class="headerlink" title="12、分享一些东西"></a>12、分享一些东西</h3><h4 id="1、Material-Design-官网"><a href="#1、Material-Design-官网" class="headerlink" title="1、Material Design 官网"></a>1、Material Design 官网</h4><blockquote>
<p>谁想写自定义 View 啊，你想写吗？正经人写什么自定义 View。</p>
<p>自定义 View 确实很难，东西又多又杂，在考虑写自定义 View 之前，请先搜索一下是否有别人已经造好的轮子，有轮子直接用，他不香吗？[狗头]，Material Design 官网就包含许多官方轮子</p>
<p>官网链接：<a target="_blank" rel="noopener" href="https://material.io/">https://material.io/</a></p>
<p>源码地址：<a target="_blank" rel="noopener" href="https://github.com/material-components/material-components-android">https://github.com/material-components/material-components-android</a></p>
<p>示例下载：<a target="_blank" rel="noopener" href="https://github.com/material-components/material-components-android/releases">https://github.com/material-components/material-components-android/releases</a></p>
<p>这里面的都算官方控件，而且有很多，如果想实现某个功能时可以去看看是否已经有实现了的，他还专门写了一个实例 app，可以下下来看看，找到想要的再去看他的源码</p>
</blockquote>
<h4 id="2、MotionLayout"><a href="#2、MotionLayout" class="headerlink" title="2、MotionLayout"></a>2、MotionLayout</h4><blockquote>
<p>这东西我都还没怎么深入学习，可以去看看掘金上的一些教程，这里我就不讲了 ）</p>
<p>官网：<a target="_blank" rel="noopener" href="https://developer.android.google.cn/training/constraint-layout/motionlayout/examples?hl=zh_cn">https://developer.android.google.cn/training/constraint-layout/motionlayout/examples?hl=zh_cn</a></p>
</blockquote>
<h4 id="2、View-post-、posyDelay-、postOnAnimation"><a href="#2、View-post-、posyDelay-、postOnAnimation" class="headerlink" title="2、View#post()、posyDelay()、postOnAnimation()"></a>2、View#post()、posyDelay()、postOnAnimation()</h4><blockquote>
<h5 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h5><p>如何在 <code>onCreate()</code> 中得到 View 的宽和高？</p>
<p>哈哈，这不是有手就行？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>	<span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>	setContentView(com.ndhzs.lib.R.layout.layout_section7)<br>        <br>	<span class="hljs-keyword">val</span> view = findViewById&lt;View&gt;(com.ndhzs.lib.R.id.myView7)<br>	<span class="hljs-keyword">val</span> width = view.width<br>	<span class="hljs-keyword">val</span> height = view.height<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后面试官笑了笑，你就被刷了</p>
<p>原因：这种写法得到的宽和高结果是 0</p>
<p>为什么呢？</p>
<p>因为前面我们讲到，<code>View#width</code> 和 <code>View#height</code> 是在 <code>onLayout()</code> 中设置的，而 <code>onCreate()</code> 此时还没有开始布局，只是调用了 <code>setContentView()</code> 加载了布局，三大流程还没有开始走，真正开始走三大流程是在 <code>onResume()</code> 后，这里提供下面几种正确方法：</p>
<blockquote>
<h5 id="1、post"><a href="#1、post" class="headerlink" title="1、post()"></a>1、post()</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> view = findViewById&lt;View&gt;(com.ndhzs.lib.R.id.myView7)<br>view.post &#123;<br>    <span class="hljs-keyword">val</span> width = view.width<br>    <span class="hljs-keyword">val</span> height = view.height<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原理：post 是用 Handler 发一个 Message，而 View 对于自带的 post 做了特殊处理，只会在 View 被测量后才开始发 Message</p>
<h5 id="2、doOnLayout"><a href="#2、doOnLayout" class="headerlink" title="2、doOnLayout"></a>2、doOnLayout</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> view = findViewById&lt;View&gt;(com.ndhzs.lib.R.id.myView7)<br>view.doOnLayout &#123;<br>    <span class="hljs-keyword">val</span> width = view.width<br>    <span class="hljs-keyword">val</span> height = view.height<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原理：使用 View 的一个 <code>addOnLayoutChangeListener()</code> 方法，监听 View 的 <code>onLayout()</code> 回调</p>
</blockquote>
<h5 id="再来个面试题："><a href="#再来个面试题：" class="headerlink" title="再来个面试题："></a>再来个面试题：</h5><p>View 的 <code>post()</code> 原理是什么？<code>postDelayed()</code> 会造成内存泄漏吗？如果会该怎么处理？</p>
<p>答案：</p>
<p>1、View 的 <code>post()</code> 在没有添加到屏幕前会先保存 Runnable 在第一次 <code>performTraversals</code> 到来时执行，如果已经添加屏幕上，就直接交给 <code>mAttachInfo</code> 的 <code>mHanlder</code> 执行，至于这个 <code>mHandler</code>，是 <code>ViewRootImpl</code> 持有的一个 <code>ViewRootHandler</code> 对象</p>
<p>2、<code>postDelayed()</code> 会造成内存泄漏，因为它没主动删除你发送的 Runnable（其实 <code>post()</code> 理论上也会造成内存泄漏，但因为时间极短，约等于不泄漏）</p>
<p>3、处理的话，可以在重写 View 的 <code>onDetachedFromWindow()</code> 方法主动取消，或者封装一下成单独的一个类，使用 <code>addOnAttachStateChangeListener()</code> 专门来发 <code>postDelayed()</code></p>
<blockquote>
<p>如果面试官真的刁难你，可能还会问 <code>View#post()</code> 在不同版本上的实现 (</p>
<p>这个你们自己看文章吧：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903521804877832">https://juejin.cn/post/6844903521804877832</a></p>
<p>还有如何检测内存泄漏，这个还是得提一下，不然不提的话，可能都不会有人知道</p>
<p>直接使用：LeakCanary  <a target="_blank" rel="noopener" href="https://github.com/square/leakcanary">https://github.com/square/leakcanary</a></p>
<p>用法很简单，只需一行代码即可</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>  <span class="hljs-comment">// debugImplementation because LeakCanary should only run in debug builds.</span><br>  debugImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-android:xxx&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后它会自己生成一个多余的图标，在你应用出现内存泄漏时弹窗提醒</p>
<p><img src="https://img-1307243988.cos.ap-chengdu.myqcloud.com/typora/image-20220325155039418.png" srcset="/img/loading.gif" lazyload alt="image-20220325155039418"></p>
<p>内存泄露也是面试的点（</p>
</blockquote>
<h5 id="最后一个面试题"><a href="#最后一个面试题" class="headerlink" title="最后一个面试题"></a>最后一个面试题</h5><p><code>postOnAnimation()</code> 是什么？通常用于什么时候？</p>
<p>不要被 Animation 迷惑了，认为这个是用来发送动画的，如果要讲这个，我们先从官方常用的一个方法讲起，如果你经常看官方控件源码，你会发现下面这个东西常出现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ViewCompat.postOnAnimation()<br></code></pre></td></tr></table></figure>

<p>如果你去看一遍它的注释，就很容易理解了，就是将 Runnable 在手机的下一帧执行（前面说过刷新率 60 的手机每帧相隔 16 毫秒），而这个方法内部在 SDK 16 及以上就是调用的 <code>View#postOnAnimation()</code></p>
<p>那这个方法的使用场景如何呢？</p>
<p>它常用于代替 <code>ValueAnimator</code> 动画（<code>ValueAnimator</code> 这类动画与 <code>View#postOnAnimation()</code> 内部实现是一样的），比如在 Rv 的惯性滑动中就会用到这个 <code>ViewCompat.postOnAnimation()</code>（下次事件分发时才讲）</p>
<p>所以你会经常看见这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">mRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// ......</span><br>		ViewCompat.postOnAnimation(View.<span class="hljs-built_in">this</span>, <span class="hljs-built_in">this</span>)<br>         <span class="hljs-comment">// 平时开发可以直接使用 View.postOnAnimation(View.this, this)</span><br>	&#125;<br>&#125;<br><span class="hljs-comment">// 这样就形成了一种隐式的递归，在每次屏幕刷新时调用 run()</span><br></code></pre></td></tr></table></figure>


</blockquote>
<h4 id="3、View-的生命周期"><a href="#3、View-的生命周期" class="headerlink" title="3、View 的生命周期"></a>3、View 的生命周期</h4><blockquote>
<p>View 也有什么周期，但 View 的生命周期很不完善</p>
<pre><code class=" mermaid">graph TB
id1(&quot;构造函数（对应 onCreate()）&quot;)--&gt;id2
id2[&quot;onFinishInflate()（对应 onCreate() 中的 setContentView()）&quot;]--&gt;id3
id3[&quot;onAttachedToWindow()&quot;]--&gt;id4
id4[&quot;onWindowVisbilityChanged()&quot;]--&gt;id5
id5[&quot;onMeasure()&quot;]--&gt;id6
id6[&quot;onLayout()&quot;]--&gt;id7
id7[&quot;onDraw()&quot;]--&gt;id8
id8[&quot;onWindowFocusChanged()&quot;]--&gt;id9
id9[&quot;onWindowVisibilityChanged()&quot;]--&gt;id10
id10[&quot;onDetachedFromWindow()&quot;]
</code></pre>

<h5 id="onFinishInflate"><a href="#onFinishInflate" class="headerlink" title="onFinishInflate()"></a>onFinishInflate()</h5><p> 从 xml 中完全加载完时的回调</p>
<h5 id="onAttachedToWindow"><a href="#onAttachedToWindow" class="headerlink" title="onAttachedToWindow()"></a>onAttachedToWindow()</h5><p>开始显示在屏幕上时的回调</p>
<h5 id="onWindowVisbilityChanged"><a href="#onWindowVisbilityChanged" class="headerlink" title="onWindowVisbilityChanged()"></a>onWindowVisbilityChanged()</h5><p>窗口可见性改变的回调</p>
<h5 id="onWindowFocusChanged"><a href="#onWindowFocusChanged" class="headerlink" title="onWindowFocusChanged()"></a>onWindowFocusChanged()</h5><p>窗口获取焦点时的回调</p>
<h5 id="onDetachedFromWindow"><a href="#onDetachedFromWindow" class="headerlink" title="onDetachedFromWindow()"></a>onDetachedFromWindow()</h5><p>View 不显示在屏幕上时的回调</p>
<p>其他的看看这篇文章吧：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0a4cb44ce9d1">https://www.jianshu.com/p/0a4cb44ce9d1</a></p>
<p>可以看到其实 View 的生命周期不是很完善，甚至连自身什么时候被添加进 ViewGroup 都没有方法回调，remove 也是一样，但如果想实现 addView 和 removeView 监听的话，查看源码后发现只能使用 <code>ViewGroup#setOnHierarchyChangeListener()</code>，意思是在 View 中通过给 parent 设置监听，但这个有个缺点，就是只能设置一次监听</p>
</blockquote>
<h4 id="4、自定义-View-的一些规范"><a href="#4、自定义-View-的一些规范" class="headerlink" title="4、自定义 View 的一些规范"></a>4、自定义 View 的一些规范</h4><blockquote>
<ul>
<li>应该尽量解耦，View 里面不建议包含 <code>网络请求</code>、<code>Rxjavaj</code>、<code>EventBus</code>、<code>Lifecycle 相关组件</code> 等，这些应该是主语应用层使用的，而不是在 View 里面使用，View 里面应该尽量使用 MVC 的模式来写</li>
<li>可以分离一些职责出来，比如课表我就把事件和绘制通过设置监听的方式来分离，这样可以方便扩展，而不是全部塞在 View 里面</li>
</ul>
<h5 id="分离-Draw-事件"><a href="#分离-Draw-事件" class="headerlink" title="分离 Draw 事件"></a>分离 Draw 事件</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 自定义绘图的监听</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mItemDecoration = ArrayList&lt;ItemDecoration&gt;(<span class="hljs-number">5</span>)<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>)</span></span> &#123;<br>    mItemDecoration.forEach &#123;<br>        it.onDrawBelow(canvas, <span class="hljs-keyword">this</span>)<br>    &#125;<br>    <span class="hljs-keyword">super</span>.dispatchDraw(canvas)<br>    mItemDecoration.forEach &#123;<br>        it.onDrawAbove(canvas, <span class="hljs-keyword">this</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该类主要用于实现一些简单的绘图处理</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 经过我的思考，我认为不应该提供删除的方法，原因如下：</span><br><span class="hljs-comment"> * - 一般不会有需要中途删除的情况</span><br><span class="hljs-comment"> * - 很容易出现事件在遍历中就把它删除，导致出现遍历越位的错误</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 设计参考了 RV 的 ItemDecoration</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 985892345 (Guo Xiangrui)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@email</span> 2767465918<span class="hljs-doctag">@qq</span>.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/1/27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ItemDecoration</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在所有子 View 的 onDraw() 前的回调，在这里面绘图可以绘制在子 View 下方</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDrawBelow</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>, view: <span class="hljs-type">View</span>)</span></span> &#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在所有子 View 的 onDraw() 后的回调，在这里面绘图可以绘制在子 View 上方</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDrawAbove</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>, view: <span class="hljs-type">View</span>)</span></span> &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还有分离事件分发，我就留到下次课来讲了</p>
</blockquote>
<h4 id="5、布局调试软件"><a href="#5、布局调试软件" class="headerlink" title="5、布局调试软件"></a>5、布局调试软件</h4><blockquote>
<p>Android 调试利器 Pandora</p>
<p>一个很牛逼的 debug 工具，可以在手机上查看布局属性、网络请求、sp 等很多东西</p>
<p><a target="_blank" rel="noopener" href="https://www.wanandroid.com/blog/show/2183">https://www.wanandroid.com/blog/show/2183</a></p>
</blockquote>
<h4 id="6、Rv-怎么得到某个-item-的实例"><a href="#6、Rv-怎么得到某个-item-的实例" class="headerlink" title="6、Rv 怎么得到某个 item  的实例"></a>6、Rv 怎么得到某个 item  的实例</h4><blockquote>
<p>这不算自定义 View 的内容，因为寒假时有很多学弟遇到了这个问题，我这里讲解一下吧</p>
<p>得到里面的 item 更建议使用在不需要保持状态的情况下，比如某个 item 的变动需要加载动画，那就可以使用这种方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RvAdapter</span> : <span class="hljs-type">RecyclerView.Adapter</span>&lt;<span class="hljs-type">RvAdapter.RvVH</span>&gt;() &#123;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RvVH</span>(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;<br>     <span class="hljs-keyword">val</span> mAnimationView: AnimationView = itemView.findViewById(R.id.item_animation)<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getVHolder</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>, call: <span class="hljs-type">VHolderCallback</span>)</span></span> &#123;<br>     <span class="hljs-comment">// 调用两个参数的这个刷新</span><br>     notifyItemChanged(position, call)<br> &#125;<br><br> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">     parent: <span class="hljs-type">ViewGroup</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">     viewType: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function"> )</span></span>: RvVH &#123;<br>     <span class="hljs-keyword">return</span> RvVH(<br>         LayoutInflater<br>         	.from(parent.context)<br>         	.inflate(R.layout.layout_item, parent, <span class="hljs-literal">false</span>)<br>     )<br> &#125;<br><br> <span class="hljs-comment">// 重写三个参数的这个方法</span><br> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">     holder: <span class="hljs-type">RvVH</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">     position: <span class="hljs-type">Int</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">     payloads: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">Any</span>&gt;</span></span><br><span class="hljs-params"><span class="hljs-function"> )</span></span> &#123;<br>     <span class="hljs-keyword">if</span> (payloads.isEmpty()) &#123;<br>         <span class="hljs-keyword">super</span>.onBindViewHolder(holder, position, payloads)<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// 这里得到 payloads 就是之前刷新传入的回调</span><br>         <span class="hljs-comment">// 因为是在下一帧才会刷新，期间可能会调用多次刷新 item，所以是一个 List</span><br>         payloads.forEach &#123;<br>             <span class="hljs-keyword">if</span> (it <span class="hljs-keyword">is</span> VHolderCallback) &#123;<br>                 it.call(holder)<br>             &#125;<br>         &#125;<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">RvVH</span>, position: <span class="hljs-type">Int</span>)</span></span> &#123;<br> &#125;<br><br> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-number">100</span><br><br> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-keyword">interface</span> VHolderCallback &#123;</span><br>     <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">call</span><span class="hljs-params">(holder: <span class="hljs-type">RvVH</span>)</span></span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用方式就是调用 <code>getVHolder()</code> 就可以了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">getVHolder(<span class="hljs-number">1</span>) &#123;<br> <span class="hljs-comment">// 开始动画</span><br> it.mAnimationView.startAnim()<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><p>这种方法在回调时不能进行延迟保存返回的 holder 对象，因为它只是目前状态下的 holder，不能保证刷新后仍是这个</p>
</li>
<li><p>这里面对 View 的设置都是暂时的，所以最开始我就说了用来调用一下动画才能使用这种方法，如果想永久保存建议：</p>
<ul>
<li>改变传入 Rv 的数据集合，</li>
<li>或者调用 <code>ViewHolder#setIsRecyclable(false)</code>，但要记得在之后还原，不然这个 ViewHolder 就不会被回收</li>
</ul>
</li>
<li><p>这种情况下会失效：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">getVHolder(<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 开始动画</span><br>    it.setIsRecyclable(<span class="hljs-literal">false</span>)<br>    it.mAnimationView.startAnim()<br>&#125;<br><span class="hljs-comment">// 后面调用这个进行普通刷新，只要出现了这个，前面的特殊刷新都会失效</span><br>notifyItemChanged(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li>
</ul>
<p>对于差分刷新也有一个与 payload 相关的方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这个是 ItemCallback，但与 DiffUtil.Callback 是差不多的</span><br><span class="hljs-keyword">object</span> : DiffUtil.ItemCallback&lt;ICourseVpBean&gt;() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">areItemsTheSame</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        oldItem: <span class="hljs-type">ICourseVpBean</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        newItem: <span class="hljs-type">ICourseVpBean</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> oldItem.week == newItem.week<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">areContentsTheSame</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        oldItem: <span class="hljs-type">ICourseVpBean</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        newItem: <span class="hljs-type">ICourseVpBean</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> oldItem == newItem<br>    &#125;<br><br>    <span class="hljs-comment">// 就这个方法，建议重写并不返回</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getChangePayload</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        oldItem: <span class="hljs-type">ICourseVpBean</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">        newItem: <span class="hljs-type">ICourseVpBean</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: Any &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// 只要不为 null 就可以在刷新时去掉与缓存的互换，减少性能的消耗</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="二、动画"><a href="#二、动画" class="headerlink" title="二、动画"></a>二、动画</h2><blockquote>
<p>动画这东西建议看《Android自定义控件开发入门与实战》和下面这网址，我这里就不进行讲解了</p>
<p><a target="_blank" rel="noopener" href="https://qijian.blog.csdn.net/article/details/50995268">https://qijian.blog.csdn.net/article/details/50995268</a></p>
<p>本节课主要讲元素共享动画</p>
<p>因为时间关系写不了了（这课件确实把我写累了），这里给出一些网址：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903727015395336">https://juejin.cn/post/6844903727015395336</a></p>
<blockquote>
<p>这个主要写了 activity 之间的元素共享，例子较全</p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29425853/article/details/53104919">https://blog.csdn.net/qq_29425853/article/details/53104919</a></p>
</li>
</ul>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Android/">#Android</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>View相关</div>
      <div>http://example.com/2022/08/08/自定义View/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>August 8, 2022</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/11/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="Android性能优化">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android性能优化</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/14/Gilde%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="Glide深入分析">
                        <span class="hidden-mobile">Glide深入分析</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
