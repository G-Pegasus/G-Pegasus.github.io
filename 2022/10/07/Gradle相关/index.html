

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="Part1 —— Gradle源码分析gradlew.bat文件那么首先第一个问题，gradle的入口在哪，我想对于这个命令应该都非常熟悉吧 12.&#x2F;gradlew build.&#x2F;gradlew sometaskname   所以应该也能猜得出 gradle  的入口应该是你工程目录下的 gradlew 和 gradlew.bat 文件，二者其实是一样的，只不过gradlew为Linux下的she">
<meta property="og:type" content="article">
<meta property="og:title" content="深入学习Gradle">
<meta property="og:url" content="http://example.com/2022/10/07/Gradle%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Part1 —— Gradle源码分析gradlew.bat文件那么首先第一个问题，gradle的入口在哪，我想对于这个命令应该都非常熟悉吧 12.&#x2F;gradlew build.&#x2F;gradlew sometaskname   所以应该也能猜得出 gradle  的入口应该是你工程目录下的 gradlew 和 gradlew.bat 文件，二者其实是一样的，只不过gradlew为Linux下的she">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719230935335.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719231746422.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719232222552.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719232512044.png">
<meta property="og:image" content="c:\Users\ysh\AppData\Roaming\Typora\typora-user-images\image-20220719233724220.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719233125245.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719233349671.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720002026622.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720002058485.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720002413236.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720004531828.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720151852905.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720151929613.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720153955796.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720160448825.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720165503139.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720170002146.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723185246052.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723185722302.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723204554548.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723204634192.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723205026378.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723205248572.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723205346273.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723205414219.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723205619019.png">
<meta property="og:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723214008137.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/10107787-39def5ca3adb114d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/877/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/10107787-9a363839b0d3b328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/10107787-c2e886fa45923c55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/784/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/10107787-f1855a3d63d32d5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="article:published_time" content="2022-10-07T06:31:33.000Z">
<meta property="article:modified_time" content="2022-10-20T00:59:41.621Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719230935335.png">
  
  
  
  <title>深入学习Gradle - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入学习Gradle"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-07 14:31" pubdate>
          October 7, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          74k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          617 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">深入学习Gradle</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Part1-——-Gradle源码分析"><a href="#Part1-——-Gradle源码分析" class="headerlink" title="Part1 —— Gradle源码分析"></a>Part1 —— Gradle源码分析</h1><h2 id="gradlew-bat文件"><a href="#gradlew-bat文件" class="headerlink" title="gradlew.bat文件"></a>gradlew.bat文件</h2><p>那么首先第一个问题，gradle的入口在哪，我想对于这个命令应该都非常熟悉吧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./gradlew build<br>./gradlew sometaskname<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719230935335.png" srcset="/img/loading.gif" lazyload alt="image-20220719230935335"></p>
<p>所以应该也能猜得出 gradle  的入口应该是你工程目录下的 gradlew 和 gradlew.bat 文件，二者其实是一样的，只不过gradlew为Linux下的shell脚本,<em>gradlew.bat</em>是Windows下的批处理文件，而我是windows系统，所以打开 gradlew.bat 文件</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bat">...<br><br><span class="hljs-built_in">set</span> APP_BASE_NAME=%~n0<br><span class="hljs-built_in">set</span> APP_HOME=<span class="hljs-variable">%DIRNAME%</span><br><br><span class="hljs-built_in">set</span> DEFAULT_JVM_OPTS=&quot;-Xmx64m&quot; &quot;-Xms64m&quot;<br><br>:findJavaFromJavaHome<br><span class="hljs-built_in">set</span> JAVA_HOME=<span class="hljs-variable">%JAVA_HOME:&quot;=%</span><br><span class="hljs-built_in">set</span> JAVA_EXE=<span class="hljs-variable">%JAVA_HOME%</span>/bin/java.exe<br><br><span class="hljs-built_in">set</span> CLASSPATH=<span class="hljs-variable">%APP_HOME%</span>\gradle\wrapper\gradle-wrapper.jar<br><span class="hljs-comment"></span><br><span class="hljs-comment">@rem Execute Gradle</span><br>&quot;<span class="hljs-variable">%JAVA_EXE%</span>&quot; <span class="hljs-variable">%DEFAULT_JVM_OPTS%</span> <span class="hljs-variable">%JAVA_OPTS%</span> <span class="hljs-variable">%GRADLE_OPTS%</span> &quot;-Dorg.gradle.appname=<span class="hljs-variable">%APP_BASE_NAME%</span>&quot; -classpath &quot;<span class="hljs-variable">%CLASSPATH%</span>&quot; org.gradle.wrapper.GradleWrapperMain %*<br><br><span class="hljs-built_in">echo</span> &quot;<span class="hljs-variable">%JAVA_EXE%</span>&quot; <span class="hljs-variable">%DEFAULT_JVM_OPTS%</span> <span class="hljs-variable">%JAVA_OPTS%</span> <span class="hljs-variable">%GRADLE_OPTS%</span> &quot;-Dorg.gradle.appname=<span class="hljs-variable">%APP_BASE_NAME%</span>&quot; -classpath &quot;<span class="hljs-variable">%CLASSPATH%</span>&quot; org.gradle.wrapper.GradleWrapperMain %*<br><br>...<br><br></code></pre></td></tr></table></figure>

<p>我们把这里的注释和一些不重要的代码去掉后，其实可以看到很多熟悉的，比如 JAVA_HOME,JAVA_EXE,CLASSPATH等等，而最重要的执行代码只有一句，</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat">&quot;<span class="hljs-variable">%JAVA_EXE%</span>&quot; <span class="hljs-variable">%DEFAULT_JVM_OPTS%</span> <span class="hljs-variable">%JAVA_OPTS%</span> <span class="hljs-variable">%GRADLE_OPTS%</span> &quot;-Dorg.gradle.appname=<span class="hljs-variable">%APP_BASE_NAME%</span>&quot; -classpath &quot;<span class="hljs-variable">%CLASSPATH%</span>&quot; org.gradle.wrapper.GradleWrapperMain %*<br></code></pre></td></tr></table></figure>

<p>而细心的小伙伴可以看到在前面的那张截图中，我已经把这段代码 echo 出来了 只不过最后跟的参数 是我传入的 build，这也进一步证明了我们的猜想，在 idea 进行gradle任务时，永远会先一步调用 gradlew.bat 文件，因此它也是gradle的入口</p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719231746422.png" srcset="/img/loading.gif" lazyload alt="image-20220719231746422"></p>
<p>对于 gradle.bat 我们的了解也可以到此为止了，毕竟它的内容很少，而它当中的不管是 JAVA_EXE 还是 DEFAULT_JVM_OPTS 虚拟机默认环境等等，在之前的set代码中都已经设置好了，只有一个我们<strong>比较陌生的字眼</strong> GradleWrpapperMain</p>
<h2 id="GradleWrapperMain"><a href="#GradleWrapperMain" class="headerlink" title="GradleWrapperMain"></a>GradleWrapperMain</h2><blockquote>
<p>GradleWrapperMain 只是 gradle 的刚刚启动，甚至没有启动，因为都还没有接触到 daemon ，它的作用很少</p>
<p>一是配置各种参数，包括命令行，文件以及系统参数</p>
<p>二是根据参数启动真正gradle的下载并启动真正的gradle</p>
</blockquote>
<p>在哪呢？ idea 全局搜索试试</p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719232222552.png" srcset="/img/loading.gif" lazyload alt="image-20220719232222552"></p>
<p>找到了是不是？ 其实就在我们项目的 gradle文件夹下的gradle-wrapper.jar里的一个类，好的，既然找到了，那么开始我们最喜欢的debug环节吧</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a><strong>环境搭建</strong></h3><ul>
<li><strong>step1</strong> 将gradle-wrapper add as library 使他成为我们项目的一部分，这样的目的是让我们能够 debug 进去，也叫补环境，否则会显示我们找不到，当然我们在调试期间还会添加很多很多的包进行补环境，为了方便，我在这里直接把目前需要的包发出来</li>
</ul>
<img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719232512044.png" srcset="/img/loading.gif" lazyload alt="image-20220719232512044" style="zoom:67%;" />

<p>那么在哪里找到这些文件呢，在你的 gradle_user_home&#x2F;wrapper&#x2F;dists&#x2F;当前项目的gradle版本&#x2F;乱码&#x2F;唯一文件夹&#x2F;lib</p>
<p><img src="C:\Users\ysh\AppData\Roaming\Typora\typora-user-images\image-20220719233724220.png" srcset="/img/loading.gif" lazyload alt="image-20220719233724220"></p>
<ul>
<li><p><strong>step2</strong> 在 src&#x2F;main&#x2F;kotlin包下新建一个文件 Test.kt </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.gradle.wrapper.GradleWrapperMain<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>     GradleWrapperMain.main(args) <span class="hljs-comment">// 记得给这一行打上断点</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>step3</strong> 新建一个 Debug 任务</p>
<img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719233125245.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
</li>
<li><p><strong>step4</strong> 选中并debug该任务<img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220719233349671.png" srcset="/img/loading.gif" lazyload alt="image-20220719233349671"></p>
</li>
</ul>
<h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>对于有些与gradle源码无关，与底层代码有关的部分，我只通过注释说明它的作用及结果，不赘述</p>
<h4 id="GradleWrapperMain-main"><a href="#GradleWrapperMain-main" class="headerlink" title="GradleWrapperMain.main"></a>GradleWrapperMain.main</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">wrapperJar</span> <span class="hljs-operator">=</span> wrapperJar();<span class="hljs-comment">//获取gradle-wrapper.jar的文件路径</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">propertiesFile</span> <span class="hljs-operator">=</span> wrapperProperties(wrapperJar);<span class="hljs-comment">//获取gradle-wrapper.properties的文件路径</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">rootDir</span> <span class="hljs-operator">=</span> rootDir(wrapperJar);<span class="hljs-comment">//获取项目根路径</span><br>    <span class="hljs-type">CommandLineParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommandLineParser</span>();<span class="hljs-comment">//命令行解释器，去检测</span><br>    parser.allowUnknownOptions();<br>    parser.option(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;gradle-user-home&quot;</span>&#125;).hasArgument();<br>    parser.option(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;quiet&quot;</span>&#125;);<br>    <span class="hljs-type">SystemPropertiesCommandLineConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemPropertiesCommandLineConverter</span>();<br>    converter.configure(parser);<br>    <span class="hljs-type">ParsedCommandLine</span> <span class="hljs-variable">options</span> <span class="hljs-operator">=</span> parser.parse(args);<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">systemProperties</span> <span class="hljs-operator">=</span> System.getProperties();<br>    systemProperties.putAll(converter.convert(options, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>()));<span class="hljs-comment">//到这里为止，都是去解析参数，分析我们在命令行给出的参数以及我们系统的各种信息，比如os，user.home甚至contry</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">gradleUserHome</span> <span class="hljs-operator">=</span> gradleUserHome(options);<span class="hljs-comment">//下面详细介绍</span><br>    addSystemProperties(systemProperties, gradleUserHome, rootDir);<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> logger(options);<br>    <span class="hljs-type">WrapperExecutor</span> <span class="hljs-variable">wrapperExecutor</span> <span class="hljs-operator">=</span> WrapperExecutor.forWrapperPropertiesFile(propertiesFile);<br>    wrapperExecutor.execute(args, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Install</span>(logger, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Download</span>(logger, <span class="hljs-string">&quot;gradlew&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>), <span class="hljs-keyword">new</span> 			     <span class="hljs-title class_">PathAssembler</span>(gradleUserHome, rootDir)), <span class="hljs-keyword">new</span> <span class="hljs-title class_">BootstrapMainStarter</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="第一个小重点-——-gradle-user-home"><a href="#第一个小重点-——-gradle-user-home" class="headerlink" title="第一个小重点 —— gradle-user-home"></a>第一个小重点 —— gradle-user-home</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">gradleUserHome</span> <span class="hljs-operator">=</span> gradleUserHome(options);<br></code></pre></td></tr></table></figure>

<p>如果我们在命令行中有声明gradleuserhome，那么直接以此路径作为gradle-user-home的文件路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> File <span class="hljs-title function_">gradleUserHome</span><span class="hljs-params">(ParsedCommandLine options)</span> &#123;<br>        <span class="hljs-keyword">return</span> options.hasOption(<span class="hljs-string">&quot;g&quot;</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(options.option(<span class="hljs-string">&quot;g&quot;</span>).getValue()) : GradleUserHomeLookup.gradleUserHome();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>如果没有声明，那么就通过GradleUserHomeLookup类来获取你本地的gradle-user-home路径，如果你没有特别配置gradle-user-home的环境变量，那么它会以默认路径 user.home&#x2F;.gradle作为文件路径，如果你配置了，那它就会通过环境变量名来拿到你自己设置好的gradle-user-home路径，因此如果你想腾出你C盘的空间的话，可以尝试配置下 gradle-user-home 的路径 ，毕竟gradle他会把很多文件放在这里 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GradleUserHomeLookup</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_GRADLE_USER_HOME</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.home&quot;</span>) + <span class="hljs-string">&quot;/.gradle&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">GRADLE_USER_HOME_PROPERTY_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;gradle.user.home&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">GRADLE_USER_HOME_ENV_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;GRADLE_USER_HOME&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GradleUserHomeLookup</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> File <span class="hljs-title function_">gradleUserHome</span><span class="hljs-params">()</span> &#123;<br>        String gradleUserHome;<br>        <span class="hljs-keyword">if</span> ((gradleUserHome = System.getProperty(<span class="hljs-string">&quot;gradle.user.home&quot;</span>)) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(gradleUserHome);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (gradleUserHome = System.getenv(<span class="hljs-string">&quot;GRADLE_USER_HOME&quot;</span>)) != <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(gradleUserHome) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(DEFAULT_GRADLE_USER_HOME);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="提一嘴-——-addSystemProperties"><a href="#提一嘴-——-addSystemProperties" class="headerlink" title="提一嘴 ——  addSystemProperties"></a>提一嘴 ——  addSystemProperties</h4><p>其实这里就是把你项目路径下的 gradle.properties 和 gradle-user-home 下的 gradle.properties 中的所有配置加入 systemProperties 中，以后凡是要拿参数什么的，都会从这里拿</p>
<p>其实就是想告诉大家，如果有什么配置你的所有项目都需要配置的话，可以在 gradle-user-home 下一键配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">addSystemProperties(systemProperties, gradleUserHome, rootDir);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSystemProperties</span><span class="hljs-params">(Properties systemProperties, File gradleUserHome, File rootDir)</span> &#123;<br>        systemProperties.putAll(SystemPropertiesHandler.getSystemProperties(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(rootDir, <span class="hljs-string">&quot;gradle.properties&quot;</span>)));<br>        systemProperties.putAll(SystemPropertiesHandler.getSystemProperties(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(gradleUserHome, <span class="hljs-string">&quot;gradle.properties&quot;</span>)));<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="下载-gradle"><a href="#下载-gradle" class="headerlink" title="下载 gradle"></a>下载 gradle</h4><p>看到这个 install 其实也就知道要发生什么了，其实我们应该都知道 gradlewrapper 是很轻量的，它先对于完整的gradle.binary文件渺小甚微，因此正如我们在开头提到的一样 GradleWrapperMain 只是 gradle 的刚刚启动，甚至没有启动，因为都还没有接触到 daemon ，它的作用一是配置参数，二是根据参数启动真正gradle的下载，你也可以在 gradle-wrapper.properties 文件中看到真正的下载地址</p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720002026622.png" srcset="/img/loading.gif" lazyload alt="image-20220720002026622" style="zoom: 50%;" /><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720002058485.png" srcset="/img/loading.gif" lazyload alt="image-20220720002058485" style="zoom:50%;" /></p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720002413236.png" srcset="/img/loading.gif" lazyload alt="image-20220720002413236"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">WrapperExecutor</span> <span class="hljs-variable">wrapperExecutor</span> <span class="hljs-operator">=</span> WrapperExecutor.forWrapperPropertiesFile(propertiesFile);<br>wrapperExecutor.execute(args, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Install</span>(logger, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Download</span>(logger, <span class="hljs-string">&quot;gradlew&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>), <span class="hljs-keyword">new</span> 			   <span class="hljs-title class_">PathAssembler</span>(gradleUserHome, rootDir)), <span class="hljs-keyword">new</span> <span class="hljs-title class_">BootstrapMainStarter</span>());<br></code></pre></td></tr></table></figure>

<p>根据 gradle-wrapper.properties 里的设置比如下载地址，存放目录，默认在 gradle-user-home 下的 wrapper&#x2F;dists ，通过这些参数进行配置，所以 WrapperExcutor 就是一个下载类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WrapperExecutor <span class="hljs-title function_">forWrapperPropertiesFile</span><span class="hljs-params">(File propertiesFile)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!propertiesFile.exists()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(String.format(<span class="hljs-string">&quot;Wrapper properties file &#x27;%s&#x27; does not exist.&quot;</span>, propertiesFile));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WrapperExecutor</span>(propertiesFile, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>随后执行的 execute 方法</p>
<p>一、首先先在 gradle-user-home 下创建对应的文件夹，即wrapper&#x2F;dists，将下载好的文件根据方法写入的规则存入该文件夹中</p>
<p>二、随后调用传入的 bootstrapMainStarter 的 start 方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(String[] args, Install install, BootstrapMainStarter bootstrapMainStarter)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">gradleHome</span> <span class="hljs-operator">=</span> install.createDist(<span class="hljs-built_in">this</span>.config);<br>        bootstrapMainStarter.start(args, gradleHome);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>在调用 start 前，我们的完整gradle已经下载好了。下面这段代码 1.首先判断 gradle-launcher-.*(对应你的gradle版本).jar是否存在。2.将该 jar 内的 GradleMain 通过类加载器加载进来，并调用其 main 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(String[] args, File gradleHome)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">gradleJar</span> <span class="hljs-operator">=</span> findLauncherJar(gradleHome);<span class="hljs-comment">//首先判断gradle-launcher-.*\.jar是否存在</span><br>        <span class="hljs-keyword">if</span> (gradleJar == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(String.format(<span class="hljs-string">&quot;Could not locate the Gradle launcher JAR in Gradle distribution &#x27;%s&#x27;.&quot;</span>, gradleHome));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">contextClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;gradleJar.toURI().toURL()&#125;, ClassLoader.getSystemClassLoader().getParent());<br>            Thread.currentThread().setContextClassLoader(contextClassLoader);<br>            Class&lt;?&gt; mainClass = contextClassLoader.loadClass(<span class="hljs-string">&quot;org.gradle.launcher.GradleMain&quot;</span>);<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">mainMethod</span> <span class="hljs-operator">=</span> mainClass.getMethod(<span class="hljs-string">&quot;main&quot;</span>, String[].class);<br>            mainMethod.invoke((Object)<span class="hljs-literal">null</span>, args);<br>            <span class="hljs-keyword">if</span> (contextClassLoader <span class="hljs-keyword">instanceof</span> Closeable) &#123;<br>                contextClassLoader.close();<br>            &#125;<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>至此，我们 GradleWrapperMain 的任务就算完成了，让我们再次梳理一遍，GradleWrapperMain 只是 gradle 的刚刚启动，它的作用很少，一是配置各种参数，包括命令行，文件以及系统参数；二是根据参数启动真正gradle的下载并启动真正的gradle，也就是我们前面提到的 <strong>GradleMain</strong></p>
<h2 id="GradleMain"><a href="#GradleMain" class="headerlink" title="GradleMain"></a>GradleMain</h2><h3 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>还有将之前提到的文件夹  add as library</p>
<img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720004531828.png" srcset="/img/loading.gif" lazyload alt="image-20220720004531828" style="zoom:67%;" />

<h3 id="开始调试-1"><a href="#开始调试-1" class="headerlink" title="开始调试"></a>开始调试</h3><p>进去之后发现 main 方法中代码很少，而最重要的是最后一句，传入了当前包下名为 Main 类的字符串，其实绕了一大圈，目的只是为了让类加载器加载这个类并启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            UnsupportedJavaRuntimeException.assertUsingVersion(<span class="hljs-string">&quot;Gradle&quot;</span>, JavaVersion.VERSION_1_8);<br>        &#125; <span class="hljs-keyword">catch</span> (UnsupportedJavaRuntimeException var2) &#123;<br>            System.err.println(var2.getMessage());<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBootstrap</span>()).run(<span class="hljs-string">&quot;org.gradle.launcher.Main&quot;</span>, args);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="new-ProcessBootstrap-run"><a href="#new-ProcessBootstrap-run" class="headerlink" title="(new ProcessBootstrap()).run"></a>(new ProcessBootstrap()).run</h3><p>ProcessBootstrap 其实从名字也看得出，这个类是一个中间类，他的作用就是调用了 runNoExit 去更新classpath并加载Main类，最后调用他的 run 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessBootstrap</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProcessBootstrap</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String mainClassName, String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.runNoExit(mainClassName, args);<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var4) &#123;<br>            var4.printStackTrace();<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runNoExit</span><span class="hljs-params">(String mainClassName, String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ClassPathRegistry</span> <span class="hljs-variable">classPathRegistry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultClassPathRegistry</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathProvider</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultClassPathProvider</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultModuleRegistry</span>(CurrentGradleInstallation.get()))&#125;);<br>        <span class="hljs-type">ClassLoaderFactory</span> <span class="hljs-variable">classLoaderFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultClassLoaderFactory</span>();<br>        <span class="hljs-type">ClassPath</span> <span class="hljs-variable">antClasspath</span> <span class="hljs-operator">=</span> classPathRegistry.getClassPath(<span class="hljs-string">&quot;ANT&quot;</span>);<br>        <span class="hljs-type">ClassPath</span> <span class="hljs-variable">runtimeClasspath</span> <span class="hljs-operator">=</span> classPathRegistry.getClassPath(<span class="hljs-string">&quot;GRADLE_RUNTIME&quot;</span>);<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">antClassLoader</span> <span class="hljs-operator">=</span> classLoaderFactory.createIsolatedClassLoader(<span class="hljs-string">&quot;ant-loader&quot;</span>, antClasspath);<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">runtimeClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VisitableURLClassLoader</span>(<span class="hljs-string">&quot;ant-and-gradle-loader&quot;</span>, antClassLoader, runtimeClasspath);<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">oldClassLoader</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br>        Thread.currentThread().setContextClassLoader(runtimeClassLoader);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; mainClass = runtimeClassLoader.loadClass(mainClassName);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">entryPoint</span> <span class="hljs-operator">=</span> mainClass.getConstructor().newInstance();<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">mainMethod</span> <span class="hljs-operator">=</span> mainClass.getMethod(<span class="hljs-string">&quot;run&quot;</span>, String[].class);<br>            mainMethod.invoke(entryPoint, args);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            Thread.currentThread().setContextClassLoader(oldClassLoader);<br>            ClassLoaderUtils.tryClose(runtimeClassLoader);<br>            ClassLoaderUtils.tryClose(antClassLoader);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至于为什么调用的是 Main 类的 run 方法，是因为它是 EntryPoint 的子类，总之最后调用的是 Main 类中的 <strong>doAction</strong> 方法，而下面短短的一段代码，却特别特别地绕，嵌套了很多层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EntryPoint</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAction</span><span class="hljs-params">(String[] args, ExecutionListener listener)</span> &#123;<br>        <span class="hljs-built_in">this</span>.createActionFactory().convert(Arrays.asList(args)).execute(listener);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>createActionFactory() 返回了一个 DefaultCommandLineActionFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">CommandLineActionFactory <span class="hljs-title function_">createActionFactory</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultCommandLineActionFactory</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>随后调用了它的 <strong>convert</strong> 方法，首先注册日志服务以及日志配置，然后返回了一个 WithLogging 的类</p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720151852905.png" srcset="/img/loading.gif" lazyload alt="image-20220720151852905"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CommandLineActionFactory.CommandLineExecution <span class="hljs-title function_">convert</span><span class="hljs-params">(List&lt;String&gt; args)</span> &#123;<br>    <span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">loggingServices</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.createLoggingServices();<br>    <span class="hljs-type">LoggingConfiguration</span> <span class="hljs-variable">loggingConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultLoggingConfiguration</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WithLogging</span>(loggingServices, args, loggingConfiguration, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParseAndBuildAction</span>(loggingServices, args), <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildExceptionReporter</span>((StyledTextOutputFactory)loggingServices.get(StyledTextOutputFactory.class), loggingConfiguration, clientMetaData()));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们回到 doAction 方法中，调用了 WithLogging 的 execute 方法</p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720151929613.png" srcset="/img/loading.gif" lazyload alt="image-20220720151929613"></p>
<p>关于 WithLogging 中的 execute ，你不需要了解很多，它只是做了一些关于日志的初始化工作，而这一部分，其实就是责任链模式，也就是okhttp中的责任链，每个类中的 excute 都负责处理自己的任务，并在最后调用下一层的execute方法，正如我们所说的，在 WithLogging 的 execute 方法的最后又 new 了嵌套一大串的 Action，最后并调用最外层的 ExceptionReportingAction的 execte方法</p>
<p><strong>注：</strong> 这里有个点需要特别注意，在最后的 DebugLoggerWarningAction 传入了 <strong>this.action</strong> ，也是之前在 WithLogging 中传入的 <strong>ParseAndBuildAction</strong> ，这是最后的调用点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ExecutionListener executionListener)</span> &#123;<br>    ...省略代码<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Action&lt;ExecutionListener&gt; exceptionReportingAction = <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionReportingAction</span>(<span class="hljs-built_in">this</span>.reporter, loggingManager, <br>                   <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeServicesInitializingAction</span>(buildLayout, <span class="hljs-built_in">this</span>.loggingConfiguration, loggingManager, <br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">WelcomeMessageAction</span>(buildLayout, <br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugLoggerWarningAction</span>(<span class="hljs-built_in">this</span>.loggingConfiguration, <span class="hljs-built_in">this</span>.action))));<br>        exceptionReportingAction.execute(executionListener);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        loggingManager.stop();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>而之后的思路就很清晰了，如果你了解责任链模式的工作方式，后面应该也不用我多说了，ExceptionReportingAction 完成异常处理的相关配置之后调用了 NativeServicesInitializingAction 的 execute 方法，之后完成本地Native服务初始化，在调用 WelcomeMessageAction 的 execute 方法，这里这个 Welcome类很有意思的，是一个专门为了欢迎用户的类，以此类推，我们直接跳到<strong>最后的调用处 this.action</strong> 也就是 <strong>ParseAndBuildAction</strong></p>
<img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720153955796.png" srcset="/img/loading.gif" lazyload alt="image-20220720153955796" style="zoom:67%;" />

<p><strong>ParseAndBuildAction</strong> 中的 execute 方法，这里我们需要关注的点有几个，一是 actions 的生成，二是 action 的生成</p>
<p>关于 actions 的生成，我在下面的注释做了比较详细的说明，我们把重点放在 action 的生成，也就是 createAction ，它将一个actions列表变成了一个 Runnable action</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ExecutionListener executionListener)</span> &#123;<br>    	<span class="hljs-comment">//new了一个命令行动作的数组，可以看到这个CommandLineAction里面有两个方法，一个是配置命令行解析器，用来初始化的，另一个是createAction，应该就是调用action去执行</span><br>            List&lt;CommandLineAction&gt; actions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    	<span class="hljs-comment">//这个BuiltInActions就是实现了CommandlineAction接口的实现类</span><br>            actions.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BuiltInActions</span>());<br>    	<span class="hljs-comment">//再加入一个能够开启日志服务的action</span><br>            DefaultCommandLineActionFactory.<span class="hljs-built_in">this</span>.createActionFactories(<span class="hljs-built_in">this</span>.loggingServices, actions);<br>    	<span class="hljs-comment">//命令行解析器</span><br>            <span class="hljs-type">CommandLineParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommandLineParser</span>();<br>            <span class="hljs-type">Iterator</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> actions.iterator();<br><br>            <span class="hljs-keyword">while</span>(var4.hasNext()) &#123;<br>                <span class="hljs-comment">//把很多的命令行指令加载进去，看到了很多熟悉的比如help,version,D对应system-prop</span><br>                <span class="hljs-type">CommandLineAction</span> <span class="hljs-variable">actionx</span> <span class="hljs-operator">=</span> (CommandLineAction)var4.next();<br>                actionx.configureCommandLineParser(parser);<br>            &#125;<br><br>            Object action;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//把我们此次的命令行参数build和可供选择的参数结合生成一个commandLine，也就是被解析后的命令行</span><br>                <span class="hljs-type">ParsedCommandLine</span> <span class="hljs-variable">commandLine</span> <span class="hljs-operator">=</span> parser.parse(<span class="hljs-built_in">this</span>.args);<br>                action = <span class="hljs-built_in">this</span>.createAction(actions, parser, commandLine);<br>            &#125; <span class="hljs-keyword">catch</span> (CommandLineArgumentException var6) &#123;<br>                action = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommandLineParseFailureAction</span>(parser, var6);<br>            &#125;<br><br>            ((Action)action).execute(executionListener);<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这个方法是一个do while 循环，直到迭代器var4为空或action不为空时才会停止，而这个迭代器也是通过参数传入的，而他里面有什么呢？其实在上个方法里面有提到过 分别叫 BuiltInActions 和 BuildActionsFactory，他们都有 createAction 方法，很简单，我们进去看看就知道了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Action&lt;? <span class="hljs-built_in">super</span> ExecutionListener&gt; createAction(Iterable&lt;CommandLineAction&gt; factories, CommandLineParser parser, ParsedCommandLine commandLine) &#123;<br>            <span class="hljs-type">Iterator</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> factories.iterator();<br><br>            Runnable action;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (!var4.hasNext()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;No action factory for specified command-line arguments.&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-type">CommandLineAction</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> (CommandLineAction)var4.next();<br>                action = factory.createAction(parser, commandLine);<br>            &#125; <span class="hljs-keyword">while</span>(action == <span class="hljs-literal">null</span>);<br><br>            <span class="hljs-keyword">return</span> Actions.toAction(action);<br>        &#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720160448825.png" srcset="/img/loading.gif" lazyload alt="image-20220720160448825"></p>
<p>这是 BuiltInActions 中的 createAction，其实一眼丁真，就知道它是当我们在命令行上输入 gradle -v&#x2F;-h 这两个命令时，它才会返回不为空的 Action ，因此这个类就是处理 <strong>gradle help</strong> 和 <strong>gradle version</strong> 两个命令的，当然我们调试的参数为 build 因此这里一定会返回空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BuiltInActions</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandLineAction</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">BuiltInActions</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureCommandLineParser</span><span class="hljs-params">(CommandLineParser parser)</span> &#123;<br>        parser.option(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;?&quot;</span>, <span class="hljs-string">&quot;help&quot;</span>&#125;).hasDescription(<span class="hljs-string">&quot;Shows this help message.&quot;</span>);<br>        parser.option(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;v&quot;</span>, <span class="hljs-string">&quot;version&quot;</span>&#125;).hasDescription(<span class="hljs-string">&quot;Print version info.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Runnable <span class="hljs-title function_">createAction</span><span class="hljs-params">(CommandLineParser parser, ParsedCommandLine commandLine)</span> &#123;<br>        <span class="hljs-keyword">if</span> (commandLine.hasOption(<span class="hljs-string">&quot;h&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShowUsageAction</span>(parser);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> commandLine.hasOption(<span class="hljs-string">&quot;v&quot;</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShowVersionAction</span>() : <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是BuildActionsFactory中的createAction方法，很明显，他要复杂地多，因为它要处理的命令都要与 daemon 有关，而其实这么多行代码，其实对于我们分析 gradle 的启动流程来说，唯一有用的只有一句 <strong>runBuildWithDaemon</strong> 自此 daemon 正式登场，这也是 gradle 加速构建 提高构建效率的关键，当然进入这行代码的条件是我们允许daemon 即 daemon &#x3D; true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Runnable <span class="hljs-title function_">createAction</span><span class="hljs-params">(CommandLineParser parser, ParsedCommandLine commandLine)</span> &#123;<br>    <span class="hljs-type">Parameters</span> <span class="hljs-variable">parameters</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.parametersConverter.convert(commandLine, (File)<span class="hljs-literal">null</span>);<br>    parameters.getDaemonParameters().applyDefaultsFor(<span class="hljs-built_in">this</span>.jvmVersionDetector.getJavaVersion(parameters.getDaemonParameters().getEffectiveJvm()));<br>    <span class="hljs-keyword">if</span> (parameters.getDaemonParameters().isStop()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stopAllDaemons(parameters.getDaemonParameters());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parameters.getDaemonParameters().isStatus()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.showDaemonStatus(parameters.getDaemonParameters());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parameters.getDaemonParameters().isForeground()) &#123;<br>        <span class="hljs-type">DaemonParameters</span> <span class="hljs-variable">daemonParameters</span> <span class="hljs-operator">=</span> parameters.getDaemonParameters();<br>        <span class="hljs-type">ForegroundDaemonConfiguration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForegroundDaemonConfiguration</span>(UUID.randomUUID().toString(), daemonParameters.getBaseDir(), daemonParameters.getIdleTimeout(), daemonParameters.getPeriodicCheckInterval(), <span class="hljs-built_in">this</span>.fileCollectionFactory);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForegroundDaemonAction</span>(<span class="hljs-built_in">this</span>.loggingServices, conf);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parameters.getDaemonParameters().isEnabled()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.runBuildWithDaemon(parameters.getStartParameter(), parameters.getDaemonParameters());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.canUseCurrentProcess(parameters.getDaemonParameters()) ? <span class="hljs-built_in">this</span>.runBuildInProcess(parameters.getStartParameter(), parameters.getDaemonParameters()) : <span class="hljs-built_in">this</span>.runBuildInSingleUseDaemon(parameters.getStartParameter(), parameters.getDaemonParameters());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在讲接下来的代码之前，需要先科普一下什么是 daemon </p>
<blockquote>
<p>这是 Gradle 官网对于 daemon 的描述</p>
<p><em>A daemon is a computer program that runs as a background process, rather than being under the direct control of an interactive user.</em></p>
<p>首先我们需要知道的是，在gradle运行之前且gradle底层也是java代码也需要虚拟机去运行，需要大量的时间去初始化支持库，时间大约为几秒或十几秒，而这仅仅只是启动，如果我们每次去 run 项目都需要这么长时间的话，会大大影响开发者的体验，而gradle daemon就是为了解决这一问题想出的方案。</p>
<p>一、gradle daemon 是一个守护进程，注意是进程，而进程下可以有多个线程</p>
<p>二、每个项目在运行时也就是运行到我们目前分析的这个情况下，即 runBuildWithDaemon时，都会创建一个叫做 DaemonClient的线程，它很轻量，启动时间很少，而它的作用就是去连接真正的 Daemon，这种关系类似于 c&#x2F;s 即服务器与客户端的关系，而如果client发现目前 daemon 进程没有被创建，则此时就会创建 daemon 进程，进行初始化支持库操作，这个时间与非daemon时的初始化操作耗时相等，而对于daemonClient的连接请求，daemon进程会给其分配一个线程 daemonService 去处理该client的gradle请求。但是关键的是 daemon 进程是独立存在的 它不会因为当前项目的停止而停止，而是会一直被守护在后台，等待 daemonClient 的连接，只有当连续三个小时左右没有连接才会自己销毁，因此初始化操作的次数就会大大减小，大大减小了时间</p>
</blockquote>
<p>事情突然变得有趣起来了</p>
<p><strong>首先</strong>：创建了一个全局client服务，传入true为确认使用daemon，毕竟在jdk8之前是不建议使用dasemon的，daemon可以帮助我们加快构建速度，因为daemon在短时间是不会销毁的，它通过每次构建client去和daemon通信</p>
<p><strong>其次：</strong>DaemonClient client 这就是我们所说的client进程，也就是与daemon通信的轻量进程</p>
<p><strong>最后：</strong>runBuildAndCloseServices 根据方法的名字就知道，它是开启daemon进程的构建并关闭当前这个client进程，在后面我们就会发现它再run的finanly的时候会调用stopable来关闭client进程，这个函数返回了一个Runnable，而这里面client作为了exector传进去，一定要注意，因为client是作为进入daemon的入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">runBuildWithDaemon</span><span class="hljs-params">(StartParameterInternal startParameter, DaemonParameters daemonParameters)</span> &#123;<br>    <span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">clientSharedServices</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.createGlobalClientServices(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">clientServices</span> <span class="hljs-operator">=</span> ((DaemonClientFactory)clientSharedServices.get(DaemonClientFactory.class)).createBuildClientServices((OutputEventListener)<span class="hljs-built_in">this</span>.loggingServices.get(OutputEventListener.class), daemonParameters, System.in);<br>    <span class="hljs-type">DaemonClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> (DaemonClient)clientServices.get(DaemonClient.class);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.runBuildAndCloseServices(startParameter, daemonParameters, client, clientSharedServices, clientServices);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数里面有个run方法，要格外注意，因为它就是我们包装了许多层之后继承自Runnable类的 run 方法，即我们最终的调用处</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">runBuildAndCloseServices</span><span class="hljs-params">(StartParameterInternal startParameter, DaemonParameters daemonParameters, BuildActionExecuter&lt;BuildActionParameters, BuildRequestContext&gt; executer, ServiceRegistry sharedServices, Object... stopBeforeSharedServices)</span> &#123;<br>    <span class="hljs-type">BuildActionParameters</span> <span class="hljs-variable">parameters</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.createBuildActionParameters(startParameter, daemonParameters);<br>    <span class="hljs-type">Stoppable</span> <span class="hljs-variable">stoppable</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompositeStoppable</span>()).add(stopBeforeSharedServices).add(sharedServices);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunBuildAction</span>(executer, startParameter, <span class="hljs-built_in">this</span>.clientMetaData(), <span class="hljs-built_in">this</span>.getBuildStartTime(), parameters, sharedServices, stoppable);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">BuildActionResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.executer.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecuteBuildAction</span>(<span class="hljs-built_in">this</span>.startParameter), <span class="hljs-built_in">this</span>.buildActionParameters, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultBuildRequestContext</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultBuildRequestMetaData</span>(<span class="hljs-built_in">this</span>.clientMetaData, <span class="hljs-built_in">this</span>.startTime, ((ConsoleDetector)<span class="hljs-built_in">this</span>.sharedServices.get(ConsoleDetector.class)).isConsoleInput()), <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultBuildCancellationToken</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoOpBuildEventConsumer</span>()));<br>        <span class="hljs-keyword">if</span> (result.hasFailure()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReportedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stoppable != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.stoppable.stop();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有趣的是有没有发现我们现在分析的方法全都是有return值的，因此最后我们又回到了 ParseAndBuildAction 类的 execute方法的最后一句，最后调用的其实就是变换后的 RunBuildAction 中的 run 方法</p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720165503139.png" srcset="/img/loading.gif" lazyload alt="image-20220720165503139"></p>
<p>而这个方法又调用了 executer的execute方法，而这个executer是什么，你们自己去找找吧，这里我就告诉你们了，其实就是前面的 DaemonClient</p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220720170002146.png" srcset="/img/loading.gif" lazyload alt="image-20220720170002146"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">BuildActionResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.executer.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecuteBuildAction</span>(<span class="hljs-built_in">this</span>.startParameter), <span class="hljs-built_in">this</span>.buildActionParameters, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultBuildRequestContext</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultBuildRequestMetaData</span>(<span class="hljs-built_in">this</span>.clientMetaData, <span class="hljs-built_in">this</span>.startTime, ((ConsoleDetector)<span class="hljs-built_in">this</span>.sharedServices.get(ConsoleDetector.class)).isConsoleInput()), <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultBuildCancellationToken</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoOpBuildEventConsumer</span>()));<br>            <span class="hljs-keyword">if</span> (result.hasFailure()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReportedException</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stoppable != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-built_in">this</span>.stoppable.stop();<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>而这里给每个 daemon 线程都分配了uid和pid，随后进行了100次的循环，不过其实不是100次，只是给了100次的重连机会，一旦client成功连接上daemon，就会直接返回，因此最关键的代码是 connect 函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> BuildActionResult <span class="hljs-title function_">execute</span><span class="hljs-params">(BuildAction action, BuildActionParameters parameters, BuildRequestContext requestContext)</span> &#123;<br>    <span class="hljs-type">UUID</span> <span class="hljs-variable">buildId</span> <span class="hljs-operator">=</span> (UUID)<span class="hljs-built_in">this</span>.idGenerator.generateId();<br>    List&lt;DaemonInitialConnectException&gt; accumulatedExceptions = Lists.newArrayList();<br>    LOGGER.debug(<span class="hljs-string">&quot;Executing build &#123;&#125; in daemon client &#123;pid=&#123;&#125;&#125;&quot;</span>, buildId, <span class="hljs-built_in">this</span>.processEnvironment.maybeGetPid());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">saneNumberOfAttempts</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; saneNumberOfAttempts; ++i) &#123;<br>        <span class="hljs-type">DaemonClientConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.connector.connect(<span class="hljs-built_in">this</span>.compatibilitySpec);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Build</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Build</span>(buildId, connection.getDaemon().getToken(), action, requestContext.getClient(), requestContext.getStartTime(), requestContext.isInteractive(), parameters);<br>            <span class="hljs-type">BuildActionResult</span> <span class="hljs-variable">var10</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.executeBuild(build, connection, requestContext.getCancellationToken(), requestContext.getEventConsumer());<br>            <span class="hljs-keyword">return</span> var10;<br>        &#125; <span class="hljs-keyword">catch</span> (DaemonInitialConnectException var14) &#123;<br>            LOGGER.debug(<span class="hljs-string">&quot;&#123;&#125;, Trying a different daemon...&quot;</span>, var14.getMessage());<br>            accumulatedExceptions.add(var14);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            connection.stop();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoUsableDaemonFoundException</span>(<span class="hljs-string">&quot;Unable to find a usable idle daemon. I have connected to &quot;</span> + saneNumberOfAttempts + <span class="hljs-string">&quot; different daemons but I could not use any of them to run the build. BuildActionParameters were &quot;</span> + parameters + <span class="hljs-string">&quot;.&quot;</span>, accumulatedExceptions);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以发现这个方法中有几个集合，空闲的daemon线程，繁忙的daemon线程，当然还包括正在取消的daemon，我们不必在意，这只是为了去最大利用daemon的代码，我们真正关心的是最后一句 startDaemon</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> DaemonClientConnection <span class="hljs-title function_">connect</span><span class="hljs-params">(ExplainingSpec&lt;DaemonContext&gt; constraint)</span> &#123;<br>        Pair&lt;Collection&lt;DaemonInfo&gt;, Collection&lt;DaemonInfo&gt;&gt; idleBusy = <span class="hljs-built_in">this</span>.partitionByState(<span class="hljs-built_in">this</span>.daemonRegistry.getAll(), State.Idle);<br>        Collection&lt;DaemonInfo&gt; idleDaemons = (Collection)idleBusy.getLeft();<br>        Collection&lt;DaemonInfo&gt; busyDaemons = (Collection)idleBusy.getRight();<br>        <span class="hljs-type">DaemonClientConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.connectToIdleDaemon(idleDaemons, constraint);<br>        <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> connection;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            connection = <span class="hljs-built_in">this</span>.connectToCanceledDaemon(busyDaemons, constraint);<br>            <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> connection;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.handleStopEvents(idleDaemons, busyDaemons);<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.startDaemon(constraint);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>它又调用了 doStartDaemon 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> DaemonClientConnection <span class="hljs-title function_">startDaemon</span><span class="hljs-params">(ExplainingSpec&lt;DaemonContext&gt; constraint)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.doStartDaemon(constraint, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我就不赘述了，只讲最重要的部分 startDaemon ，在它之后的代码就是去连接 DaemonService 并更新存活Daemon的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> DaemonClientConnection <span class="hljs-title function_">doStartDaemon</span><span class="hljs-params">(ExplainingSpec&lt;DaemonContext&gt; constraint, <span class="hljs-type">boolean</span> singleRun)</span> &#123;<br>    <span class="hljs-type">ProgressLogger</span> <span class="hljs-variable">progressLogger</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.progressLoggerFactory.newOperation(DefaultDaemonConnector.class).start(<span class="hljs-string">&quot;Starting Gradle Daemon&quot;</span>, <span class="hljs-string">&quot;Starting Daemon&quot;</span>);<br>    <span class="hljs-type">DaemonStartupInfo</span> <span class="hljs-variable">startupInfo</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.daemonStarter.startDaemon(singleRun);<br>    LOGGER.debug(<span class="hljs-string">&quot;Started Gradle daemon &#123;&#125;&quot;</span>, startupInfo);<br>    <span class="hljs-type">CountdownTimer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> Time.startCountdownTimer(<span class="hljs-built_in">this</span>.connectTimeout);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-type">DaemonClientConnection</span> <span class="hljs-variable">daemonConnection</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.connectToDaemonWithId(startupInfo, constraint);<br>            <span class="hljs-keyword">if</span> (daemonConnection != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-built_in">this</span>.startListener.daemonStarted(daemonConnection.getDaemon());<br>                <span class="hljs-type">DaemonClientConnection</span> <span class="hljs-variable">var7</span> <span class="hljs-operator">=</span> daemonConnection;<br>                <span class="hljs-keyword">return</span> var7;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">200L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException var11) &#123;<br>                <span class="hljs-keyword">throw</span> UncheckedException.throwAsUncheckedException(var11);<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span>(!timer.hasExpired());<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaemonConnectionException</span>(<span class="hljs-string">&quot;Timeout waiting to connect to the Gradle daemon.\n&quot;</span> + startupInfo.describe());<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        progressLogger.completed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们只把目光关注在这两行代码，在这个方法中，将很多参数都加入了 daemonArgs中 比如gradle版本等等，而最重要的就是这个 GradleDaemon.class.getName，这里又引入了一个新的类名，我们也完全可以猜测，这就是我们第三阶段所要讲的类，也就是 gradle 启动完成后的构建阶段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> DaemonStartupInfo <span class="hljs-title function_">startDaemon</span><span class="hljs-params">(<span class="hljs-type">boolean</span> singleUse)</span> &#123;<br>    	...<br>        <br>        daemonArgs.add(GradleDaemon.class.getName());<br>        ...<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.startProcess(daemonArgs, <span class="hljs-built_in">this</span>.daemonDir.getVersionedDir(), <span class="hljs-built_in">this</span>.daemonParameters.getGradleUserHomeDir().getAbsoluteFile(), stdInput);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到代码越来越复杂，看看startProcess做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> DaemonStartupInfo <span class="hljs-title function_">startProcess</span><span class="hljs-params">(List&lt;String&gt; args, File workingDir, File gradleUserHome, InputStream stdInput)</span> &#123;<br>    LOGGER.debug(<span class="hljs-string">&quot;Starting daemon process: workingDir = &#123;&#125;, daemonArgs: &#123;&#125;&quot;</span>, workingDir, args);<br>    <span class="hljs-type">Timer</span> <span class="hljs-variable">clock</span> <span class="hljs-operator">=</span> Time.startTimer();<br><br>    DaemonStartupInfo var23;<br>    <span class="hljs-keyword">try</span> &#123;<br>        GFileUtils.mkdirs(workingDir);<br>        <span class="hljs-type">DaemonOutputConsumer</span> <span class="hljs-variable">outputConsumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaemonOutputConsumer</span>();<br>        <span class="hljs-type">DefaultExecActionFactory</span> <span class="hljs-variable">execActionFactory</span> <span class="hljs-operator">=</span> DefaultExecActionFactory.root(gradleUserHome);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ExecHandle</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">DaemonExecHandleBuilder</span>()).build(args, workingDir, outputConsumer, stdInput, execActionFactory.newExec());<br>            handle.start();<br>            LOGGER.debug(<span class="hljs-string">&quot;Gradle daemon process is starting. Waiting for the daemon to detach...&quot;</span>);<br>            handle.waitForFinish();<br>            LOGGER.debug(<span class="hljs-string">&quot;Gradle daemon process is now detached.&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            CompositeStoppable.stoppable(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;execActionFactory&#125;).stop();<br>        &#125;<br><br>        var23 = <span class="hljs-built_in">this</span>.daemonGreeter.parseDaemonOutput(outputConsumer.getProcessOutput(), args);<br>    &#125; <span class="hljs-keyword">catch</span> (GradleException var20) &#123;<br>        <span class="hljs-keyword">throw</span> var20;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception var21) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GradleException</span>(<span class="hljs-string">&quot;Could not start Gradle daemon.&quot;</span>, var21);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        LOGGER.info(<span class="hljs-string">&quot;An attempt to start the daemon took &#123;&#125;.&quot;</span>, clock.getElapsed());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> var23;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实就是创建了一个 Handle 并调用了其 start方法，而至此，daemon 就正式开启了，也就是说我们运行到了 GradleDaemon类的main方法</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">ExecHandle handle = (<span class="hljs-keyword">new</span> <span class="hljs-type">DaemonExecHandleBuilder</span>()).build(args, workingDir, outputConsumer, stdInput, execActionFactory.<span class="hljs-keyword">new</span><span class="hljs-type">Exec</span>());<br>handle.start();<br></code></pre></td></tr></table></figure>

<h3 id="总结一下-1"><a href="#总结一下-1" class="headerlink" title="总结一下"></a>总结一下</h3><p>如果说 GradleWrapperMain 的任务是下载真正的Gradle，那么 GradleMain 的任务就是启动 Gradle</p>
<blockquote>
<p>1.进行一系列的初始化</p>
<p>2.启动&#x2F;连接 Daemon 守护进程</p>
<p>3.Daemon 守护进程不断等待任务task请求并在线程池中执行任务</p>
</blockquote>
<h2 id="GradleDaemon"><a href="#GradleDaemon" class="headerlink" title="GradleDaemon"></a>GradleDaemon</h2><blockquote>
<p> Daemon 守护线程构建的过程，其实也可以算作 GradleMain的一部分，这里就单独领出来讲吧，主要的作用是：</p>
<p>如何开启了一个Daemon一直等待客户端发送构建任务，当有任务来到的时候就将任务发送到线程池执行构建</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GradleDaemon</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ProcessBootstrap.run(<span class="hljs-string">&quot;org.gradle.launcher.daemon.bootstrap.DaemonMain&quot;</span>, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>他跑起来的第一想法就是调用</p>
<p>DaemonMain</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RecordingExecutionListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecordingExecutionListener</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            doAction(args, listener);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            createErrorHandler().execute(e);<br>            listener.onFailure(e);<br>        &#125;<br><br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">failure</span> <span class="hljs-operator">=</span> listener.getFailure();<br>        <span class="hljs-type">ExecutionCompleter</span> <span class="hljs-variable">completer</span> <span class="hljs-operator">=</span> createCompleter();<br>        <span class="hljs-keyword">if</span> (failure == <span class="hljs-literal">null</span>) &#123;<br>            completer.complete();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            completer.completeWithFailure(failure);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>它又调用了doAction</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAction</span><span class="hljs-params">(String[] args, ExecutionListener listener)</span> &#123;<br>        ......<br>        ......<br><br>        LOGGER.debug(<span class="hljs-string">&quot;Assuming the daemon was started with following jvm opts: &#123;&#125;&quot;</span>, startupOpts);<br><br>        <span class="hljs-type">Daemon</span> <span class="hljs-variable">daemon</span> <span class="hljs-operator">=</span> daemonServices.get(Daemon.class);<br>        daemon.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">DaemonContext</span> <span class="hljs-variable">daemonContext</span> <span class="hljs-operator">=</span> daemonServices.get(DaemonContext.class);<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> daemonContext.getPid();<br>            daemonStarted(pid, daemon.getUid(), daemon.getAddress(), daemonLog);<br>            <span class="hljs-type">DaemonExpirationStrategy</span> <span class="hljs-variable">expirationStrategy</span> <span class="hljs-operator">=</span> daemonServices.get(MasterExpirationStrategy.class);<br>            daemon.stopOnExpiration(expirationStrategy, parameters.getPeriodicCheckIntervalMs());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            daemon.stop();<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Stop all daemon services</span><br>            CompositeStoppable.stoppable(daemonServices.get(GradleUserHomeScopeServiceRegistry.class)).stop();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>进入以后进行了海量的配置</p>
<p>之后获取了Daemon对象,以下是Daemon类的注解信息</p>
<blockquote>
<p>A long-lived build server that accepts commands via a communication channel.</p>
</blockquote>
<p>Daemon就相当于一个长时间运行的服务器，通过一个管道和客户端进行通信</p>
<p>start某种程度上就是开启了这个管道</p>
<p>之后进行了一些必要的配置以后，就开始<strong>等死</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stopOnExpiration</span><span class="hljs-params">(DaemonExpirationStrategy expirationStrategy, <span class="hljs-type">int</span> checkIntervalMills)</span> &#123;<br>        LOGGER.debug(<span class="hljs-string">&quot;stopOnExpiration() called on daemon&quot;</span>);<br>        scheduleExpirationChecks(expirationStrategy, checkIntervalMills);<br>        awaitExpiration();<br>    &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitExpiration</span><span class="hljs-params">()</span> &#123;<br>        LOGGER.debug(<span class="hljs-string">&quot;awaitExpiration() called on daemon&quot;</span>);<br><br>        DaemonStateCoordinator stateCoordinator;<br>        lifecycleLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stateCoordinator == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;cannot await stop on daemon as it has not been started.&quot;</span>);<br>            &#125;<br>            stateCoordinator = <span class="hljs-built_in">this</span>.stateCoordinator;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lifecycleLock.unlock();<br>        &#125;<br><br>        stateCoordinator.awaitStop();<br>    &#125;<br> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitStop</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">switch</span> (state) &#123;<br>                        <span class="hljs-keyword">case</span> Idle:<br>                        <span class="hljs-keyword">case</span> Busy:<br>                            LOGGER.debug(<span class="hljs-string">&quot;daemon is running. Sleeping until state changes.&quot;</span>);<br>                            condition.await();<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> Canceled:<br>                            LOGGER.debug(<span class="hljs-string">&quot;cancel requested.&quot;</span>);<br>                            cancelNow();<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> Broken:<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;This daemon is in a broken state.&quot;</span>);<br>                        <span class="hljs-keyword">case</span> StopRequested:<br>                            LOGGER.debug(<span class="hljs-string">&quot;daemon stop has been requested. Sleeping until state changes.&quot;</span>);<br>                            condition.await();<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> Stopped:<br>                            LOGGER.debug(<span class="hljs-string">&quot;daemon has stopped.&quot;</span>);<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> UncheckedException.throwAsUncheckedException(e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>就这样完成了gradle的启动。开启了一个Daemon一直等待客户端发送构建任务，当有任务来到的时候就将任务发送到线程池执行构建。</p>
<h3 id="总结一下-2"><a href="#总结一下-2" class="headerlink" title="总结一下"></a>总结一下</h3><p>GradleDaemon 的内容比较少，但是很重要，因为 Daemon 也是 Gradle 去加速构建，提高效率的关键，了解这个流程对去进一步理解Gradle也有帮助</p>
<h2 id="Gradle-构建"><a href="#Gradle-构建" class="headerlink" title="Gradle 构建"></a>Gradle 构建</h2><blockquote>
<p> 以上的内容，仅仅只是 Gradle 初始化的过程，它对于我们使用 gradle 可以说没有多大的价值，不过倒是可以帮助你更好的管理你本地的gradle，例如gradle-user-home，或是让你对gradle目录下的几个文件夹不至于那么头痛，也能知道它们大概表示的意义。</p>
<p>而至于我们所熟悉的 setting.gradle, build.gradle文件，都还没有出场，而接下来我们才刚刚开始介绍关于它们的源码</p>
</blockquote>
<p>在这之前，其实可以看一些有意思的东西。</p>
<p>这是 gradle-user-home 下的各个文件夹，可以试着去理解一下各个文件夹存放的东西</p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723185246052.png" srcset="/img/loading.gif" lazyload alt="image-20220723185246052"></p>
<ul>
<li><p><strong>.tmp</strong> —— 存放临时文件的文件夹，可以看到修改日期很新，完全删掉也可以</p>
</li>
<li><p><strong>build-scan-data</strong> —— 这其实是一个有关 gradle 的工具，build-scan，用图形化查看你项目的构建，包括各个 gradle 的任务，有兴趣的同学可以 Google Gradle build scan，这个文件夹就是存放该工具的一些数据</p>
</li>
<li><p><strong>caches</strong> —— 缓存的gradle 工程依赖文件和module依赖文件</p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723185722302.png" srcset="/img/loading.gif" lazyload alt="image-20220723185722302"></p>
<ul>
<li>7.1 gradle程序的脚本（gradle程序版本</li>
<li>jars-3存储的是工程gradle依赖文件</li>
<li>modules-2存储的是每一个项目下面的应用具体依赖的jar包</li>
</ul>
</li>
<li><p><strong>daemon</strong> ——  daemon日志目录，有关错误日志也会在这里</p>
</li>
<li><p><strong>native</strong> —— 用于存放平台相关（Win&#x2F;Linux&#x2F;Mac）的库，其实就是存放了 native 方法的地方，源码分析的时候，有很多也是调用到了 native 方法</p>
</li>
<li><p><strong>wrapper</strong> —— gradle-wrapper下载目录</p>
</li>
</ul>
<h3 id="环境搭建-2"><a href="#环境搭建-2" class="headerlink" title="环境搭建"></a>环境搭建</h3><blockquote>
<p>首先此时 daemon 已经被创建连接且处于正在等待task请求的状态，即 awaitStop，可是我们现在又迷茫了， Gradle 的构建，我们应该从和入手，换句话说，入口在哪，或者只要我们能看到方法的调用栈，是不是就可以知道入口了？</p>
</blockquote>
<ul>
<li><strong>step1</strong> 找到入口</li>
</ul>
<p>所以我们在 build.gradle 中让其强行抛出异常，这样做的目的，当我们 async 后就知道了</p>
<img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723204554548.png" srcset="/img/loading.gif" lazyload alt="image-20220723204554548" style="zoom:67%;" />

<p>报错了，但同时提供给了我们信息，而这些都是调用较后的方法了，我们把重点放在</p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723204634192.png" srcset="/img/loading.gif" lazyload alt="image-20220723204634192"></p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723205026378.png" srcset="/img/loading.gif" lazyload alt="image-20220723205026378"></p>
<p>找到了，然后通过全局搜索找到这几个类 DaemonStateCoordinator DaemonCommandExecution 并打上断点</p>
<ul>
<li><p><strong>step2</strong> 新建任务</p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723205248572.png" srcset="/img/loading.gif" lazyload alt="image-20220723205248572"></p>
</li>
<li><p><strong>step3</strong> 开始调试 记得这时候把抛出异常注释掉</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./gradlew.bat &quot;-Dorg.gradle.daemon=false&quot; &quot;-Dorg.gradle.debug=true&quot; :build<br></code></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723205346273.png" srcset="/img/loading.gif" lazyload alt="image-20220723205346273"></p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723205414219.png" srcset="/img/loading.gif" lazyload alt="image-20220723205414219"></p>
<p>咱们就来了</p>
<p><img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723205619019.png" srcset="/img/loading.gif" lazyload alt="image-20220723205619019"></p>
</li>
</ul>
<h3 id="开始调试-2"><a href="#开始调试-2" class="headerlink" title="开始调试"></a>开始调试</h3><p>DaemonCommandExecution 很有意思的一点就是它的成员变量actions，他是一个链表。</p>
<p>也就是说它把需要执行的内容串连起来了，当需要执行的时候就把这个串里面的任务链进行缩减，然后调用execute</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;DaemonCommandAction&gt; actions;<br></code></pre></td></tr></table></figure>

<p>这个执行任务链的过程比较长大概又15个任务。其中大部分就是一些配置任务，比如加log信息，配置环境变量。由于篇幅的原因那些不重要的配置任务就直接省略。</p>
<p>这里又一个任务非常重要也就是<code>ExecuteBuild</code>，这个任务触发了构建流程。</p>
<p>可以看到他是一个BuildCommandOnly的是实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecuteBuild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BuildCommandOnly</span><br></code></pre></td></tr></table></figure>

<p>BuildCommandOnly又是DaemonCommandAction的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BuildCommandOnly</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DaemonCommandAction</span><br></code></pre></td></tr></table></figure>

<p>前面分析过了任务链的执行是依靠一层层的调用BuildCommandOnly.execute.</p>
<p>这里也没落下。它调用了doBuild方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(DaemonCommandExecution execution)</span> &#123;<br>        <span class="hljs-type">Command</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> execution.getCommand();<br>        <span class="hljs-keyword">if</span> (!(command <span class="hljs-keyword">instanceof</span> Build)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(String.format(<span class="hljs-string">&quot;%1$s command action received a command that isn&#x27;t Build (command is %2$s), this shouldn&#x27;t happen&quot;</span>, <span class="hljs-built_in">this</span>.getClass(), command.getClass()));<br>        &#125;<br><br>        doBuild(execution, (Build)command);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>ExecuteBuild.doBuild执行如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBuild</span><span class="hljs-params">(DaemonCommandExecution execution, Build build)</span> &#123;<br>        LOGGER.debug(<span class="hljs-string">&quot;The daemon has started executing the build.&quot;</span>);<br>        LOGGER.debug(<span class="hljs-string">&quot;Executing build with daemon context: &#123;&#125;&quot;</span>, execution.getDaemonContext());<br>        <span class="hljs-built_in">this</span>.runningStats.buildStarted();<br>        <span class="hljs-type">DaemonConnectionBackedEventConsumer</span> <span class="hljs-variable">buildEventConsumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaemonConnectionBackedEventConsumer</span>(execution);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">BuildCancellationToken</span> <span class="hljs-variable">cancellationToken</span> <span class="hljs-operator">=</span> execution.getDaemonStateControl().getCancellationToken();<br>            <span class="hljs-type">BuildRequestContext</span> <span class="hljs-variable">buildRequestContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultBuildRequestContext</span>(build.getBuildRequestMetaData(), cancellationToken, buildEventConsumer);<br>            <span class="hljs-keyword">if</span> (!build.getAction().getStartParameter().isContinuous()) &#123;<br>                buildRequestContext.getCancellationToken().addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        ExecuteBuild.LOGGER.info(<span class="hljs-string">&quot;The daemon has received a build cancellation request.&quot;</span>);<br>                    &#125;<br>                &#125;);<br>            &#125;<br><br>            <span class="hljs-type">BuildActionResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.actionExecuter.execute(build.getAction(), build.getParameters(), buildRequestContext);<br>            execution.setResult(result);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            buildEventConsumer.waitForFinish();<br>            <span class="hljs-built_in">this</span>.runningStats.buildFinished();<br>            LOGGER.debug(<span class="hljs-string">&quot;The daemon has finished executing the build.&quot;</span>);<br>        &#125;<br><br>        execution.proceed();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这里调用了一个非常重要的方法，执行构建并获取构建结果。在它以前的任务就是一些配置以及准备，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BuildActionResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.actionExecuter.execute(build.getAction(), build.getParameters(), buildRequestContext);<br></code></pre></td></tr></table></figure>

<p>actionExecuter.execute的执行逻辑和前面任务链的执行逻辑很像。</p>
<p>每一个executer内部都持有了另外一个executer，等待把当前的executer的任务执行完成以后会调用delegate的execute继续执行，确保任务链不断。</p>
<p>这里也执行了一些没啥用的配置任务。直到执行到<code>BuildSessionLifecycleBuildActionExecuter</code></p>
<p>这里又把任务委托给了BuildSessionState.run</p>
<p>这里又是采用的链式任务执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> context.execute(action);<br><span class="hljs-keyword">public</span> BuildActionResult <span class="hljs-title function_">execute</span><span class="hljs-params">(BuildAction action, BuildActionParameters actionParameters, BuildRequestContext requestContext)</span> &#123;<br>        <span class="hljs-type">StartParameterInternal</span> <span class="hljs-variable">startParameter</span> <span class="hljs-operator">=</span> action.getStartParameter();<br>        <span class="hljs-keyword">if</span> (action.isCreateModel()) &#123;<br>            startParameter.setContinuous(<span class="hljs-literal">false</span>);<br>        &#125;<br><br>        <span class="hljs-type">CrossBuildSessionState</span> <span class="hljs-variable">crossBuildSessionState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CrossBuildSessionState</span>(<span class="hljs-built_in">this</span>.globalServices, startParameter);<br><br>        BuildActionResult var7;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">BuildSessionState</span> <span class="hljs-variable">buildSessionState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildSessionState</span>(<span class="hljs-built_in">this</span>.userHomeServiceRegistry, crossBuildSessionState, startParameter, requestContext, actionParameters.getInjectedPluginClasspath(), requestContext.getCancellationToken(), requestContext.getClient(), requestContext.getEventConsumer());<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                var7 = (BuildActionResult)buildSessionState.run((context) -&gt; &#123;<br>                    <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> context.execute(action);<br>                    <span class="hljs-type">PayloadSerializer</span> <span class="hljs-variable">payloadSerializer</span> <span class="hljs-operator">=</span> (PayloadSerializer)context.getServices().get(PayloadSerializer.class);<br>                    <span class="hljs-keyword">if</span> (result.getBuildFailure() == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">return</span> BuildActionResult.of(payloadSerializer.serialize(result.getClientResult()));<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">return</span> requestContext.getCancellationToken().isCancellationRequested() ? BuildActionResult.cancelled(payloadSerializer.serialize(result.getBuildFailure())) : BuildActionResult.failed(payloadSerializer.serialize(result.getClientFailure()));<br>                    &#125;<br>                &#125;);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var11) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    buildSessionState.close();<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable var10) &#123;<br>                    var11.addSuppressed(var10);<br>                &#125;<br><br>                <span class="hljs-keyword">throw</span> var11;<br>            &#125;<br><br>            buildSessionState.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var12) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                crossBuildSessionState.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var9) &#123;<br>                var12.addSuppressed(var9);<br>            &#125;<br><br>            <span class="hljs-keyword">throw</span> var12;<br>        &#125;<br><br>        crossBuildSessionState.close();<br>        <span class="hljs-keyword">return</span> var7;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>然后又是一番惊天地泣鬼神的任务调度以后跑到了<code>DefaultBuildTreeLifecycleController</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultBuildTreeLifecycleController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BuildTreeLifecycleController</span><br></code></pre></td></tr></table></figure>

<p>又是一个doBuild</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; T <span class="hljs-title function_">doBuild</span><span class="hljs-params">(<span class="hljs-keyword">final</span> BuildAction&lt;T&gt; build)</span> &#123;<br>       <span class="hljs-keyword">if</span> (completed) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Cannot run more than one action for this build.&quot;</span>);<br>       &#125;<br>       completed = <span class="hljs-literal">true</span>;<br>       <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>pm Move this to RunAsBuildOperationBuildActionRunner when BuildOperationWorkerRegistry scope is changed</span><br>       <span class="hljs-keyword">return</span> workerLeaseService.withLocks(Collections.singleton(workerLeaseService.getWorkerLease()), () -&gt; &#123;<br>           List&lt;Throwable&gt; failures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>           Consumer&lt;Throwable&gt; collector = failures::add;<br><br>           T result;<br>           <span class="hljs-keyword">try</span> &#123;<br>               result = build.run(buildLifecycleController, collector);<br>           &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>               result = <span class="hljs-literal">null</span>;<br>               failures.add(t);<br>           &#125;<br><br>           includedBuildControllers.finishBuild(collector);<br>           <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">reportableFailure</span> <span class="hljs-operator">=</span> exceptionAnalyser.transform(failures);<br>           buildLifecycleController.finishBuild(reportableFailure, collector);<br><br>           <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">finalReportableFailure</span> <span class="hljs-operator">=</span> exceptionAnalyser.transform(failures);<br>           <span class="hljs-keyword">if</span> (finalReportableFailure != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">throw</span> finalReportableFailure;<br>           &#125;<br><br>           <span class="hljs-keyword">return</span> result;<br>       &#125;);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>之后创建了一个构建的生命周期管理器开启构建</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">DefaultBuildLifecycleController</span><br></code></pre></td></tr></table></figure>

<p>代码有些多不贴出了，可以注意一下内部的一个枚举类</p>
<p>这代表了任务的执行周期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>        Created, Configure, TaskGraph, Finished;<br><br>        String <span class="hljs-title function_">getDisplayName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (TaskGraph == <span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Build&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Configure&quot;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>又到了<code>VintageBuildModelController</code>的doBuildStages开始构建任务。</p>
<p>这个方法看来来就很贴切</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBuildStages</span><span class="hljs-params">(Stage upTo)</span> &#123;<br>        prepareSettings();<br>        <span class="hljs-keyword">if</span> (upTo == Stage.LoadSettings) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        prepareProjects();<br>        <span class="hljs-keyword">if</span> (upTo == Stage.Configure) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        prepareTaskExecution();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>上述3个方法</p>
<ul>
<li><p>prepareSettings</p>
<p>加载编译init脚本和顶层的settings.gradle文件<strong>并执行</strong></p>
</li>
<li><p>prepareProjects</p>
<p>加载buildSrc以及build.gradle文件</p>
</li>
<li><p>prepareTaskExecution</p>
<p>执行子project的脚本文件，并执行对应的task</p>
</li>
</ul>
<p>他们只要是执行构建脚本都会先编译，然后才执行。这里涉及到一个类</p>
<p><code>DefaultScriptPluginFactory</code>(如果想对脚本的编译流程做了解的，可以看看apply方法)</p>
<p>给出的编译流程分两个步骤</p>
<blockquote>
<p>&#x2F;&#x2F; Pass 1, extract plugin requests and plugin repositories and execute buildscript {}, ignoring (i.e. not even compiling) anything else</p>
<p>第一步只编译插件请求以及插件的repositories以及执行buildscript闭包，其余的都不编译</p>
</blockquote>
<blockquote>
<p>&#x2F;&#x2F; Pass 2, compile everything except buildscript {}, pluginManagement{}, and plugin requests, then run</p>
<p>第二步是编译除开buildscript，pluginManagement以及插件请求的其余请求，并执行</p>
</blockquote>
<p>编译方法调用以后就会调用对应的执行方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">initialRunner.run(target, services);<br><br><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">buildScriptRunner</span> <span class="hljs-operator">=</span> () -&gt; runner.run(target, services);<br></code></pre></td></tr></table></figure>

<p>接着就会执行对应的构建脚本(准确来说是执行构建脚本的编译产物)。</p>
<p>上述即是gradle启动到执行构建的流程。可见的是gradle的构建其实很大程度上难度不算太大，只是回调特别的多，分支比较多，得抓主线。</p>
<h2 id="Gradle-生命周期"><a href="#Gradle-生命周期" class="headerlink" title="Gradle 生命周期"></a>Gradle 生命周期</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">DefaultBuildTreeLifecycleController<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">DefaultBuildTreeLifecycleController</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">BuildTreeLifecycleController</span><br></code></pre></td></tr></table></figure>

<p>可以发现他是<code>BuildTreeLifecycleController</code>的实现类</p>
<p>而它的注解是这样的</p>
<blockquote>
<p>Controls the lifecycle of the build tree, allowing a single action to be run against the build tree</p>
<p>控制构建树生命周期</p>
</blockquote>
<p>除此之外还要注意<code>DefaultBuildTreeLifecycleController</code>的一个成员变量<code>BuildLifecycleController</code>,它是实际的管理者。它内部有一个枚举类。对于我们解读build流程比较重要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>        Created,<br>        Configure,<br>        TaskGraph,<br>        Finished;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">State</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br><br>        String <span class="hljs-title function_">getDisplayName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> TaskGraph == <span class="hljs-built_in">this</span> ? <span class="hljs-string">&quot;Build&quot;</span> : <span class="hljs-string">&quot;Configure&quot;</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>fromBuildModel</p>
<blockquote>
<p>Configures the build, optionally schedules and runs any tasks specified in the {@link org.gradle.StartParameter} associated with the build, calls the given action and finally finishes up the build.</p>
<p>配置buiild，选择性地计划执行我们在命令行里面申明地task，执行相应地action并最后结束构建。</p>
</blockquote>
<p>Controller</p>
<blockquote>
<p>构建是具有一定的生命周期的，而生命周期的管理是采用的几个Controller进行管理的。</p>
</blockquote>
<p>DefaultBuildLifecycleController</p>
<blockquote>
<p>这个类是构建生命周期的总调度类。</p>
</blockquote>
<p>继承关系</p>
<blockquote>
<p><code>DefaultBuildLifecycleController</code>是<code>BuildLifecycleController</code>的实现类。</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">DefaultBuildLifecycleController</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">BuildLifecycleController</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>接口的注释给的也很明确。</p>
<p>Controls the lifecycle of an individual build in the build tree.</p>
<p>控制一个单独的构建的生命周期</p>
</blockquote>
<p>DefaultBuildTreeLifecycleController</p>
<blockquote>
<p>Controls the lifecycle of the build tree, allowing a single action to be run against the build tree.</p>
<p>掌控构建树的生命周期，允许单action构建树的运行。</p>
</blockquote>
<p>VintageBuildModelController</p>
<blockquote>
<p>Transitions the model of an individual build in the build tree through its lifecycle.</p>
<p>过渡构建树中的的构建的生命周期。</p>
</blockquote>
<p>State</p>
<p>状态的可以分为如下的几个</p>
<ul>
<li>Created</li>
<li>LoadSettings</li>
<li>Configure</li>
<li>TaskGraph</li>
</ul>
<p>执行过程</p>
<blockquote>
<p>如果让我直接硬分析我绝对是会崩溃的，单步调试能把人都给调试傻，gradle源码有很大一特色就是代码的调用栈特别的长，所以硬分析着实不行。</p>
</blockquote>
<blockquote>
<p>源码分析的突破口也就是全局生命周期的监听，gradle build具有生命周期，我们就直接在它对应生命周期的方法上打断点，可能在很大程度上能减轻海量调用栈的负担。</p>
</blockquote>
<p>生命周期回调</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino">gradle.beforeSettings &#123;<br>    println <span class="hljs-string">&quot;beforeSettings&quot;</span><br>&#125;<br><br>gradle.settingsEvaluated &#123;<br>    println <span class="hljs-string">&quot;settingsEvaluated&quot;</span><br>&#125;<br><br>gradle.projectsEvaluated &#123;<br>    println <span class="hljs-string">&quot;projectsEvaluated&quot;</span><br>&#125;<br><br>gradle.projectsLoaded &#123;<br>    println <span class="hljs-string">&quot;projectsLoaded&quot;</span><br>&#125;<br><br>gradle.afterProject &#123;<br>    println <span class="hljs-string">&quot;afterProject&quot;</span><br>&#125;<br><br>gradle.beforeProject &#123;<br>    println <span class="hljs-string">&quot;beforeProject&quot;</span><br>&#125;<br><br>gradle.buildFinished &#123;<br>    println <span class="hljs-string">&quot;buildFinished&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>正文</p>
<p>fromBuildModel</p>
<p>就程序停止的位置来看，选取了<code>DefaultBuildTreeLifecycleController</code>的<code>fromBuildModel</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">fromBuildModel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> runTasks, Function&lt;? <span class="hljs-built_in">super</span> GradleInternal, T&gt; action)</span> &#123;<br>    <span class="hljs-keyword">return</span> doBuild((buildController, failureCollector) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (runTasks) &#123;<br>            buildController.scheduleRequestedTasks();<br>            List&lt;Throwable&gt; failures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            workExecutor.execute(throwable -&gt; &#123;<br>                failures.add(throwable);<br>                failureCollector.accept(throwable);<br>            &#125;);<br>            <span class="hljs-keyword">if</span> (!failures.isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            buildController.getConfiguredBuild();<br>        &#125;<br>        <span class="hljs-keyword">return</span> action.apply(buildController.getGradle());<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>scheduleRequestedTasks</p>
<p>任务调度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleRequestedTasks</span><span class="hljs-params">()</span> &#123;<br>        withModel(buildModelController -&gt; &#123;<br>            state = State.TaskGraph;<br>            buildModelController.scheduleRequestedTasks();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleRequestedTasks</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!maybeLoadFromCache()) &#123;<br>        delegate.scheduleRequestedTasks();<br>        configurationCache.save();<br>    &#125; <span class="hljs-comment">// Else, already scheduled</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleRequestedTasks</span><span class="hljs-params">()</span> &#123;<br>    doBuildStages(Stage.TaskGraph);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBuildStages</span><span class="hljs-params">(Stage upTo)</span> &#123;<br>    prepareSettings();<br>    <span class="hljs-keyword">if</span> (upTo == Stage.LoadSettings) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    prepareProjects();<br>    <span class="hljs-keyword">if</span> (upTo == Stage.Configure) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    prepareTaskExecution();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="prepareSettings"><a href="#prepareSettings" class="headerlink" title="prepareSettings"></a>prepareSettings</h3><p>这里非常的绕，因为有很多方法都有多个实现类，比如这个 settingsPreparer的prepareSettings方法有三个类实现了这个类，但是到最后都会被调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareSettings</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (stage == Stage.Created) &#123;<br>        settingsPreparer.prepareSettings(gradle);<br>        stage = Stage.LoadSettings;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>BuildOperationFiringSettingsPreparer的 prepareSettings</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareSettings</span><span class="hljs-params">(GradleInternal gradle)</span> &#123;<br>    buildOperationExecutor.run(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadBuild</span>(gradle));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>跳过一些没必要的东西就执行到了doLoadBuild，经过了一系列的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">doLoadBuild</span><span class="hljs-params">()</span> &#123;<br>            BuildOperationFiringSettingsPreparer.<span class="hljs-built_in">this</span>.delegate.prepareSettings(<span class="hljs-built_in">this</span>.gradle);<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>紧接着就是判断是否是 root的settings,然后去寻找并加载settings.gradle</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareSettings</span><span class="hljs-params">(GradleInternal gradle)</span> &#123;<br>        <span class="hljs-type">SettingsLoader</span> <span class="hljs-variable">settingsLoader</span> <span class="hljs-operator">=</span> gradle.isRootBuild() ? <span class="hljs-built_in">this</span>.settingsLoaderFactory.forTopLevelBuild() : <span class="hljs-built_in">this</span>.settingsLoaderFactory.forNestedBuild();<br>        settingsLoader.findAndLoadSettings(gradle);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>然后先执行了init script</p>
<p>GradlePropertiesHandlingSettingsLoader 的 findAndLoadSettings</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SettingsInternal <span class="hljs-title function_">findAndLoadSettings</span><span class="hljs-params">(GradleInternal gradle)</span> &#123;<br>    <span class="hljs-type">SettingsLocation</span> <span class="hljs-variable">settingsLocation</span> <span class="hljs-operator">=</span> buildLayoutFactory.getLayoutFor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildLayoutConfiguration</span>(gradle.getStartParameter()));<br>    gradlePropertiesController.loadGradlePropertiesFrom(settingsLocation.getSettingsDir());<br>    <span class="hljs-keyword">return</span> delegate.findAndLoadSettings(gradle);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后又是一番惊天泣泣鬼神的调度以后开始编译执行init script </p>
<p>InitScriptHandlingSettingsLoader 的 findAndLoadSettings</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SettingsInternal <span class="hljs-title function_">findAndLoadSettings</span><span class="hljs-params">(GradleInternal gradle)</span> &#123;<br>    <span class="hljs-type">SettingsLocation</span> <span class="hljs-variable">settingsLocation</span> <span class="hljs-operator">=</span> buildLayoutFactory.getLayoutFor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildLayoutConfiguration</span>(gradle.getStartParameter()));<br>    gradlePropertiesController.loadGradlePropertiesFrom(settingsLocation.getSettingsDir());<br>    <span class="hljs-keyword">return</span> delegate.findAndLoadSettings(gradle);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里有个点很重要，在我调试的时候一度怀疑我自己看错了，就是 settings.gradle 文件被编译了两次，即上面的两段代码被执行了两次，在这里我简称 GradlePropertiesHandlingSettingsLoader 为<strong>GSL</strong> InitScriptHandlingSettingsLoader为 <strong>ISL</strong> ，当然还有一个未出现的CompositeBuildSettingsLoader为 <strong>CSL</strong></p>
<img src="https://gitee.com/ye-shenghao/typora-huawei-pic/raw/master/img/image-20220723214008137.png" srcset="/img/loading.gif" lazyload alt="image-20220723214008137" style="zoom:67%;" />

<blockquote>
<p> 至于为什么，这其实和gradle的特性有关，为什么build.gradle文件的后缀名为 .gradle 而不是 .grovvy ，因为gradle文件会先按照 groovy 语法执行 setting.gradle文件，从而使该文件变成 gradle文件，第二次再用 gradle 语法执行一遍，所以就是为什么会执行两次，不单单是 setting.gradle 文件，任何 gradle文件都是如此</p>
</blockquote>
<p>最后的最后，经过一系列的 findAndLoadSettings，到了最后一个 DefaultSettingsLoader的 findAndLoadSettings方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SettingsInternal <span class="hljs-title function_">findAndLoadSettings</span><span class="hljs-params">(GradleInternal gradle)</span> &#123;<br>    <span class="hljs-type">StartParameter</span> <span class="hljs-variable">startParameter</span> <span class="hljs-operator">=</span> gradle.getStartParameter();<br><br>    <span class="hljs-type">SettingsLocation</span> <span class="hljs-variable">settingsLocation</span> <span class="hljs-operator">=</span> buildLayoutFactory.getLayoutFor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildLayoutConfiguration</span>(startParameter));<br><br>    <span class="hljs-type">SettingsInternal</span> <span class="hljs-variable">settings</span> <span class="hljs-operator">=</span> findSettingsAndLoadIfAppropriate(gradle, startParameter, settingsLocation, gradle.getClassLoaderScope());<br>    <span class="hljs-type">ProjectSpec</span> <span class="hljs-variable">spec</span> <span class="hljs-operator">=</span> ProjectSpecs.forStartParameter(startParameter, settings);<br>    <span class="hljs-keyword">if</span> (useEmptySettings(spec, settings, startParameter)) &#123;<br>        settings = createEmptySettings(gradle, startParameter, settings.getClassLoaderScope());<br>    &#125;<br><br>    setDefaultProject(spec, settings);<br>    <span class="hljs-keyword">return</span> settings;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>beforeSettings</strong></p>
<p>initScript执行以后就会去执行SettingsScript</p>
<p>准备执行settings.gradle,调用beforeSettings方法，最后引入插件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSettings</span><span class="hljs-params">(Action&lt;? <span class="hljs-built_in">super</span> Settings&gt; action)</span> &#123;<br>       buildListenerBroadcast.add(<span class="hljs-string">&quot;beforeSettings&quot;</span>, action);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>插件的引入还是和init script的一样</p>
<p>紧接着又是二次编译，二次执行(不贴了)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applySettingsScript</span><span class="hljs-params">(TextResourceScriptSource settingsScript, SettingsInternal settings)</span> &#123;<br>       <span class="hljs-type">ScriptPlugin</span> <span class="hljs-variable">configurer</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.configurerFactory.create(settingsScript, settings.getBuildscript(), settings.getClassLoaderScope(), settings.getBaseClassLoaderScope(), <span class="hljs-literal">true</span>);<br>       configurer.apply(settings);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p><strong>settingsEvaluated</strong></p>
<p>上述执行完成以后就会调用gradle的回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SettingsInternal <span class="hljs-title function_">process</span><span class="hljs-params">(GradleInternal gradle, SettingsLocation settingsLocation, ClassLoaderScope buildRootClassLoaderScope, StartParameter startParameter)</span> &#123;<br>        <span class="hljs-type">SettingsInternal</span> <span class="hljs-variable">settings</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.delegate.process(gradle, settingsLocation, buildRootClassLoaderScope, startParameter);<br>        gradle.getBuildListenerBroadcaster().settingsEvaluated(settings);<br>        settings.preventFromFurtherMutation();<br>        <span class="hljs-keyword">return</span> settings;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>之后就是确保include的project不包含buildSrc（也就是说settings.gradle管理的子project名称不可以是buildSrc，详细可见代码）</p>
<p><strong>includeBuild</strong></p>
<p>准备开始includeBuild</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SettingsInternal <span class="hljs-title function_">findAndLoadSettings</span><span class="hljs-params">(GradleInternal gradle)</span> &#123;<br>    <span class="hljs-type">SettingsInternal</span> <span class="hljs-variable">settings</span> <span class="hljs-operator">=</span> delegate.findAndLoadSettings(gradle);<br><br>    <span class="hljs-comment">// Add all included builds from the command-line</span><br>    <span class="hljs-keyword">for</span> (File rootDir : gradle.getStartParameter().getIncludedBuilds()) &#123;<br>        settings.includeBuild(rootDir);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> settings;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后includeBuild又会去new一个<code>DefaultBuildLifecycleController</code>又走一套流程</p>
<p>只不过呢这里upTo是LoadSettings，也就是说只执行一个sttings操作。</p>
<p>prepareSettings又会先去执行init script然后执行settings.gradle</p>
<p>这样root project的prepareSettings就执行完了</p>
<p><strong>小节</strong></p>
<ul>
<li>rootProject下的prepareSettings先回调用init script然后再调用对应的settings script，然后再去执行includeBuild的prepareSettings去加载includeBuilde的settings script。</li>
<li>beforeSettings触发时间在init script加载之后，在settings执行以前</li>
<li>settingsEvaluated触发时间在settings执行以后</li>
<li>seethingsEvaluated触发时间在settingsEvaluated闭包执行以后</li>
</ul>
<h3 id="prepareProjects"><a href="#prepareProjects" class="headerlink" title="prepareProjects"></a>prepareProjects</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareProjects</span><span class="hljs-params">(GradleInternal gradle)</span> &#123;<br>        <span class="hljs-type">SettingsInternal</span> <span class="hljs-variable">settings</span> <span class="hljs-operator">=</span> gradle.getSettings();<br>        <span class="hljs-type">ClassLoaderScope</span> <span class="hljs-variable">settingsClassLoaderScope</span> <span class="hljs-operator">=</span> settings.getClassLoaderScope();<br>        <span class="hljs-type">ClassLoaderScope</span> <span class="hljs-variable">buildSrcClassLoaderScope</span> <span class="hljs-operator">=</span> settingsClassLoaderScope.createChild(<span class="hljs-string">&quot;buildSrc[&quot;</span> + gradle.getIdentityPath() + <span class="hljs-string">&quot;]&quot;</span>);<br>        gradle.setBaseProjectClassLoaderScope(buildSrcClassLoaderScope);<br>        <span class="hljs-built_in">this</span>.generateDependenciesAccessorsAndAssignPluginVersions(gradle.getServices(), settings, buildSrcClassLoaderScope);<br>        <span class="hljs-built_in">this</span>.buildLoader.load(gradle.getSettings(), gradle);<br>        <span class="hljs-keyword">if</span> (gradle.isRootBuild()) &#123;<br>            <span class="hljs-built_in">this</span>.buildStateRegistry.beforeConfigureRootBuild();<br>        &#125;<br><br>        <span class="hljs-built_in">this</span>.buildBuildSrcAndLockClassloader(gradle, buildSrcClassLoaderScope);<br>        <span class="hljs-built_in">this</span>.delegate.prepareProjects(gradle);<br>        <span class="hljs-keyword">if</span> (gradle.isRootBuild()) &#123;<br>            <span class="hljs-built_in">this</span>.buildStateRegistry.afterConfigureRootBuild();<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>projectsLoaded</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">projectsLoaded</span><span class="hljs-params">(Action&lt;? <span class="hljs-built_in">super</span> Gradle&gt; action)</span> &#123;<br>    assertProjectMutatingMethodAllowed(<span class="hljs-string">&quot;projectsLoaded(Action)&quot;</span>);<br>    buildListenerBroadcast.add(<span class="hljs-string">&quot;projectsLoaded&quot;</span>, getListenerBuildOperationDecorator().decorate(<span class="hljs-string">&quot;Gradle.projectsLoaded&quot;</span>, action));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>紧接着就是判断该build是不是顶层的build(gradle的build过程类似于一个树的结构，顶层的向下一直扩展新的build，root build也就是最顶层的build，它的parent为null)</p>
<p>如果是就做一些其他的操作</p>
<p>执行includeBuild</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeConfigureRootBuild</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.registerSubstitutions();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerSubstitutions</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.libraryBuilds.values().iterator();<br><br>        <span class="hljs-keyword">while</span>(var1.hasNext()) &#123;<br>            <span class="hljs-type">IncludedBuildState</span> <span class="hljs-variable">includedBuild</span> <span class="hljs-operator">=</span> (IncludedBuildState)var1.next();<br>            <span class="hljs-built_in">this</span>.currentlyConfiguring.add(includedBuild);<br>            <span class="hljs-built_in">this</span>.dependencySubstitutionsBuilder.build(includedBuild);<br>            <span class="hljs-built_in">this</span>.currentlyConfiguring.remove(includedBuild);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>紧接着就又执行到了doBuildStage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> GradleInternal <span class="hljs-title function_">getConfiguredModel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.doBuildStages(VintageBuildModelController.Stage.Configure);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.gradle;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>然后就执行到了熟悉的代码片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareProjects</span><span class="hljs-params">(GradleInternal gradle)</span> &#123;<br>        <span class="hljs-type">SettingsInternal</span> <span class="hljs-variable">settings</span> <span class="hljs-operator">=</span> gradle.getSettings();<br>        <span class="hljs-type">ClassLoaderScope</span> <span class="hljs-variable">settingsClassLoaderScope</span> <span class="hljs-operator">=</span> settings.getClassLoaderScope();<br>        <span class="hljs-type">ClassLoaderScope</span> <span class="hljs-variable">buildSrcClassLoaderScope</span> <span class="hljs-operator">=</span> settingsClassLoaderScope.createChild(<span class="hljs-string">&quot;buildSrc[&quot;</span> + gradle.getIdentityPath() + <span class="hljs-string">&quot;]&quot;</span>);<br>        gradle.setBaseProjectClassLoaderScope(buildSrcClassLoaderScope);<br>        <span class="hljs-built_in">this</span>.generateDependenciesAccessorsAndAssignPluginVersions(gradle.getServices(), settings, buildSrcClassLoaderScope);<br>        <span class="hljs-built_in">this</span>.buildLoader.load(gradle.getSettings(), gradle);<br>        <span class="hljs-keyword">if</span> (gradle.isRootBuild()) &#123;<br>            <span class="hljs-built_in">this</span>.buildStateRegistry.beforeConfigureRootBuild();<br>        &#125;<br><br>        <span class="hljs-built_in">this</span>.buildBuildSrcAndLockClassloader(gradle, buildSrcClassLoaderScope);<br>        <span class="hljs-built_in">this</span>.delegate.prepareProjects(gradle);<br>        <span class="hljs-keyword">if</span> (gradle.isRootBuild()) &#123;<br>            <span class="hljs-built_in">this</span>.buildStateRegistry.afterConfigureRootBuild();<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>先回去执行buildSrc然后才会去prepareProjects</p>
<p>然后他呢又会依次去调用每一个字project的configure</p>
<p>最后prepareProjects执行结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureHierarchy</span><span class="hljs-params">(ProjectInternal project)</span> &#123;<br>       <span class="hljs-built_in">this</span>.configure(project);<br>       <span class="hljs-type">Iterator</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> project.getSubprojects().iterator();<br><br>       <span class="hljs-keyword">while</span>(var2.hasNext()) &#123;<br>           <span class="hljs-type">Project</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> (Project)var2.next();<br>           <span class="hljs-built_in">this</span>.configure((ProjectInternal)sub);<br>       &#125;<br><br>   &#125;<br></code></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<p>当调用root build下的prepareProjects时候，先会去执行初始化，配置，执行buildSrc的内容，然后遍历所有的子project进行配置操作。</p>
<h3 id="prepareTaskExecution"><a href="#prepareTaskExecution" class="headerlink" title="prepareTaskExecution"></a>prepareTaskExecution</h3><p>调用了doBuild</p>
<p>执行了所有的相应的task</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">fromBuildModel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> runTasks, Function&lt;? <span class="hljs-built_in">super</span> GradleInternal, T&gt; action)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.doBuild((buildController, failureCollector) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (runTasks) &#123;<br>                buildController.scheduleRequestedTasks();<br>                List&lt;Throwable&gt; failures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>                <span class="hljs-built_in">this</span>.workExecutor.execute((throwable) -&gt; &#123;<br>                    failures.add(throwable);<br>                    failureCollector.accept(throwable);<br>                &#125;);<br>                <span class="hljs-keyword">if</span> (!failures.isEmpty()) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                buildController.getConfiguredBuild();<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> action.apply(buildController.getGradle());<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>gradle构建是存有生命周期的，状态呢大致可分为3个初始化，配置，执行<ul>
<li>初始化过程主要是settings.gradle的执行以及一些init.gradle的执行</li>
<li>配置主要是build.gradle的执行以及buildSrc的执行(通常的buildSrc是最先执行的)</li>
<li>执行过程主要是执行我们在terminal里面定义的task</li>
</ul>
</li>
<li>gradle的构建是依靠<code>VintageBuildModelController</code>的<code>doBuildStages</code>调度执行。(<code>VintageBuildModelController</code>可以看成是build生命周期的管理者，除此之外还有两个与gradle build生命周期相关的类分别是<code>BuildLifecycleController</code>和<code>BuildTreeLifecycleController</code>)<ul>
<li>doBuildStages有一个新参，upTo表明了代码要执行到哪个生命周期</li>
<li>对应有4个状态Created, LoadSettings, Configure, TaskGraph</li>
<li>Created, LoadSettings表明只执行到<code>prepareSettings</code></li>
<li>Configure表明执行到<code>prepareProjects</code></li>
<li>TaskGraph表明执行到<code>prepareTaskExecution</code></li>
</ul>
</li>
<li>&#96;doBuildStages其实和build的三个生命周期状态是吻合的<ul>
<li>prepareSettings对应初始化</li>
<li>prepareProjects对应配置</li>
<li>prepareTaskExecution对应执行</li>
</ul>
</li>
<li>gradle的构建是从顶层开始执行的，依次调用prepareSettings，prepareProjects，prepareTaskExecution。在调用这3个方法的过程中会触发其他的controller的doBuildStages对某一个特定的模块进行构建，所以整个构建的流程其实不是完全按照模块的顺序进行执行的。执行顺序大体如下<ul>
<li>prepareSettings会先把root模块下的settings.gradle编译执行，然后去编译执行所有includeBuild的settings.gradle。</li>
<li>prepareProjects先会去编译执行includeBuild的build.gradle然后走完buildSrc的全套生命周期，之后去编译执行root模块以及它的所有子模块的build.gradle</li>
<li>prepareTaskExecution会执行root模块以及所有子project相应的task</li>
</ul>
</li>
</ul>
<p>整体看下来，其实 Gradle 的生命周期比起前面的内容要容易理解的多，并且更有迹可循，而源码部分到这里就讲完了，gradle的源码并没有那么难，不过还是希望你们能够自己跟着课件上的思路去调试一遍，因为时间问题，可能跳过了部分代码，并且自己真正去调试也会有更大的收获。</p>
<h1 id="Part2-——-Gradle基础"><a href="#Part2-——-Gradle基础" class="headerlink" title="Part2 —— Gradle基础"></a>Part2 —— Gradle基础</h1><h2 id="1-认识-Gradle"><a href="#1-认识-Gradle" class="headerlink" title="1. 认识 Gradle"></a>1. 认识 Gradle</h2><p>Gradle 并不仅仅是一个语言，而是一套构建工具。在早期，软件构建只有编译和打包等简单需求，但软件开发的发展，现在的构建变得更加复杂。而构建工具就是在这一背景下衍生出来的工具链，它能够帮助开发者可重复、自动化地生成目标产物。例如 Ant、Maven 和 ivy 也是历史演化过程中诞生的构建工具。</p>
<h3 id="1-1-Gradle-的优缺点"><a href="#1-1-Gradle-的优缺点" class="headerlink" title="1.1 Gradle 的优缺点"></a>1.1 Gradle 的优缺点</h3><p>相比于早期出现的构建工具，Gradle 能够脱颖而出主要是以下优点：</p>
<ul>
<li><strong>表达性的 DSL：</strong> Gradle 构建脚本采用基于 Groovy 的 DSL 领域特定语言，而不是采用传统的 XML 文件，相比 Maven 等构建系统更加简洁；</li>
<li><strong>基于 Java 虚拟机：</strong> Groovy 语言基于 Java 虚拟机，这使得 Gradle 支持用 Java &#x2F; Kotlin 代码编写构建脚本，我们完全可以只学习一小部分 Groovy 语法就能上手 Gradle 脚本，降低了 Gradle 的学习强度；</li>
<li><strong>约定优先于配置：</strong> Gradle 具有约定优先于配置的原则，即为属性提供默认值，相比 Ant 等构建系统更容易上手。我们在开发 Gradle 插件时也需要遵循这一原则。</li>
</ul>
<p>Gradle 也有明显的缺点，例如：</p>
<ul>
<li><strong>较弱的向后兼容性：</strong> Gradle 是一个快速发展的工具，新版本经常会打破向后兼容性，有经验的同学就知道，一个工程在低版本 Gradle 可以编译，但换了新版本 Gradle 可能就编译不通过了。</li>
</ul>
<h3 id="1-2-Gradle-工程的基本结构"><a href="#1-2-Gradle-工程的基本结构" class="headerlink" title="1.2 Gradle 工程的基本结构"></a>1.2 Gradle 工程的基本结构</h3><p>在 Android Studio 中创建新项目时，会自动生成以下与 Gradle 相关文件。这些大家都很熟悉了，简单梳理下各个文件的作用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">.<br>├── a-subproject<br>│   └── build.gradle<br>├── build.gradle<br>├── settings.gradle<br>├── gradle.properties<br>├── local.properties<br>├── gradle<br>│   └── wrapper<br>│       ├── gradle-wrapper.jar<br>│       └── gradle-wrapper.properties<br>├── gradlew<br>└── gradlew.bat<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>settings.gradle 文件：</strong> 用于确定哪些模块参与构建；</li>
<li><strong>项目级 build.gradle 文件：</strong> 用于定义所有子模块公共的配置参数；</li>
<li><strong>模块级 build.gradle 文件：</strong> 用于定义子模块的配置参数，它可以覆盖项目级 build.gradle 文件中定义的配置；</li>
<li><strong>gradle&#x2F;warpper：</strong> 负责自动下载安装项目所需的 Gradle 环境的脚本；</li>
<li><strong>gradle.properties：</strong> 用作项目级 Gradle 配置项，会覆盖全局的配置项；</li>
<li><strong>local.properties：</strong> 用作项目的私有属性配置，例如 SDK 安装目录，一般不把 local.properties 加入版本控制。</li>
</ul>
<h3 id="1-3-Gradle-中的重要概念"><a href="#1-3-Gradle-中的重要概念" class="headerlink" title="1.3 Gradle 中的重要概念"></a>1.3 Gradle 中的重要概念</h3><ul>
<li><strong>Gradle：</strong> 提供核心构建流程，但不提供具体构建逻辑；</li>
<li><strong>Gradle 插件：</strong> Gradle 提供的是一套核心的构建机制，而 Gradle 插件正是运行在这套机制上的一些具体构建逻辑，本质上和 .gradle 文件没有区别。例如，我们熟悉的 Android 构建流程就是由 Android Gradle Plugin 引入的构建逻辑；</li>
<li><strong>Gradle Daemon：</strong> 用于提升构建速度的后台进程；</li>
<li><strong>Gradle Wrapper：</strong> 对 Gradle 的封装，增加了自动下载安装 Gradle 环境的能力；</li>
<li><strong>环境变量 GRADLE：</strong> 用于定义 Gradle 的安装目录；</li>
<li><strong>环境变量 GRADLE_USER_HOME：</strong> 用于定义 Gradle 运行过程的文件存储目录，例如 Gradle Wrapper 自动安装的 Gradle 环境、构建缓存等；</li>
</ul>
<h3 id="1-4-Gradle-Daemon"><a href="#1-4-Gradle-Daemon" class="headerlink" title="1.4 Gradle Daemon"></a>1.4 Gradle Daemon</h3><p><strong><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://docs.gradle.org/current/userguide/gradle_daemon.html">Gradle Daemon</a> 是 Gradle 3.0 引入的构建优化策略，通过规避重复创建 JVM 和内存缓存的手段提升了构建速度。</strong> Daemon 进程才是执行构建的进程，当构建结束后，Daemon 进程并不会立即销毁，而是保存在内存中等待承接下一次构建。根据官方文档说明，Gradle Daemon 能够降低 15-75% 的构建时间。</p>
<p>Daemon 的优化效果主要体现在 3 方面：</p>
<ul>
<li><strong>1、缩短 JVM 虚拟机启动时间：</strong> 不需要重复创建；</li>
<li><strong>2、JIT 编译：</strong> Daemon 进程会执行 JIT 编译，有助于提升后续构建的字节码执行效率；</li>
<li><strong>3、构建缓存：</strong> 构建过程中加载的类、资源或者 Task 的输入和输出会保存在内存中，可以被后续构建复用。</li>
</ul>
<p>相关的 Gradle 命令：</p>
<ul>
<li><strong>gradle —status：</strong> 查看存活的 Daemon 进程信息；</li>
<li><strong>gradle —stop：</strong> 停止所有 Daemon 进程。</li>
</ul>
<blockquote>
<p><strong>提示：</strong> 并不是所有的构建都会复用同一个 Daemon 进程，如果已存活的 Daemon 进程无法满足新构建的需求，则 Gradle 会新建一个新的 Daemon 进程。影响因素：</p>
<ul>
<li>Gradle 版本： 不同 Gradle 版本的构建不会关联到同一个 Daemon 进程；</li>
<li>Gradle 虚拟机参数： 不满足的虚拟机参数不会关联到同一个 Daemon 进程。</li>
</ul>
</blockquote>
<h3 id="1-5-Gradle-Wrapper"><a href="#1-5-Gradle-Wrapper" class="headerlink" title="1.5 Gradle Wrapper"></a>1.5 Gradle Wrapper</h3><p><strong>Gradle Wrapper 本质是对 Gradle 的一层包装，会在执行 Gradle 构建之前自动下载安装 Gradle 环境。</strong> 在开始执行 Gradle 构建时，如果当前设备中还未安装所需版本的 Gradle 环境，Gradle Wrapper 会先帮你下载安装下来，将来其他需要这个 Gradle 版本的工程也可以直接复用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10107787-39def5ca3adb114d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/877/format/webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>Android Studio 默认使用 Gradle Wrapper 执行构建，你可以在设置中修改这一行为：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10107787-9a363839b0d3b328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>命令行也有区分：</p>
<ul>
<li><code>gradle</code> ：使用系统环境变量定义的 Gradle 环境进行构建；</li>
<li><code>gradlew</code> ：使用 Gradle Wrapper 执行构建。</li>
</ul>
<p>为什么 Gradle 官方从早期就专门推出一个自动安装环境工具呢，我认为原因有 2 个：</p>
<ul>
<li><strong>确保 Gradle 版本正确性：</strong> 鉴于 Gradle 有较弱向后兼容性的特点，Gradle Wrapper 能够从项目工程级别固化项目所需要的 Gradle 版本，从而确保同一个工程移植到其他电脑后能够正确地、可重复地构建；</li>
<li><strong>减少了手动安装 Gradle 环境的工作量：</strong> 单单从 Gradle 4 到 Gradle 7 就有大大小小十几个版本，而且每个工程所需要的 Gradle 版本不尽相同，使用 Gradle Wrapper 能够减少手动安装环境的工作量；</li>
</ul>
<p>简单说下 Gradle Wrapper 相关的文件，主要有 4 个：</p>
<ul>
<li><p><strong>gradlew &amp; gradlew.bat：</strong> 在 Linux 或 Mac 上可用的 Shell 脚本，以及在 Window 上可用的 Batch 脚本，用于以 Gradle Wrapper 的方式执行构建。也就是说，在命令行使用 <code>gradlew</code> 才是基于 Gradle Wrapper 执行的，而使用 <code>gradle</code> 命令是直接基于系统安装的 Gradle 环境执行编译；</p>
</li>
<li><p><strong>gradle-wrapper.jar：</strong> 负责下载安装 Gradle 环境的脚本；</p>
</li>
<li><p>gradle-wrapper.properties：</p>
<p> Gradle Wrapper 的配置文件，主要作用是决定 Gradle 版本和安装目录：</p>
<ul>
<li>distributionBase + distributionPath：指定 Gradle 环境安装路径；</li>
<li>zipStoreBase + zipStorePath：指定 Gradle 安装包的存储路径；</li>
<li>distributionUrl：指定版本 Gradle 的下载地址，通过这个参数可以配置项目工程所需要的 Gradle 版本。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">distributionBase=GRADLE_USER_HOME<br>distributionPath=wrapper/dists<br>distributionUrl=https\:<span class="hljs-comment">//services.gradle.org/distributions/gradle-6.0.1-bin.zip</span><br>zipStoreBase=GRADLE_USER_HOME<br>zipStorePath=wrapper/dists<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示：</strong> GRADLE_USER_HOME 的默认值是 <code>用户目录/.gradle</code>，可以通过系统环境变量 GRADLE_USER_HOME 修改。</p>
</blockquote>
<h3 id="1-6-gradle-properties-构建环境配置"><a href="#1-6-gradle-properties-构建环境配置" class="headerlink" title="1.6 gradle.properties 构建环境配置"></a>1.6 gradle.properties 构建环境配置</h3><p>Gradle 是运行在 Java 虚拟机的，gradle.properties 文件可以配置 Gradle 构建的运行环境，并且会覆盖 Android Studio 设置中的全局配置，完整构建环境配置见官方文档：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://docs.gradle.org/current/userguide/build_environment.html">Build Enviroment</a>。常用的配置项举例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"># Gradle Daemon 开关，默认 ture<br>org.gradle.daemon=<span class="hljs-literal">true</span>  <br><br># 虚拟机参数<br>org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-<span class="hljs-number">8</span><br><br># 多模块工程并行编译多个模块，会消耗更多内存<br>org.gradle.parallel=<span class="hljs-literal">true</span>  <br></code></pre></td></tr></table></figure>

<p>除了构建环境配置，其他配置也可以用类似的键值对方式放在 gradle.properties 中，并直接在 .gradle 文件中引用。</p>
<hr>
<h2 id="2-Groovy-必知必会"><a href="#2-Groovy-必知必会" class="headerlink" title="2. Groovy 必知必会"></a>2. Groovy 必知必会</h2><p>Groovy 是从 Java 虚拟机衍生出来的语言，由于我们都具备一定的 Java 基础，所以我们没有必要完全从零开始学习 Groovy。梳理 Groovy 与 Java 之间有差异的地方，或许是更高效的学习方式：</p>
<h3 id="2-1-一些小差异"><a href="#2-1-一些小差异" class="headerlink" title="2.1 一些小差异"></a>2.1 一些小差异</h3><ul>
<li><p><strong>分号：</strong> 语句允许不以分号 ; 结尾；</p>
</li>
<li><p><strong>public：</strong> 默认的访问修饰符为 public；</p>
</li>
<li><p><strong>getter &#x2F; setter：</strong> Groovy 会为每个 field 创建对应的 getter &#x2F; setter 方法，在访问 obj.field &#x2F; obj.field&#x3D;”” 时，实际上是在访问 getField() 和 setField(””)；</p>
</li>
<li><p><strong>支持静态类型和动态类型：</strong> Groovy 既支持 Java 的静态类型，也支持通过 <code>def</code> 关键字声明动态类型（静态类型和动态类型的关键区别在于 ”类型检查是否倾向于在编译时执行“。例如 Java 是静态类型语言，意味着类型检查主要由编译器在编译时完成）；</p>
</li>
<li><p>字符串：</p>
<p> Groovy 支持三种格式定义字符串 —— 单引号、双引号和三引号</p>
<ul>
<li>单引号：纯粹的字符串，与 Java 的双引号字符串类似；</li>
<li>双引号：支持在引号内通过 $ 关键字直接引用变量值；</li>
<li>三引号：支持换行。</li>
</ul>
</li>
</ul>
<h3 id="2-2-函数"><a href="#2-2-函数" class="headerlink" title="2.2 函数"></a>2.2 函数</h3><ul>
<li><strong>函数定义：</strong> Groovy 支持通过返回类型或 def 关键字定义函数。def 关键字定义的函数如果没有 return 关键字返回值，则默认会返回 null。例如：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用 def 关键字</span><br>def methodName() &#123;<br>    <span class="hljs-comment">// Method Code</span><br>&#125;<br><br>String methodName() &#123;<br>    <span class="hljs-comment">// Method Code</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>参数名：</strong> Groovy 支持不指定参数类型。例如：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 省略参数类型</span><br>def methodName(param1, param2) &#123;<br>    <span class="hljs-comment">// Method Code</span><br>&#125;<br><br>def methodName(String param1, String param2) &#123;<br>    <span class="hljs-comment">// Method Code</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>默认参数：</strong> Groovy 支持指定函数参数默认值，默认参数必须放在参数列表末尾。例如：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def methodName(param1, param2 = <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// Method Code</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>返回值：</strong> 可以省略 return，默认返回最后一行语句的值。例如：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def methodName() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;返回值&quot;</span><br>&#125;<br>等价于<br>def methodName() &#123;<br>    <span class="hljs-string">&quot;返回值&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>invokeMethod &amp; methodMissing：<ul>
<li><strong>invokeMethod：</strong> 分派对象上所有方法调用，包括已定义和未定义的方法，需要实现 GroovyInterceptable 接口；</li>
<li><strong>methodMissing：</strong> 分派对象上所有为定义方法的调用。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 实现 GroovyInterceptable 接口，才会把方法调用分派到 invokeMethod。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-title">implements</span> <span class="hljs-title">GroovyInterceptable</span>&#123;<br>    def name;<br><br>    def hello() &#123;<br>        println <span class="hljs-string">&quot;Hello <span class="hljs-subst">$&#123;name&#125;</span>&quot;</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    Object invokeMethod(String name, Object args) &#123;<br>        System.<span class="hljs-keyword">out</span>.println <span class="hljs-string">&quot;invokeMethod : <span class="hljs-variable">$name</span>&quot;</span><br>    &#125;<br>&#125;<br><br>def student = new Student(name: <span class="hljs-string">&quot;Tom&quot;</span>)<br><br>student.hello()<br>student.hello1()<br><br>输出：<br>invokeMethod : hello<br>invokeMethod : hello1<br><br>-------------------------------------------------------------<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    def name;<br><br>    def hello() &#123;<br>        println <span class="hljs-string">&quot;Hello <span class="hljs-subst">$&#123;name&#125;</span>&quot;</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    Object methodMissing(String name, Object args) &#123;<br>        System.<span class="hljs-keyword">out</span>.println <span class="hljs-string">&quot;methodMissing : <span class="hljs-variable">$name</span>&quot;</span><br>    &#125;<br>&#125;<br><br>def student = new Student(name: <span class="hljs-string">&quot;Tom&quot;</span>)<br><br>student.hello()<br>student.hello1()<br><br>输出：<br>Hello Tom<br>methodMissing hello1<br></code></pre></td></tr></table></figure>

<h3 id="2-3-集合"><a href="#2-3-集合" class="headerlink" title="2.3 集合"></a>2.3 集合</h3><p>Groovy 支持通过 [] 关键字定义 List 列表或 Map 集合：</p>
<ul>
<li><strong>列表：</strong> 例如 def list &#x3D; [1, 2, 3, 4]</li>
<li><strong>集合：</strong> 例如 def map &#x3D; [’name’:’Tom’, ‘age’:18]，空集合 [:]</li>
<li><strong>范围：</strong> 例如 def range &#x3D; 1 .. 10</li>
<li><strong>遍历：</strong></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 列表</span><br>def list = [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]<br>list.each &#123; value -&gt;<br>&#125;<br>list.eachWIthIndex &#123; value, index -&gt;<br>&#125;<br><br><span class="hljs-comment">// 集合</span><br>def map = [’name’:’Tom’, ‘age’:<span class="hljs-number">18</span>]<br>map.each &#123; key, value -&gt;<br>&#125;<br>map.eachWithIndex &#123; entry, index -&gt;<br>&#125;<br>map.eachWithIndex &#123; key, value, index -&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-4-闭包"><a href="#2-4-闭包" class="headerlink" title="2.4 闭包"></a>2.4 闭包</h3><p>Groovy 闭包是一个匿名代码块，可以作为值传递给变量或函数参数，也可以接收参数和提供返回值，形式上与 Java &#x2F; Kotlin 的 lambda 表达式类似。例如以下是有效的闭包：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&#123; <span class="hljs-number">123</span> &#125;                                          <br><br>&#123; -&gt; <span class="hljs-number">123</span> &#125;                                       <br><br>&#123; println it &#125;<br><br>&#123; it -&gt; println it &#125;<br><br>&#123; name -&gt; println name &#125;                            <br><br>&#123; String x, int y -&gt;                                <br>    println <span class="hljs-string">&quot;hey <span class="hljs-subst">$&#123;x&#125;</span> the value is <span class="hljs-subst">$&#123;y&#125;</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>闭包类型：</strong> Groovy 将闭包定义为  <code>groovy.lang.Closure</code> 的实例，使得闭包可以像其他类型的值一样复制给变量。例如：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Closure c = &#123; <span class="hljs-number">123</span> &#125;<br><br><span class="hljs-comment">// 当然也可以用 def 关键字</span><br>def c = &#123; <span class="hljs-number">123</span> &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>闭包调用：</strong> 闭包可以像方法一样被调用，可以通过 Closure#call() 完成，也可以直接通过变量完成。例如：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def c = &#123; <span class="hljs-number">123</span> &#125;<br><br><span class="hljs-comment">// 通过 Closure#call() 调用</span><br>c.call()<br><br><span class="hljs-comment">// 直接通过变量名调用</span><br>c()<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>隐式参数：</strong> 闭包默认至少有一个形式参数，如果闭包没有显式定义参数列表（使用 <code>→</code>），Groovy 总是带有隐式添加一个参数 it。如果调用者没有使用任何实参，则 it 为空。当你需要声明一个不接收任何参数的闭包，那么必须用显式的空参数列表声明。例如：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 带隐式参数 it</span><br>def greeting = &#123; <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$it</span>!&quot;</span> &#125;<br>assert greeting(<span class="hljs-string">&#x27;Patrick&#x27;</span>) == <span class="hljs-string">&#x27;Hello, Patrick!&#x27;</span><br><br><span class="hljs-comment">// 不带隐式参数 it</span><br>def magicNumber = &#123; -&gt; <span class="hljs-number">42</span> &#125;<br><span class="hljs-comment">// error 不允许传递参数</span><br>magicNumber(<span class="hljs-number">11</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>闭包参数简化：</strong> 函数的最后一个参数是闭包类型的化，在调用时可以简化，省略圆括号：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def methodName(String param1, Closure closure) &#123;<br>    <span class="hljs-comment">// Method Code</span><br>&#125;<br><br><span class="hljs-comment">// 调用：</span><br>methodName(<span class="hljs-string">&quot;Hello&quot;</span>) &#123;<br>    <span class="hljs-comment">// Closure Code</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>this、owner、delegate：</p>
<p> 闭包委托是 Groovy Closure 相比 Java Lambda 最大的区别，通过修改闭包的委托可以实现灵活多样的 DSL。先认识闭包中的三个变量：</p>
<ul>
<li><strong>this：</strong> 定义闭包的外部类，this 一定指向类对象；</li>
<li><strong>owner：</strong> 定义闭包的外部对象，owner 可能是类对象，也可能是更外一层的闭包；</li>
<li><strong>delegate：</strong> 默认情况 delegate 等同于 owner，this 和 owner 的语义无法修改，而 delegate 可以修改。</li>
</ul>
</li>
<li><p><strong>闭包委托策略：</strong> 在闭包中，如果一个属性没有显式声明接收者对象，则会通过闭包代理解析策略寻找定义的对象，例如：</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name<br>&#125;<br>def p = new Person(name:<span class="hljs-string">&#x27;Igor&#x27;</span>)<br>def cl = &#123; <br>    <span class="hljs-comment">// 相当于 delegate.name.toUpperCase()</span><br>    name.toUpperCase() <br>&#125;                 <br>cl.delegate = p                                 <br>assert cl() == <span class="hljs-string">&#x27;IGOR&#x27;</span><br></code></pre></td></tr></table></figure>

<p>闭包定义了多种解析策略，可以通过 <code>Closure#resolveStrategy=Closure.DELEGATE_FIRST</code> 修改：</p>
<ul>
<li><strong>Closure.OWNER_FIRST（默认）：</strong> 优先在 owner 对象中寻找，再去 delegate 对象中寻找；</li>
<li><strong>Closure.DELEGATE_FIRST：</strong> 优先在 delegate 对象中寻找，再去 owner 对象中寻找；</li>
<li><strong>Closure.OWNER_ONLY：</strong> 只在 owner 对象中寻找；</li>
<li><strong>Closure.DELEGATE_ONLY：</strong> 只在 delegate 对象中寻找；</li>
<li><strong>Closure.TO_SELF：</strong> 只在闭包本身寻找；</li>
</ul>
<hr>
<h2 id="3-Gradle-构建生命周期"><a href="#3-Gradle-构建生命周期" class="headerlink" title="3. Gradle 构建生命周期"></a>3. Gradle 构建生命周期</h2><p>Gradle 将构建划分为三个阶段： <strong>初始化 - 配置 - 执行</strong> 。理解构建生命周期（Gradle Build Lifecycle）非常重要，否则你可能连脚本中的每个代码单元的执行时机都搞不清楚。</p>
<h3 id="3-1-初始化阶段"><a href="#3-1-初始化阶段" class="headerlink" title="3.1 初始化阶段"></a>3.1 初始化阶段</h3><p>由于 Gradle 支持单模块构建或多模块构建，因此在初始化阶段（Initialization Phase），Gradle 需要知道哪些模块将参与构建。主要包含 4 步：</p>
<ul>
<li><p>1、执行 Init 脚本：</p>
<p>Initialization Scripts</p>
<p> 会在构建最开始执行，一般用于设置全局属性、声明周期监听、日志打印等。Gradle 支持多种配置 Init 脚本的方法，以下方式配置的所有 Init 脚本都会被执行：</p>
<ul>
<li>gradle 命令行指定的文件：<code>gradle —init-script &lt;file&gt;</code></li>
<li>USER_HOME&#x2F;.gradle&#x2F;init.gradle 文件</li>
<li>USER_HOME&#x2F;.gradle&#x2F;init.d&#x2F; 文件夹下的 .gradle 文件</li>
<li>GRADLE_HOME&#x2F;init.d&#x2F; 文件夹下的 .gradle 文件</li>
</ul>
</li>
<li><p><strong>2、实例化 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html">Settings</a> 接口实例：</strong> 解析根目录下的 <code>settings.gradle</code> 文件，并实例化一个 Settings 接口实例；</p>
</li>
<li><p><strong>3、执行 settings.gradle 脚本：</strong> 在 settings.gradle 文件中的代码会在初始化阶段执行；</p>
</li>
<li><p><strong>4、实例化 Project 接口实例：</strong> Gradle 会解析 <code>include</code> 声明的模块，并为每个模块 <code>build.gradle</code> 文件实例化 Project 接口实例。Gradle 默认会在工程根目录下寻找 include 包含的项目，如果你想包含其他工程目录下的项目，可以这样配置：</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 引用当前工程目录下的模块</span><br>include <span class="hljs-string">&#x27;:app&#x27;</span><br><br><span class="hljs-comment">// 引用其他工程目录下的模块</span><br>include <span class="hljs-string">&#x27;video&#x27;</span> <span class="hljs-comment">// 易错点：不要加’冒号 :‘</span><br>project(:video).projectDir = new File(<span class="hljs-string">&quot;..\\libs\\video&quot;</span>)<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示：</strong> 模块 build.gradle 文件的执行顺序和 include 顺序没有关系。</p>
</blockquote>
<h3 id="3-2-配置阶段"><a href="#3-2-配置阶段" class="headerlink" title="3.2 配置阶段"></a>3.2 配置阶段</h3><p>配置阶段（Configuration Phase）将执行 build.gradle 中的构建逻辑，以完成 Project 的配置。主要包含 3 步：</p>
<ul>
<li><strong>1、下载插件和依赖：</strong> Project 通常需要依赖其他插件或 Project 来完成工作，如果有需要先下载；</li>
<li><strong>2、执行脚本代码：</strong> 在 build.gradle 文件中的代码会在配置阶段执行；</li>
<li><strong>3、构造 Task DAG：</strong> 根据 Task 的依赖关系构造一个有向无环图，以便在执行阶段按照依赖关系执行 Task。</li>
</ul>
<blockquote>
<p><strong>提示：</strong> 执行任何 Gradle 构建命令，都会先执行初始化阶段和配置阶段。</p>
</blockquote>
<h3 id="3-3-执行阶段"><a href="#3-3-执行阶段" class="headerlink" title="3.3 执行阶段"></a>3.3 执行阶段</h3><p>在配置阶段已经构造了 Task DAG，执行阶段（Execution Phase）就是按照依赖关系执行 Task。这里有两个容易理解错误的地方：</p>
<ul>
<li><strong>1、Task 配置代码在配置阶段执行，而 Task 动作在执行阶段执行；</strong></li>
<li><strong>2、即使执行一个 Task，整个工程的初始化阶段和所有 Project 的配置阶段也都会执行，这是为了支持执行过程中访问构建模型的任何部分。</strong></li>
</ul>
<blockquote>
<p><strong>原文：</strong> This means that when a single task, from a single project is requested, <em>all</em> projects of a multi-project build are configured first. The reason every project needs to be configured is to support the flexibility of accessing and changing any part of the Gradle project model.</p>
</blockquote>
<p>介绍完三个生命周期阶段后，你可以通过以下 Demo 体会各个代码单元所处的执行阶段：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">USER_HOME<span class="hljs-regexp">/.gradle/i</span>nit.gradle<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println <span class="hljs-string">&#x27;init.gradle:This is executed during the initialization phase.&#x27;</span><br>settings.gradle<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">rootProject.name = <span class="hljs-string">&#x27;basic&#x27;</span><br>println <span class="hljs-string">&#x27;settings.gradle:This is executed during the initialization phase.&#x27;</span><br>build.gradle<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println <span class="hljs-string">&#x27;build.gradle:This is executed during the configuration phase.&#x27;</span><br><br>tasks.register(<span class="hljs-string">&#x27;test&#x27;</span>) &#123;<br>    doFirst &#123;<br>        println <span class="hljs-string">&#x27;build.gradle:This is executed first during the execution phase.&#x27;</span><br>    &#125;<br>    doLast &#123;<br>        println <span class="hljs-string">&#x27;build.gradle:This is executed last during the execution phase.&#x27;</span><br>    &#125;<br>    <span class="hljs-comment">// 易错点：这里在配置阶段执行</span><br>    println <span class="hljs-string">&#x27;build.gradle:This is executed during the configuration phase as well.&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Executing tasks: [test] <span class="hljs-keyword">in</span> project /Users/pengxurui/workspace/<span class="hljs-keyword">public</span>/EasyUpload<br><br><span class="hljs-keyword">init</span>.gradle:This <span class="hljs-keyword">is</span> executed during the initialization phase.<br>settings.gradle:This <span class="hljs-keyword">is</span> executed during the initialization phase.<br><br>&gt; Configure project :<br>build.gradle:This <span class="hljs-keyword">is</span> executed during the configuration phase.<br>build.gradle:This <span class="hljs-keyword">is</span> executed during the configuration phase <span class="hljs-keyword">as</span> well.<br><br>&gt; Task :test<br>build.gradle:This <span class="hljs-keyword">is</span> executed first during the execution phase.<br>build.gradle:This <span class="hljs-keyword">is</span> executed last during the execution phase.<br><br>...<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示：</strong> Task 在执行阶段执行有一个特例，即通过 Project#defaultTasks 指定默认任务，会在配置阶段会执行，见 <strong>第 6.2 节</strong> ，了解即可。</p>
</blockquote>
<h3 id="3-4-生命周期监听"><a href="#3-4-生命周期监听" class="headerlink" title="3.4 生命周期监听"></a>3.4 生命周期监听</h3><p>Gradle 提供了一系列监听构建生命周期流程的接口，大部分的节点都有直接的 Hook 点，这里我总结一些常用的：</p>
<ul>
<li><strong>1、监听初始化阶段</strong></li>
</ul>
<p>Gradle 接口提供了监听 Settings 初始化阶段的方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">settings.gradle<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Settings 配置完毕</span><br>gradle.settingsEvaluated &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 所有 Project 对象创建（注意：此时 build.gradle 中的配置代码还未执行）</span><br>gradle.projectsLoaded &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>2、监听配置阶段</strong></li>
</ul>
<p>Project 接口提供了监听当前 Project 配置阶段执行的方法，其中 afterEvaluate 常用于在 Project 配置完成后继续增加额外的配置，例如 Hook 构建过程中的 Task。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 执行 build.gradle 前</span><br>project.beforeEvaluate &#123; <br>    ...<br>&#125;<br><br><span class="hljs-comment">// 执行 build.gradle 后</span><br>project.afterEvaluate &#123; <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除此之外，Gradle 接口也提供了配置阶段的监听：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行 build.gradle 前</span><br>gradle.beforeProject &#123; project -&gt;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 执行 build.gradle 后</span><br>gradle.afterProject &#123; project -&gt;<br>    <span class="hljs-comment">// 配置后，无论成功或失败</span><br>    <span class="hljs-keyword">if</span> (project.state.failure) &#123;<br>        println <span class="hljs-string">&quot;Evaluation of $project FAILED&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        println <span class="hljs-string">&quot;Evaluation of $project succeeded&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 与 project.beforeEvaluate 和 project.afterEvaluate 等价</span><br>gradle.addProjectEvaluationListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProjectEvaluationListener</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeEvaluate</span><span class="hljs-params">(Project project)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterEvaluate</span><span class="hljs-params">(Project project, ProjectState projectState)</span> &#123;<br>        ...<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 依赖关系解析完毕</span><br>gradle.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DependencyResolutionListener</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeResolve</span><span class="hljs-params">(ResolvableDependencies dependencies)</span> &#123;<br>        ....<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterResolve</span><span class="hljs-params">(ResolvableDependencies dependencies)</span> &#123;<br>        ....<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// Task DAG 构造完毕</span><br>gradle.taskGraph.whenReady &#123;   <br>&#125;<br><br><span class="hljs-comment">// 与 gradle.taskGraph.whenReady 等价</span><br>gradle.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskExecutionGraphListener</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">graphPopulated</span><span class="hljs-params">(TaskExecutionGraph graph)</span> &#123;<br>        ...<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 所有 Project 的 build.gradle 执行完毕</span><br>gradle.projectsEvaluated &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>3、监听执行阶段</strong></li>
</ul>
<p>Gradle 接口提供了执行阶段的监听：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">gradle.addListener(new TaskExecutionListener() &#123;<br><br>    <span class="hljs-comment">// 执行 Task 前</span><br>    <span class="hljs-meta">@Override</span><br>    void beforeExecute(Task task) &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">// 执行 Task 后</span><br>    <span class="hljs-meta">@Override</span><br>    void afterExecute(Task task, TaskState state) &#123;<br>        ...<br>    &#125;<br>&#125;)<br><br>gradle.addListener(new TaskActionListener() &#123;<br><br>    <span class="hljs-comment">// 开始执行 Action 列表前，回调时机略晚于 TaskExecutionListener#beforeExecute</span><br>    <span class="hljs-meta">@Override</span><br>    void beforeActions(Task task) &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">// 执行 Action 列表完毕，回调时机略早于 TaskExecutionListener#afterExecute</span><br>    <span class="hljs-meta">@Override</span><br>    void afterActions(Task task) &#123;<br>        ...<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 执行 Task 前</span><br>gradle.taskGraph.beforeTask &#123; Task task -&gt;<br>&#125;<br><br><span class="hljs-comment">// 执行 Task 后</span><br>gradle.taskGraph.afterTask &#123; Task task, TaskState state -&gt;<br>    <span class="hljs-keyword">if</span> (state.failure) &#123;<br>        println <span class="hljs-string">&quot;FAILED&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        println <span class="hljs-string">&quot;done&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>4、监听 Task 创建</strong></li>
</ul>
<p>TaskContainer 接口提供了监听 Task 添加的方法，可以在 Task 添加到 Project 时收到回调：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">tasks.whenTaskAdded &#123; task -&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>5、监听构建结束</strong></li>
</ul>
<p>当所有 Task 执行完毕，意味着构建结束：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">gradle.buildFinished &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="4-Project-核心-API"><a href="#4-Project-核心-API" class="headerlink" title="4. Project 核心 API"></a>4. Project 核心 API</h2><p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://docs.gradle.org/current/dsl/org.gradle.api.Project.html">Project</a> 可以理解为模块的构建管理器，在初始化阶段，Gradle 会为每个模块的 build.gradle 文件实例化一个接口对象。在 .gradle 脚本中编写的代码，本质上可以理解为是在一个 Project 子类中编写的。</p>
<h3 id="4-1-Project-API"><a href="#4-1-Project-API" class="headerlink" title="4.1 Project API"></a>4.1 Project API</h3><p>Project 提供了一系列操作 Project 对象的 API：</p>
<ul>
<li><strong>getProject()：</strong> 返回当前 Project；</li>
<li><strong>getParent()：</strong> 返回父 Project，如果在工程 RootProject 中调用，则会返回 null；</li>
<li><strong>getRootProject()：</strong> 返回工程 RootProject；</li>
<li><strong>getAllprojects()：</strong> 返回一个 Project Set 集合，包含当前 Project 与所有子 Project；</li>
<li><strong>getSubprojects()：</strong> 返回一个 Project Set 集合，包含所有子 Project；</li>
<li><strong>project(String)：</strong> 返回指定 Project，不存在时抛出 UnKnownProjectException；</li>
<li><strong>findProject(String)：</strong> 返回指定 Project，不存在时返回 null；</li>
<li><strong>allprojects(Closure)：</strong> 为当前 Project 以及所有子 Project 增加配置；</li>
<li><strong>subprojects(Closure)：</strong> 为所有子 Project 增加配置。</li>
</ul>
<h3 id="4-2-Project-属性-API"><a href="#4-2-Project-属性-API" class="headerlink" title="4.2 Project 属性 API"></a>4.2 Project 属性 API</h3><p>Project 提供了一系列操作属性的 API，通过属性 API 可以实现在 Project 之间共享配置参数：</p>
<ul>
<li><strong>hasProperty(String)：</strong> 判断是否存在指定属性名；</li>
<li><strong>property(Stirng)：</strong> 获取属性值，如果属性不存在则抛出 MissingPropertyException；</li>
<li><strong>findProperty(String)：</strong> 获取属性值，如果属性不存在则返回 null；</li>
<li><strong>setProperty(String, Object)：</strong> 设置属性值，如果属性不存在则抛出 MissingPropertyException。</li>
</ul>
<p>实际上，你不一定需要显示调用这些 API，当我们直接使用属性名时，Gradle 会帮我们隐式调用 property() 或 setProperty()。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">build.gradle<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">name =&gt; 相当于 project.getProperty(<span class="hljs-string">&quot;name&quot;</span>)<br>project.name = <span class="hljs-string">&quot;Peng&quot;</span> =&gt; 相当于 project.setProperty(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Peng&quot;</span>)<br></code></pre></td></tr></table></figure>

<p><strong>4.2.1 属性匹配优先级</strong></p>
<p>Project 属性的概念比我们理解的字段概念要复杂些，不仅仅是一个简单的键值对。Project 定义了 4 种命名空间（scopes）的属性 —— <strong>自有属性、Extension 属性、ext 属性、Task。</strong> 当我们通过访问属性时，会按照这个优先级顺序搜索。</p>
<p><code>getProperty()</code> 的搜索过程：</p>
<ul>
<li>1、自有属性： Project 对象自身持有的属性，例如 rootProject 属性；</li>
<li>2、Extension 属性；</li>
<li>3、ext 属性；</li>
<li>4、Task： 添加到 Project 上的 Task 也支持通过属性 API 访问；</li>
<li>5、父 Project 的 ext 属性： 会被子 Project 继承，因此当 1 ~ 5 未命中时，会继续从父 Project 搜索。需要注意： <strong>从父 Project 继承的属性是只读的；</strong></li>
<li>6、以上未命中，抛出 MissingPropertyException 或返回 null。</li>
</ul>
<p><code>setProperty()</code> 的搜索路径（由于部分属性是只读的，搜索路径较短）：</p>
<ul>
<li>1、自有属性</li>
<li>2、ext 额外属性</li>
</ul>
<blockquote>
<p><strong>提示：</strong> 其实还有 Convention 命名空间，不过已经过时了，我们不考虑。</p>
</blockquote>
<p><strong>4.2.2 Extension 扩展</strong></p>
<p>Extension 扩展是插件为外部构建脚本提供的配置项，用于支持外部自定义插件的工作方式，其实就是一个对外开放的 Java Bean 或 Groovy Bean。例如，我们熟悉的 <code>android&#123;&#125;</code> 就是 Android Gradle Plugin 提供的扩展。</p>
<p>关于插件 Extension 扩展的更多内容，见下一篇文章。</p>
<p><strong>4.2.3 ext 属性</strong></p>
<p>Gradle 为 Project 和 Task 提供了 ext 命名空间，用于定义额外属性。如前所述，子 Project 会继承 父 Project 定义的 ext 属性，但是只读的。我们经常会在 Root Project 中定义 ext 属性，而在子 Project 中可以直接复用属性值，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">项目 build.gradle<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ext &#123;<br>    kotlin_version = <span class="hljs-string">&#x27;1.4.31&#x27;</span><br>&#125;<br>模块 build.gradle<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 如果子 Project 也定义了 kotlin_version 属性，则不会引用父 Project</span><br>implementation <span class="hljs-string">&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:<span class="hljs-variable">$kotlin_version</span>&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="4-3-Project-文件-API"><a href="#4-3-Project-文件-API" class="headerlink" title="4.3 Project 文件 API"></a>4.3 Project 文件 API</h3><p><strong>4.3.1 文件路径</strong></p>
<ul>
<li><strong>getRootDir()：</strong> Project 的根目录（不是工程根目录）</li>
<li><strong>getProjectDir()：</strong> 包含 build 文件夹的项目目录</li>
<li><strong>getBuildDir()：</strong> build 文件夹目录</li>
</ul>
<p><strong>4.3.2 文件获取</strong></p>
<ul>
<li><strong>File file(Object path)：</strong> 获取单个文件，相对位置从当前 Project 目录开始</li>
<li><strong>ConfigurableFileCollection files(Object… paths)：</strong> 获取多个文件，相对位置从当前 Project 目录开始</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def destFile = file(<span class="hljs-string">&#x27;releases.xml&#x27;</span>)<br><span class="hljs-keyword">if</span> (destFile != <span class="hljs-literal">null</span> &amp;&amp; !destFile.exists()) &#123;<br>    destFile.createNewFile()<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>4.3.3 文件拷贝</strong></p>
<ul>
<li><strong>copy(Closure)：</strong> 文件拷贝，参数闭包用于配置 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://docs.gradle.org/current/javadoc/org/gradle/api/file/CopySpec.html">CodeSpec</a> 对象</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">copy &#123;<br>    <span class="hljs-comment">// 来源文件</span><br>    from file(<span class="hljs-string">&quot;build/outputs/apk&quot;</span>)<br>    <span class="hljs-comment">// 目标文件</span><br>    into getRootProject().getBuildDir().path + <span class="hljs-string">&quot;/apk/&quot;</span><br>    exclude &#123;<br>        <span class="hljs-comment">// 排除不需要拷贝的文件</span><br>    &#125;<br>    rename &#123;<br>        <span class="hljs-comment">// 对拷贝过来的文件进行重命名</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>4.3.4 文件遍历</strong></p>
<ul>
<li><strong>fileTree(Object baseDir)：</strong> 将指定目录转化为文件树，再进行遍历操作</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">fileTree(<span class="hljs-string">&quot;build/outputs/apk&quot;</span>) &#123; FileTree fileTree -&gt;<br>    fileTree.visit &#123; FileTreeElement fileTreeElement -&gt;<br>        <span class="hljs-comment">// 文件操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="5-Task-核心-API"><a href="#5-Task-核心-API" class="headerlink" title="5. Task 核心 API"></a>5. Task 核心 API</h2><p>Project 的构建逻辑由一系列 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://docs.gradle.org/current/dsl/org.gradle.api.Task.html">Task</a> 的组成，每个 Task 负责完成一个基本的工作，例如 Javac 编译 Task、资源编译 Task、Lint 检查 Task，签名 Task等。在构建配置阶段，Gradle 会根据 Task 的依赖关系构造一个有向无环图，以便在执行阶段按照依赖关系执行 Task。</p>
<h3 id="5-1-创建简单-Task"><a href="#5-1-创建简单-Task" class="headerlink" title="5.1 创建简单 Task"></a>5.1 创建简单 Task</h3><p>Gradle 支持两种创建简单 Task 的语法：</p>
<ul>
<li><strong>1、通过 task 关键字：</strong></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 创建名为 MyTask 的任务</span><br>task MyTask(group: <span class="hljs-string">&quot;MyGroup&quot;</span>) &#123;<br>    <span class="hljs-comment">// Task 配置代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>2、通过 TaskContainer 方法：</p>
<p> 通过 Project 的 </p>
<p>TaskContainer</p>
<p> 属性，可以创建 Task，分为热创建和懒创建：</p>
<ul>
<li><strong>Task create(String, Closure) 热创建：</strong> 立即实例化 Task 对象；</li>
<li><strong>TaskProvider register(String, Closure) 懒创建：</strong> 注册 Task 构造器，但不会实例化对象。创建 Task 操作会延迟到访问该 Task 时，例如通过 TaskProvider#get() 或 TaskContainer#getByName()。</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 创建名为 MyTask 的任务</span><br>project.tasks.create(name: <span class="hljs-string">&quot;MyTask&quot;</span>) &#123;<br>    <span class="hljs-comment">// Task 配置代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-2-创建增强-Task（自定义-Task-类型）"><a href="#5-2-创建增强-Task（自定义-Task-类型）" class="headerlink" title="5.2 创建增强 Task（自定义 Task 类型）"></a>5.2 创建增强 Task（自定义 Task 类型）</h3><p>除了简单创建 Task 的方式，我们还可以自定义 Task 类型，Gradle 将这类 Task 称为增强 Task。增强 Task 的可重用性更好，并且可以通过暴露属性的方式来定制 Task 的行为。</p>
<ul>
<li><strong>1、DefaultTask：</strong> 自定义 Task 必须继承 DefaultTask。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTask</span> <span class="hljs-title">extends</span> <span class="hljs-title">DefaultTask</span> &#123;<br>    <span class="hljs-keyword">final</span> String message<br>    <span class="hljs-keyword">final</span> int number<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>2、带参数创建 Task：</strong> 除了可以在创建 Task 后配置属性值，我们也可以在调用 TaskContainer#create() 时传递构造器参数。为了将值传递给任务构造函数，必须使用 <code>@Inject</code> 注解修饰构造器。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTask</span> <span class="hljs-title">extends</span> <span class="hljs-title">DefaultTask</span> &#123;<br>    <span class="hljs-keyword">final</span> String message<br>    <span class="hljs-keyword">final</span> int number<br><br>    <span class="hljs-meta">@Inject</span><br>    CustomTask(String message, int number) &#123;<br>        <span class="hljs-keyword">this</span>.message = message<br>        <span class="hljs-keyword">this</span>.number = number<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 第二个参数为 Task 类型</span><br>tasks.register(<span class="hljs-string">&#x27;myTask&#x27;</span>, CustomTask, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">42</span>)<br></code></pre></td></tr></table></figure>

<h3 id="5-3-获取已创建-Task"><a href="#5-3-获取已创建-Task" class="headerlink" title="5.3 获取已创建 Task"></a>5.3 获取已创建 Task</h3><p>可以获取 TaskContainer 中已创建的任务，对于通过 register 注册的任务会在这个时机实例化。例如：</p>
<ul>
<li><strong>Task getByName(String)：</strong> 获取 Task，如果 Task 不存在则抛出 UnKnownDomainObjectException；</li>
<li><strong>Task findByName(String)：</strong> 获取 Task，如果 Task 不存在则返回 null。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 获取已创建的 Task</span><br>project.MyTask.name =&gt; 等同于 project.tasks.getByName(<span class="hljs-string">&quot;MyTask&quot;</span>).name<br></code></pre></td></tr></table></figure>

<h3 id="5-4-设置-Task-属性"><a href="#5-4-设置-Task-属性" class="headerlink" title="5.4 设置 Task 属性"></a>5.4 设置 Task 属性</h3><p>设置 Task 属性的语法主要有三种：</p>
<ul>
<li><strong>1、在创建 Task 时设置</strong></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">task MyTask(group: <span class="hljs-string">&quot;MyGroup&quot;</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>2、通过 setter 方法设置</strong></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">task MyTask &#123;<br>    group = <span class="hljs-string">&quot;MyGroup&quot;</span> =&gt; 等同于 setGroup(<span class="hljs-string">&quot;MyGroup&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>3、通过 ext 额外属性设置：</strong> Task 也支持与 Project 类似的额外属性。例如：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">task MyTask(group:<span class="hljs-string">&quot;111&quot;</span>) &#123;<br>    ext.goods = <span class="hljs-number">2</span><br>&#125;<br><br>ext.goods = <span class="hljs-number">1</span><br><br>println MyTask.good<br><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>Task 常用的自有属性如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>Task 标识符，在定义 Task 时指定</td>
</tr>
<tr>
<td>group</td>
<td>Task 所属的组</td>
</tr>
<tr>
<td>description</td>
<td>Task 的描述信息</td>
</tr>
<tr>
<td>type</td>
<td>Task类型，默认为 DefaultTask</td>
</tr>
<tr>
<td>actions</td>
<td>动作列表</td>
</tr>
<tr>
<td>dependsOn</td>
<td>依赖列表</td>
</tr>
</tbody></table>
<p><strong>注意事项：</strong></p>
<ul>
<li>严格避免使用带空格的 Task <code>name</code>，否则在一些版本的 Android Studio 中会被截断，导致不兼容；</li>
<li>Android Studio 的 Gradle 面板会按照 <code>group</code> 属性对 Task 进行分组显示。其中， Tasks 组为 Root Project 中的 Task，其他分组为各个 Project 中的 Task，未指定 group 的 Task 会分配在 other 中。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/10107787-c2e886fa45923c55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/784/format/webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="5-5-执行-Task"><a href="#5-5-执行-Task" class="headerlink" title="5.5 执行 Task"></a>5.5 执行 Task</h3><ul>
<li><strong>1、命令行：</strong> gradlew :[模块名]:[任务名]，例如：gradlew -q :app:dependencies</li>
<li><strong>2、IDE 工具：</strong> 通过 IDE 提供的用户界面工具执行，例如 Gradle 面板或绿色三角形，支持普通执行和调试执行；</li>
<li><strong>3、默认任务：</strong> 通过 Project#defaultTasks 可以指定 Project 配置阶段的默认任务，在配置阶段会执行（这说明 Task 是有可能在配置阶段执行的，了解即可，不用钻牛角尖）。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">build.gradle<br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">defaultTasks <span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;hello2&#x27;</span><br><br>task hello &#123;<br>    println <span class="hljs-string">&quot;defaultTasks hello&quot;</span><br>&#125;<br><br>task hello2 &#123;<br>    println <span class="hljs-string">&quot;defaultTasks hello2&quot;</span><br>&#125;<br><br>输出：<br>&gt; Configure project :easyupload<br>defaultTasks hello<br>defaultTasks hello2<br>--afterEvaluate--<br>--taskGraph.whenReady--<br></code></pre></td></tr></table></figure>

<h3 id="5-6-Task-Action-动作"><a href="#5-6-Task-Action-动作" class="headerlink" title="5.6 Task Action 动作"></a>5.6 Task Action 动作</h3><p>每个 Task 内部都保持了一个 Action 列表 <code>actions</code>，执行 Task 就是按顺序执行这个列表，Action 是比 Task 更细的代码单元。Task 支持添加多个动作，Task 提供了两个方法来添加 Action：</p>
<ul>
<li><strong>doFirst(Closure)：</strong> 在 Action 列表头部添加一个 Action；</li>
<li><strong>doLast(Closure)：</strong> 在 Action 列表尾部添加一个 Action。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">task MyTask<br><br>MyTask.doFirst&#123;<br>    println <span class="hljs-string">&quot;Action doFirst 1&quot;</span><br>&#125;<br><br>MyTask.doFirst&#123;<br>    println <span class="hljs-string">&quot;Action doFirst 2&quot;</span><br>&#125;<br><br>MyTask.doLast&#123;<br>    println <span class="hljs-string">&quot;Action doLast 1&quot;</span><br>&#125;<br><br>执行 MyTask 输出:<br><br>Action doFirst <span class="hljs-number">2</span><br>Action doFirst <span class="hljs-number">1</span><br>Action doLast <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>对于自定义 Task，还可以通过 <code>@TaskAction</code> 注解添加默认 Action。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTask</span> <span class="hljs-title">extends</span> <span class="hljs-title">DefaultTask</span> &#123;<br>    <span class="hljs-meta">@TaskAction</span><br>    def greet() &#123;<br>        println <span class="hljs-string">&#x27;hello from GreetingTask&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-7-跳过-Task-的执行"><a href="#5-7-跳过-Task-的执行" class="headerlink" title="5.7 跳过 Task 的执行"></a>5.7 跳过 Task 的执行</h3><p>并不是所有 Task 都会被执行，Gradle 提供了多个方法来控制跳过 Task 的执行：</p>
<ul>
<li><strong>1、onlyIf{}：</strong> 闭包会在即将执行 Task 之前执行，闭包返回值决定了是否执行 Task；</li>
<li><strong>2、enabled 属性：</strong> Task 的 enabled 属性默认为 true，设置为 false 表示无效任务，不需要执行。</li>
</ul>
<p>剩下两种方式允许在执行 Task 的过程中中断执行：</p>
<ul>
<li><p>3、Task 异常：</p>
<p> Task 提供了两个异常，能够当 Action 执行过程中抛出以下异常，将跳过执行并继续后续的构建过程：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/StopActionException.html">StopActionException</a>：</strong> 中断当前 Action，并继续当前 Task 的下一个 Action；</li>
<li><strong><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/StopExecutionException.html">StopExecutionException</a>：</strong> 中断当前 Task，并继续 Task 依赖树上的下一个 Action。</li>
</ul>
</li>
<li><p><strong>4、timeouts 属性：</strong> 当 Task 执行时间到达 timeouts 超时时间时，执行线程会收到一个中断信号，可以借此许控制 Task 的执行时间（前提是 Task 要响应中断信号）。</p>
</li>
</ul>
<h3 id="5-8-Task-依赖关系"><a href="#5-8-Task-依赖关系" class="headerlink" title="5.8 Task 依赖关系"></a>5.8 Task 依赖关系</h3><p>通过建立 Task 的依赖关系可以构建完成的 Task 有向无环图：</p>
<ul>
<li><strong>dependsOn 强依赖：</strong> Task 通过 dependsOn 属性建立强依赖关系，可以直接通过 dependsOn 属性设置依赖列表，也可以通过 dependsOn() 方法添加一个依赖；</li>
<li><strong>输入输出隐式依赖：</strong> 通过建立 Task 之间的输入和输出关系，也会隐式建立依赖关系。例如 Transform Task 之间就是通过输入输出建立的依赖关系。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 通过属性设置依赖列表</span><br>task task3(dependsOn: [task1, task2]) &#123;<br>&#125;<br><br><span class="hljs-comment">// 添加依赖</span><br>task3.dependsOn(task1, task2)<br><br>依赖关系：task3 依赖于 [task1, task2]，在执行 task3 前一定会执行 task1 和 task2<br></code></pre></td></tr></table></figure>

<p>在某些情况下，控制两个任务的执行顺序非常有用，而不会在这些任务之间引入显式依赖关系，可以理解为弱依赖。 <strong>任务排序和任务依赖关系之间的主要区别在于，排序规则不影响将执行哪些任务，只影响任务的执行顺序。</strong></p>
<ul>
<li><strong>mustRunAfter 强制顺序：</strong> 指定强制要求的任务执行顺序；</li>
<li><strong>shouldRunAfter 非强制顺序：</strong> 指定非强制的任务执行顺序，在两种情况下会放弃此规则：1、该规则造成环形顺序；2、并行执行并且任务的所有依赖项都已经完成。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">task3 mustRunAfter(task1, task2)<br>task3 shouldRunAfter(task1, task2)<br><br>依赖关系：无，在执行 task3 前不一定会执行 task1 和 task2<br>顺序关系：[task1, task2] 优先于 task3<br></code></pre></td></tr></table></figure>

<h3 id="5-9-Finalizer-Task"><a href="#5-9-Finalizer-Task" class="headerlink" title="5.9 Finalizer Task"></a>5.9 Finalizer Task</h3><p>给一个 Task 添加 Finalizer 终结器任务后，无论 Task 执行成功还是执行失败，都会执行终结器，这对于需要在 Task 执行完毕后清理资源的情况非常有用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// taskY 是 taskX 的终结器</span><br>taskX finalizedBy taskY<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="6-增量构建"><a href="#6-增量构建" class="headerlink" title="6. 增量构建"></a>6. 增量构建</h2><h3 id="6-1-什么是增量构建？"><a href="#6-1-什么是增量构建？" class="headerlink" title="6.1 什么是增量构建？"></a>6.1 什么是增量构建？</h3><p>任何构建工具都会尽量避免重复执行相同工作，这一特性称为 Incremental Build 增量构建，这一特性能够节省大量构建时间。例如编译过源文件后就不应该重复编译，除非发生了影响输出的更改（例如修改或删除源文件）。</p>
<p>Gradle 通过对比自从上一次构建之后，Task 的 <code>inputs</code> 和 <code>outputs</code> 是否变化，来决定是否跳过执行。如果相同，则 Gralde 认为 Task 是最新的，从而会跳过执行。在 Build Outputs 中看到 Task 名称旁边出现 <code>UP-TO-DATE</code> 标志，即说明该 Task 是被跳过的。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&gt; Task :easyupload:compileJava NO-SOURCE<br>&gt; Task :easyupload:compileGroovy UP-TO-DATE<br>&gt; Task :easyupload:pluginDescriptors UP-TO-DATE<br>&gt; Task :easyupload:processResources UP-TO-DATE<br>&gt; Task :easyupload:classes UP-TO-DATE<br>&gt; Task :easyupload:jar UP-TO-DATE<br>&gt; Task :easyupload:uploadArchives<br></code></pre></td></tr></table></figure>

<p>那么，在定义 Task 的输入输出时，要遵循一个原则：如果 Task 的一个属性会影响输出，那么应该将该属性注册为输入，否则会影响 Task 执行；相反，如果 Task 的一个属性不会影响输出，那么不应该将该属性注册为输入，否则 Task 会在不必要时执行。</p>
<h3 id="6-2-Task-输入输出"><a href="#6-2-Task-输入输出" class="headerlink" title="6.2 Task 输入输出"></a>6.2 Task 输入输出</h3><p>大多数情况下，Task 需要接收一些 input 输入，并生成一些 output 输出。例如编译任务，输入是源文件，而输出是 Class 文件。Task 使用 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/TaskInputs.html">TaskInputs</a> 和 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/TaskOutputs.html">TaskOutputs</a> 管理输入输出：</p>
<ul>
<li><strong>Task#inputs：</strong> 返回 Task 的 TaskInputs 输入管理器；</li>
<li><strong>Task#outputs：</strong> 返回 Task 的 TaskOutputs 输出管理器。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/10107787-f1855a3d63d32d5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>对于 Task 的输入输出，我们用面向对象的概念去理解是没问题的。如果我们把 Task 理解为一个函数，则 Task 的输入就是函数的参数，而 Task 的输出就是函数的返回值。在此理解的基础上，再记住 2 个关键点：</p>
<ul>
<li><strong>1、隐式依赖：</strong> 如果一个 Task 的输入是另一个 Task 的输出，Gradle 会推断出两者之间的强依赖关系；</li>
<li><strong>2、在配置阶段声明：</strong> 由于 Task 的输入输出会用于构建依赖关系，那么我们应该确保在配置阶段定义输入输出，而不是在执行阶段定义。</li>
</ul>
<p><strong>Task 支持三种形式的输入：</strong></p>
<ul>
<li><strong>1、简单值：</strong> 包括数值、字符串和任何实现 Serializable 的类；</li>
<li><strong>2、文件：</strong> 包括单个文件或文件目录；</li>
<li><strong>3、嵌套对象：</strong> 不满足以上两种条件，但其字段声明为输入。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessTemplates</span> <span class="hljs-title">extends</span> <span class="hljs-title">DefaultTask</span> &#123;<br><br>    <span class="hljs-meta">@Input</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Property&lt;TemplateEngineType&gt; getTemplateEngine();<br><br>    <span class="hljs-meta">@InputFiles</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ConfigurableFileCollection getSourceFiles();<br><br>    <span class="hljs-meta">@Nested</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> TemplateData getTemplateData();<br><br>    <span class="hljs-meta">@OutputDirectory</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> DirectoryProperty getOutputDir();<br><br>    <span class="hljs-meta">@TaskAction</span><br>    <span class="hljs-keyword">public</span> void processTemplates() &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplateData</span> &#123;<br><br>    <span class="hljs-meta">@Input</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Property&lt;String&gt; getName();<br><br>    <span class="hljs-meta">@Input</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> MapProperty&lt;String, String&gt; getVariables();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-3-Task-输入输出校验"><a href="#6-3-Task-输入输出校验" class="headerlink" title="6.3 Task 输入输出校验"></a>6.3 Task 输入输出校验</h3><p>通过注解方式注册输入输出时，Gradle 会在配置阶段会对属性值进行检查。如果属性值不满足条件，则 Gradle 会抛出 <code>TaskValidationException</code> 异常。特殊情况时，如果允许输入为 null 值，可以添加 <code>@Optional</code> 注解表示输入可空。</p>
<ul>
<li><strong>@InputFile：</strong> 验证该属性值不为 null，并且关联一个文件（而不是文件夹），且该文件存在；</li>
<li><strong>@InputDirectory：</strong> 验证该属性值不为 null，并且关联一个文件夹（而不是文件），且该文件夹存在；</li>
<li><strong>@OutputDirectory：</strong> 验证该属性值不为 null，并且关联一个文件夹（而不是文件），当该文件夹不存在时会创建该文件夹。</li>
</ul>
<h1 id="Part3-——-Gradle-拓展"><a href="#Part3-——-Gradle-拓展" class="headerlink" title="Part3 —— Gradle 拓展"></a>Part3 —— Gradle 拓展</h1><blockquote>
<p>正如大家看到了 Gradle 的内容很多，仅仅只是源码和基础就已经占了比较大的篇幅，Gradle 不像 java ，新版本会对旧版本进行兼容，Gradle的更新迭代很快且变化很大，因此学习成本很大，但是收获也是很大的，如果很好地掌握 gradle，大家能够更好地管理自己的项目，不单单是通过编写插件来实现另外的功能，还有gradle的很多特性也能很好地帮助我们，lint，build-scan，Transform，都是值得学习的，只不过在下学艺不精，让我去写可能会有大量篇幅的废话，所以还是在这里给大家提供学习的思路和资料吧，相信在前面两章的学习，大家对 Gradle 源码以及 Gradle 基础已经有比较大的了解。</p>
</blockquote>
<h2 id="视频资料"><a href="#视频资料" class="headerlink" title="视频资料"></a>视频资料</h2><p><a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PL0UJI1nZ56yDZSgsL1Gf4_krgTMhuotYM">油管上的一个up，适合入门</a></p>
<p>GradleBuildBiblev</p>
<p>《GradleBuildBiblev》一本我花了100大洋买的电子书，也就是上面的up写的，之后我会发在群里</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLWQK2ZdV4Yl2k2OmC_gsjDpdIBTN0qqkE">gradle中心化管理，进阶(个人感觉讲的很好)</a></p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/28615855/channel/seriesdetail?sid=297909">bennyhuo的gradle视频，虽然涉及的内容很少，但都是干货，而且很有意思，值得看</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1DE411Z7nt?spm_id_from=333.337.search-card.all.click">这是Gradle官方的一个视频，我觉得算是入门必看，如果对gradle的基本流程和概念比较模糊的同学，可以看一下，讲的很清晰，毕竟是官方开发人员</a></p>
<h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><p><a target="_blank" rel="noopener" href="https://docs.gradle.org/7.5/userguide/custom_plugins.html">官网</a>  官网yyds，甚至可以把官网所有内容都看完，因为这里的内容几乎涵盖了前面的所有内容，只不过写的很烂，并不是指内容烂，而是它的排版，因为官网的内容很零散，所以阅读难度很大，所以建议有一定水平后再去看，看完都行，很有意思的。</p>
<p><a target="_blank" rel="noopener" href="https://scans.gradle.com/#gradle">Build Scan 官网</a> 这个我其实用的比较少，只是稍微玩了一下，有兴趣的可以看看</p>
<p><a target="_blank" rel="noopener" href="https://plugins.gradle.org/search?term=base">Gradle plugins</a></p>
<p>掌邮的 Gradle，现在已经被蔷神和郭神改的很好了，大家可以去学习学习。</p>
<blockquote>
<p>不要看好像不多，其实涵盖的内容已经是巨大了，光是官网含有的内容已经够喝了，当然大家也没必要在 gradle 上花太大的时间，毕竟提高 coding 能力才是最关键的，gradle 往往起到的是锦上添花的作用。</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Android/">#Android</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入学习Gradle</div>
      <div>http://example.com/2022/10/07/Gradle相关/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>October 7, 2022</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/08/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/" title="事件分发">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">事件分发</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/29/%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3/" title="学习Android动画">
                        <span class="hidden-mobile">学习Android动画</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
